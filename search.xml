<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021 backing</title>
    <url>/2022/01/01/2021-backing/</url>
    <content><![CDATA[<h2 id="回首2021"><a href="#回首2021" class="headerlink" title="回首2021"></a>回首2021</h2><p>大家好，我是小八，是一名HUT的大二在校本科生，今天写一篇博客来说说2021我的成长之旅吧。</p>
<h3 id="2021年上半年（大一下学期）"><a href="#2021年上半年（大一下学期）" class="headerlink" title="2021年上半年（大一下学期）"></a>2021年上半年（大一下学期）</h3><h4 id="2021-1-1"><a href="#2021-1-1" class="headerlink" title="2021.1.1"></a>2021.1.1</h4><p>大病初愈的我，和我好兄弟们跨过了第二个大学元旦，也抓到了2021年的第一个娃娃，而这也是我新的一年的开始，那时候的我也才大一下学期，对未来也只是仅仅抱着幻想，但仍然十分的迷茫和无奈。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/20210101.jpg?versionId=CAEQGRiBgMDPtKvZ8BciIDhiZWMwZDEyYTRjODRjMjk5YTc3NTcxZWJkY2FiMmQy" alt="20210101"></p>
<h4 id="2021-1-1—2021-3-13"><a href="#2021-1-1—2021-3-13" class="headerlink" title="2021.1.1—2021.3.13"></a>2021.1.1—2021.3.13</h4><p>这段时间，没错正如我所说的，非常迷茫、无知，天天除了打游戏，打篮球，和好兄弟们一起在外面狂嗨等，也没啥事干，可以说是天天无所事事，天天在学校混世度日，虽然我的综合成绩排名在年级也混得过去，不算很差（年级几十名吧），但真的算不上优秀。</p>
<p>可是当时的我真的不知道去干嘛，但应该去做一些什么有意义的事情。</p>
<h4 id="2021-3-14"><a href="#2021-3-14" class="headerlink" title="2021.3.14"></a>2021.3.14</h4><p>我遇到了我生命中除了亲朋好友之外最喜欢的人——那个她，在这一天，我们官宣了，实际上我们当时2021.3.12号就在一起了，我在那之后的每一周周末都会去陪着我喜欢的人，一起开心的玩耍，当时我以为，这样的我，算是走出了一点点的迷茫大学生涯，其实我还是一个迷茫的憨批。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/20210314.jpg?versionId=CAEQGRiBgMDZtKvZ8BciIGUxODM4YTRiMThlMjQwNWE5MTUwMDA3OTRjOWNjMzJh" alt="20210314"></p>
<h4 id="2021-3-27"><a href="#2021-3-27" class="headerlink" title="2021.3.27"></a>2021.3.27</h4><p>这一天，我真的可以说是上天给我了一个莫名的惊喜，我肯定要好好把握住这一个很好的机会，毕竟我当时也意识到了自己的迷茫，而这也算是人生中的一次转折点吧，很高兴遇到了这个学长，有一说一，我和他的大学经历，真的很像，因为他给的这个机会，我真的有了很大的改变，也就有了后面很大的学习动力和进步，但是这也需要付出一定的代价。那时候，我也便开始了我的java学习之旅。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/202103271.png?versionId=CAEQGRiBgICktKvZ8BciIDhjNTdhNzFhNDIxNzQzMmFiZGY1YTU2NjE2MzAwOWRm" alt="20210327 1"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/202103272.png?versionId=CAEQGRiBgICdtKvZ8BciIDMzNjVlZjI2MDA4ODRhNjNiODc4MjQ3ODRmNzk1MWIy" alt="20210327 2"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/202103273.png?versionId=CAEQGRiBgMCntKvZ8BciIDcwYmE5MTc5Yjk2NjQ2YzA4M2Q0YTM1MGIxZTU5ZDk3" alt="20210327 3"></p>
<p>可是好景不长，果然我要付出的代价来了，我和我的好兄弟，也因为这个，渐渐减少了和他们一起聚会，一起快乐，一起玩耍，一起做我们大学生想做的事情，想想真的挺烦的，但是也没有办法，说点自私的，我也是在为自己的未来奋斗，毕竟我实力有限，我也只能独自前行，不能带着他们一起进步。</p>
<p>虽说后悔，但是我也无法后退，既然踏出了那一步，我只能看好当下，而不是留在过去，只想着能够在自己变优秀之后，慢慢再带着他们一起变优秀，一起在大学留下属于自己的足迹。</p>
<h4 id="2021-6月"><a href="#2021-6月" class="headerlink" title="2021.6月"></a>2021.6月</h4><p>我们学院为了迎接新生，辅导员需要在19级和20级学生里面选一部分同学当大小班助，为21级新生的到来提供我们力所能及的帮助，并为他们解决进入大学之后的迷茫，无知。可是在我看来，其实当时的我，也顶多只是比21级新生多了一点点“如何在大学生存下去”的生活常识？</p>
<p>但是我想着这也是一次锻炼自己的机会，我当然不想放弃，果断下定决心，参加这一次的选拔，记得当时报名的人有一百来个吧，我也不知道能不能选上，单纯就抱着一个尝试的心理去面试了，没想到当时真的通过了老师和各个主席的认同，当上了2107班的小班助。</p>
<p>在得到这次机会之后，也是临近放假的时候，当时就在想，当上了小班助可得懂得更多一点，那这暑假更不能闲着了，得好好学学还没有学完的java了，到时候可不能比大部分新生差啊。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/20216.jpg?versionId=CAEQGRiBgICptKvZ8BciIDhjZjdhYzU4NmJlODQ0MGRhM2UzY2M1ZTNiMmE1YzQ1" alt="20216"></p>
<h3 id="2021下半年（大二上学期）"><a href="#2021下半年（大二上学期）" class="headerlink" title="2021下半年（大二上学期）"></a>2021下半年（大二上学期）</h3><h4 id="2021-7-10月"><a href="#2021-7-10月" class="headerlink" title="2021.7-10月"></a>2021.7-10月</h4><p>这是我和她吵架高峰期，因为学习和班助工作，真的少了很多时间对她的陪伴，这段时间，我尽量不把自己的心情影响到身边人，不想因为周围的人被我的心情影响到，我只能努力忍着自己随时可能爆发的情绪，每天照常如故对待身边的人，先把自己感情的事情放在一边，做好自己身为班助应该做的工作。</p>
<p>可以说，我算得上是一个合格的班助吧，但算不上一个合格的男朋友，那段时间居然还有人在外面传言说我分手了，真的听到了我都笑了，对这些人挺够无语的。</p>
<p>迎新工作开始，而我也陷入了学习java和迎新的工作之中，在迎新的过程中，当时还立了好几个flag，要学好java其他相关的技术，比如：MySQL、ssm框架、spring boot、spring cloud等等。</p>
<p>当时的我真的觉得，自己会在暑假干好上面的flag，但事与愿违，自制力还是不够，仅仅只是学完了java基础部分和很浅的了解了一下java的ssm框架，终究还是败给了懒惰。</p>
<p>大二正式开学之后，因为有了新的课程学习，自然没有暑假那么多时间学习java更多的知识了，而且当上了小班助，为了防止他们军训时发生什么事故，请了很多节课假，选择陪他们一起军训，java的学习进度也就减慢了很多。</p>
<p>到了十月份，我基本放下了班助的工作，那时候，我不知道为什么，再次陷入了学习的迷茫之中，那段时间，我感觉我学了java，但是毫无用处，对java的框架学习也比较反感，那时候我还想着要不要转iOS开发呢？</p>
<p>带着这个疑惑，突然想起了那个学长，便去咨询了他，我在这种迷茫的时候，到底应该怎么办，我该怎么做？后来在和他的聊天过程中发现，不是我对java彻底失去兴趣，也不是我不适合学习java，只是暂时的失去了对它的兴趣，这算是一种叫做“递减效应”的心理效应吧。他当时推荐我去学学前端，写写网页后面再去转向后端，用前端来做一个跳板，像后端再去慢慢转换。</p>
<p>在他的建议下，我很快入手了前端，毕竟web前端的核心js的学习，其实跟java十分相似，自然上手就很快。</p>
<h4 id="2021-11"><a href="#2021-11" class="headerlink" title="2021.11"></a>2021.11</h4><p>这一个月怎么说呢，有快乐也有伤心吧，快乐就是我得到了学长的认可，有不开心的事情，也可以跟学长分享，并且他能在闲暇的时候帮我解决，伤心的是我失去了很多，少了很多时间给她，少了和兄弟们当初的快乐。陪她的时间越来越少，我们之间的争吵也越来越多，可是我当初也是想着做这个项目，能够好好带着她一起去她想去的城市，也算是为未来打拼奋斗，虽然以后我可能不是一个Winner，但我不想做一个未来的Loser。</p>
<h5 id="2021-11-24-9-34"><a href="#2021-11-24-9-34" class="headerlink" title="2021.11.24 9:34"></a>2021.11.24 9:34</h5><p>那个学长给我发了一条微信，询问我是否愿意来一起和他一起做项目，我当时收到这条消息，真的乐开了花，多的不说，机会是自己把握的，当机立断就答应了，毕竟我觉得，不管最终结果如何，我相信我一定能学到很多东西，学到在学校学不到的东西，慢慢摆脱在大学的迷茫和无知。</p>
<h4 id="2021-12"><a href="#2021-12" class="headerlink" title="2021.12"></a>2021.12</h4><p>我在学长的学习路线下，慢慢学会了怎样使用Git、HEXO、Node.js、前端等等开发技术，在慢慢学习了计网、计组等基础知识。</p>
<p>我还记得，我当时为了学习，经常熬夜到晚上一两点，前面的好几篇blog，也是在那段时间写出来的。有兴趣的可以去看看“<a href="https://pengzihao166.work/2021/11/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">小八学习git从0到基本运用</a>”，“<a href="https://pengzihao166.work/2021/11/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Git%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">自学如何使用Git+Hexo搭建个人博客</a>”。</p>
<p>真的很喜欢一句话，<strong>“没有人会因为你熬到两三点就心疼你，也没有人会在乎你在熬什么，你只需要知道你自己在奋斗”</strong>。</p>
<p>这个月我也便在学习新知识和期末备考中度过了，过得算不上很“大学生”。而我的一年差不多也就这么过去了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说了这么多，有了很多的失去，也有很多的收获，多的不说，送给大家一句话，<strong>看好当下，跳向未来吧</strong>。做好自己2022立下的flag，加油加油，冲冲冲，也希望我身边的人能够快快乐乐，成为自己想成为的人！！！</p>
<p>你好，这里是小八，一个专门分享学习经验和经历的菜鸟。</p>
]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>2107的小崽子们</title>
    <url>/2021/12/01/2107%E7%9A%84%E5%B0%8F%E5%B4%BD%E5%AD%90%E4%BB%AC/</url>
    <content><![CDATA[<h3 id="Hello，大家好啊，我是小八"><a href="#Hello，大家好啊，我是小八" class="headerlink" title="Hello，大家好啊，我是小八"></a>Hello，大家好啊，我是小八</h3><span id="more"></span>
<p>&ensp;&ensp;最近在学计组，实在不想学了，今天咱不谈学习，本学期临近期末，就来写一篇博客来回忆一下本学期的时光，来缓解一下心情吧。</p>
<p>&ensp;&ensp;咳咳咳，那就从大一下的暑假开始说起吧，没错，就在上学期，我很荣幸的被选成21级新生小班助，虽然当时的我并不知道我带的是哪个班，更不知道你们一个个“小兔崽子”长啥样，更别说你们会不会到时候惹我生气，但是我当时真的还是很开心，当时当上小班助，还特意发了个朋友圈庆祝一下：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/banzhu.jpg?versionId=CAEQFxiBgICXuoTX6xciIDZkNjkyMGU5NmQ3ZDRkYWVhNjdmZjA2YTU2ZTlhNWM5" alt="banzhu"></p>
<h3 id="ensp-ensp-2021-8-09-19-31"><a href="#ensp-ensp-2021-8-09-19-31" class="headerlink" title="&ensp;&ensp;2021-8-09 19:31"></a>&ensp;&ensp;2021-8-09 19:31</h3><p>&ensp;&ensp;我收到了班助分配通知，很荣幸成为了大类2107班的小班助，和你们的大班助杨姐姐一起共事，那天晚上，我们班助也就开始进行新生迎新工作了。</p>
<h3 id="ensp-ensp-2021-8-12-21-48"><a href="#ensp-ensp-2021-8-12-21-48" class="headerlink" title="&ensp;&ensp;2021-8-12 21:48"></a>&ensp;&ensp;2021-8-12 21:48</h3><p>&ensp;&ensp;老师发给我们你们的联系方式，要求我们通过联系方式通知你们一个个进入班级通知群和聊天群，虽然我和大班助打电话的时候，还被部分家长当成过诈骗电话，但是觉得还是挺有意义的，hhhhhhhh，想起来这里就挺搞笑的，不过最后在辅导员的努力下，你们还是顺利进到了2107班这个新的大集体。</p>
<h3 id="ensp-ensp-2021-8-20-——2021-9-11"><a href="#ensp-ensp-2021-8-20-——2021-9-11" class="headerlink" title="&ensp;&ensp;2021-8-20 ——2021-9-11"></a>&ensp;&ensp;2021-8-20 ——2021-9-11</h3><p>&ensp;&ensp;身为班助的我还有大班助杨姐姐，为了你们能顺利开学，根据当时学校的疫情返校规定，每天都一日三次在通知群提醒你们进行完美校园的健康打卡，中途杨姐姐和我想让你们在QQ聊天群里活跃起来，想尽了一切办法，把隔壁班的班助都拉进来了，一直在那里水群，想着带动你们一起来说说话，讨论一下你们对大学的看法，水着水着还是那几个“老油条”在里面水群，好家伙，好像并没啥用，可能是我活跃气氛的能力不行吧，要是下次还能当你们班助，我一定会尽力去学一下怎么带动你们。</p>
<p>&ensp;&ensp;有一说一，你们在还没有进学校的时候，有很多人，加了我的好友，然后问我计算机怎么入门，当时的我，真的就在想，好家伙，一个个的都这么卷的吗，不在群里聊天，在这里问我怎么学习，当然当时能告诉你们怎么入门，我真的感到很荣幸，毕竟我自己一直也是一个菜鸟。那时候还记得我们班的有些人经常问我c语言的题目，但是当时我也在自学Java，回消息就比较慢，希望你们能体谅一下，诶嘿嘿嘿。你看看你们内卷的时候，是多么恐怖：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/suanfa.png?versionId=CAEQFxiBgID8uITX6xciIGYyMDU3MjBkY2U1OTQ5NmM5ZmM0NGY4NmJiZjE5YmI4" alt="neijuan"></p>
<p>&ensp;&ensp;不过你们真的很优秀，我当时要大一这么有觉悟，也不至于现在还这么菜了（来自小八的自嘲）。</p>
<h3 id="2021-9-11-——-2021-9-30"><a href="#2021-9-11-——-2021-9-30" class="headerlink" title="2021-9-11 —— 2021-9.30"></a>2021-9-11 —— 2021-9.30</h3><p>&ensp;&ensp;这段时间是你们最快乐的时候吧，我觉得你们挺快乐的，就前几天军训你们训练比较累，后面就感觉你们教官还是对你们太好了，这段时间，因为害怕你们军训时会晕倒，我们七八班的班助每天都是轮换制去陪着你们军训，要是有课都会请假去陪你们，看你们晒太阳，hhhhhhhhh，不过我不知道为什么，我好像没怎么晒太阳，咋也黑了好几个度，就挺离谱的，到现在我还是很黑。</p>
<p>&ensp;&ensp;有一说一哈，那一个月真的很快很快，我都感觉像在昨天一样，虽然跟你们接触的时间很短，但是，我和大班助，真的就像把你们当做自己的弟弟妹妹来对待的。</p>
<p>&ensp;&ensp;还记得，在军训期间的第一次晚自习，我们七八班的班助请你们喝奶茶，你们很多人都发了QQ空间，在中秋晚会的时候，为你们准备中秋的零食，虽然那天我不在场（我去陪谁了，你们懂的），但是我的心还是跟你们在一起的。当时，我还记得有几个“小崽子”进了方阵队，甚至有人进了国旗队，你们真的很了不起，为自己班上争了很多光，我身为班助也很开心啊。最后结束军训的那天，我们班也有了一张在军训期间的第n张大合影，（当时大班助在上课，没有及时赶到，挺遗憾的）。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/2107.jpg?versionId=CAEQFxiBgIDKvITX6xciIDEyOWRmNjg4MzBkZTQ1MTY4YzBlNjJkM2FkNzExOTVk" alt="2107"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/21071.jpg?versionId=CAEQFxiBgIDYuYTX6xciIGI4YThiMzg5NzRjOTQwMmVhMmQxMzU4ZTQxMzI2N2Rl" alt="21071"></p>
<h3 id="2021-9-30-——-现在"><a href="#2021-9-30-——-现在" class="headerlink" title="2021-9-30 —— 现在"></a>2021-9-30 —— 现在</h3><p>&ensp;&ensp;你们终于结束了军训，9-30当天，我们也相应选出了属于自己班的班委，这个时候也就意味着，班助差不多要撒手交给你们自己来管理好这个大集体了，但这并不意味着我们的缘分就此结束，我们在学校肯定也会有很多遇到的时候，说到这里，我觉得我们班的崽子真的很讲礼貌，每次看到我，都会主动跟我打招呼。</p>
<p>&ensp;&ensp;2021-10-1，迎来了你们在大学的第一个小长假，虽然因为疫情，你们哪都不能去，你们也很懂事，非特殊情况的人都乖乖留在了株洲，没有私自外出，这点真的做的很好，当时也很感谢你们和家长的支持和谅解.</p>
<p>&ensp;&ensp;在国庆之后，我们也和八班这个大集体一起进行了团建，那天因为临时有点私事，也没有及时赶到，不好意思哈。后面你们组织篮球队，很积极参加了学院新生杯的篮球赛，在三场淘汰赛中均以大比分战胜对手，进入八强，虽然最后那天在八强赛，你们下半场状态有点下滑，以一分之差输给了对手，但是你们真的已经很棒了。我想对你们说“七班一直都很牛逼！！！”</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/lanqiu.jpg?versionId=CAEQFxiBgIDPuYTX6xciIDQ2MWYxNGM1MDczYjQ2YjU5YmI5ZTk2NDlkYzJmMDZl" alt="lanqiu"></p>
<p>&ensp;&ensp;最后小助想对你们说：“大学嘛，是一个新的开始，希望你们在这已经过去的几个月，早已丢掉了初来乍到时的迷茫、焦虑、失望、堕落，而是找到了自己的生活方式和学习方式，记住，在大学，不要在任何东西面前失去自我，哪怕是别人的目光，哪怕是别人对你感情的插手，就是希望你们都能拥有自由而有趣的灵魂，很荣幸能和你们一起在2107共同战斗过，以后有啥需要帮助的，小助也随时可以给你们提供帮助，希望你们在大一的一年中能够带着稚气、迷惑和理想，完成你们曾在大学许下的梦！！！最重要的就是，千万别挂科，才能有可能选到自己想选的专业，当初这件事，我在班会上面也给你们强调过很多次，也就不多说了。加油加油！！！”</p>
<p>&ensp;&ensp; 好了，差不多回忆完了，我要去学习了，今天的分享就到此结束吧。</p>
 <p align="right">———————————你们的小班助-小八</p>]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>DataStructure-AVLTree</title>
    <url>/2023/06/24/DataStructure-AVLTree/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础复习笔记</title>
    <url>/2021/12/21/C-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C-面对对象笔记整理："><a href="#C-面对对象笔记整理：" class="headerlink" title="C++面对对象笔记整理："></a>C++面对对象笔记整理：</h1><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/C-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/C%2B%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.png?versionId=CAEQGBiBgID9.uzZ7xciIGE0NmYxMzZhNzE5MDQ3ODU5NzA2ZDE2NmNhNzUyYTdl"></p>
<h2 id="内存分区："><a href="#内存分区：" class="headerlink" title="内存分区："></a>内存分区：</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<p>​    <strong>代码区：</strong></p>
<ul>
<li><p>存放 CPU 执行的机器指令</p>
</li>
<li><p>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
</li>
<li><p>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
</li>
</ul>
<p>​    <strong>全局区：</strong></p>
<ul>
<li><p>全局变量和静态变量存放在此.</p>
</li>
<li><p>全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
</li>
<li><p>该区域的数据在程序结束后由操作系统释放</p>
</li>
</ul>
<h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部变量</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
<li>全局变量、静态变量、全局常量的地址&amp;隔得比较近</li>
</ul>
<h3 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h3><p>​    <strong>栈区：</strong></p>
<p>​        由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong>：栈区由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>​    <strong>堆区：</strong></p>
<p>​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​        在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<ul>
<li><p>堆区数据由程序员管理开辟和释放</p>
</li>
<li><p>堆区数据利用new关键字进行开辟内存</p>
</li>
</ul>
<h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><p>​    C++中利用<strong>new</strong>操作符在堆区开辟数据</p>
<p>​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 <strong>delete</strong></p>
<p>​    语法：<code> new 数据类型</code></p>
<p>​    利用new创建的数据，会返回该数据对应的类型的指针</p>
<p><strong>示例1： 基本语法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：开辟数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h3><p>**作用： **给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">	<span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">	c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递，把主函数里面的a,b的值传过来，把主函数里面的实参a,b的值赋给了形参a,b,在mySwap01函数里面的形参a,b的值发生了改变，但是主函数的里面的a,b的地址和值都没有改变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递,通过把主函数里面的a,b的地址和值传给 mySwap02的*a,*b。即a的地址原来是01，值为10，b的地址是02，值是20，在mySwap02中的通过*a和*b传过来主函数的a,b的地址和值，将a的地址和值转换成02,20,b的地址和值转换成01,10</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递，在mySwap03中&amp;a,&amp;b指向主函数的a,b对应地址。比如原先的a,b的地址分别为01,02，进行交换之后,a,b的地址没有变，但是把01,02地址的里面的值交换了，即变量a的地址为01的值变成了20,变量b的地址为02的值变成了10</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量，存放在栈区，返回之后会被自动释放</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;<span class="comment">//全局变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<span class="comment">//第一次会被编译器保存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<span class="comment">//第二次就不会保存,a的内存已经被释放</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;<span class="comment">//把1000赋值给a也就相当于赋给了a的别名ref2</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<span class="comment">//1000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>​    </p>
<h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">    <span class="comment">//因为const的存在 v=1000修改不了v</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误，10是一个常量</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，相当于int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数，即：声明和实现只能有一个默认参数</span></span><br><span class="line"><span class="comment">//3、如果我们自己传入数据，就用自己的数据，如果没有就用默认值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;<span class="comment">//声明函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="comment">//实现函数</span></span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>,<span class="number">10</span>)&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func2</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;<span class="comment">//void func(int a, int =10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h4 id="函数重载概述"><a href="#函数重载概述" class="headerlink" title="函数重载概述"></a>函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改函数返回值类型不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h4 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span><span class="comment">//int &amp;a=10,不合法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a); <span class="comment">//调用无const，a是一个变量，不是常量</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const，10是一个常量const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func2(10); //碰到默认参数产生歧义，即：void func2(int a)和void func2(int a, int b = 10)均可以被调用，出现二义性，需要避免，所以写函数重载的时候，尽量避免形参中有默认参数的出现</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p>
<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>
<p><strong>例如：</strong></p>
<p>​    人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<p>​    车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>
<p>​    具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h4><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>​    在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p><strong>示例1：</strong>设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="comment">//获取到圆的周长</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//2 * pi  * r</span></span><br><span class="line">		<span class="comment">//获取圆的周长</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过圆类，创建圆的对象c1</span></span><br><span class="line">	<span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	c<span class="number">1.</span>m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c<span class="number">1.</span><span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类,属性+行为=成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//行为</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">		m_id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//属性</span></span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Student stu;</span><br><span class="line">	stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);<span class="comment">//stu.m_name=&quot;德玛西亚&quot;</span></span><br><span class="line">	stu.<span class="built_in">setID</span>(<span class="number">250</span>);<span class="comment">//stu.id=250</span></span><br><span class="line">	stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限  </li>
<li>protected 保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问 可以通过所属类的成员函数、友元类、友元函数、派生类对象</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问 只可以被所属类的成员函数、友元函数、友元类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">		m_Password = <span class="number">123456</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//实例化对象p</span></span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">	<span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line">	p.<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	C1 c1;</span><br><span class="line">	c<span class="number">1.</span>m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c<span class="number">2.</span>m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h4 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//姓名设置可读可写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取年龄 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置年龄</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置为只写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">		m_Lover = lover;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m_Age; <span class="comment">//只读  年龄,如果需要读取，那么就写一个getAge函数</span></span><br><span class="line"></span><br><span class="line">	string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	<span class="comment">//姓名设置</span></span><br><span class="line">	p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄设置</span></span><br><span class="line">	p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置</span></span><br><span class="line">	p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h3><ul>
<li> 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li> C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​    一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><p>两种分类方式：</p>
<p>​    按参数分为： 有参构造和无参构造</p>
<p>​    按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​    括号法</p>
<p>​    显示法</p>
<p>​    隐式转换法</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();类似于void func();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); <span class="comment">//有参构造p2，即：右边的无名函数声明取名为p2</span></span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);<span class="comment">//拷贝构造p3</span></span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明，即：Person(p3)===Person p3，会默认为重定义</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person newman3;</span></span><br><span class="line">	<span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造，但要是需要创建一个类对象，必须写上默认无参构造函数</li>
</ul>
<ul>
<li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数，默认构造和有参构造均不提供，析构函数还是有</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">	Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">	Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数  </span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	<span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p<span class="number">1.</span>m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p<span class="number">1.</span>m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p<span class="number">2.</span>m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p<span class="number">2.</span>m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供深拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">////传统方式初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_PhoneName = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">	<span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">	<span class="comment">//析构顺序与构造相反</span></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li> 所有对象共享同一份数据</li>
<li> 在编译阶段分配内存</li>
<li> 类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li> 所有对象共享同一个函数</li>
<li> 静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1 ：</strong>静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量特点：</span></span><br><span class="line">	<span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">	<span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p<span class="number">1.</span>m_A = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="number">1.</span>m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p<span class="number">2.</span>m_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="number">1.</span>m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p<span class="number">2.</span>m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：</strong>静态成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数特点：</span></span><br><span class="line">	<span class="comment">//1 程序共享一个函数</span></span><br><span class="line">	<span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p<span class="number">1.f</span>unc();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h3><h4 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li> 当形参和成员变量同名时，可用this指针来区分</li>
<li> 在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">        <span class="comment">//this指针指向被调用的成员函数所属的对象</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//this指向p2的指针，而*this指向的就是p2对象的本体</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p<span class="number">1.</span>age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//链式变成思想</span></span><br><span class="line">	p<span class="number">2.</span><span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//mAge相当于this-&gt;mAge，但是当p-&gt;ShowPerson()调用这个函数的时候，因为此时*p指向一个空的值，并不是一个确定的对象，无法访问Person属性的成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">	p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h4><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">    <span class="comment">//在成员函数的后面加const，修饰的是this指向，让this指向的 值 也不可以进行修改</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//加mutable之后，此属性可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象只能调用常函数，常对象不能调用普通的成员函数，因为普通成员函数能修改</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为  ==friend==</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<p>下面我就拿两个例子简单示例一下，当然还有**++运算符**等重载，有兴趣的小伙伴可以去自己上网或者查询书籍深入了解一下</p>
<h4 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p<span class="number">2.</span>m_A + val;</span><br><span class="line">	temp.m_B = p<span class="number">2.</span>m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//对类对象p1，p2的m_A,m_B属性分别进行初始化</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数Person operator+(const Person&amp; p)的调用</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p<span class="number">3.</span>m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p<span class="number">3.</span>m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局函数operator+的调用</span></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p<span class="number">4.</span>m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p<span class="number">4.</span>m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h4><p>作用：可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承是面向对象三大特性之一</strong></p>
<p>我们发现，定义很多类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h4 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>继承的好处：==可以减少重复的代码==</p>
<p>class A : public B; </p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s<span class="number">1.</span>m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//父类中的非静态成员属性都会被子类继承，只不过父类的private 被隐藏了</span></span><br><span class="line">    <span class="comment">//子类可以继承父类的静态属性</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>利用工具查看：</p>
<p>1、找到visual studio下面的vs2017的开发人员命令指示符</p>
<p>2、打开工具窗口后，定位到当前CPP文件的盘符，假如你的cpp文件在F盘那就先输入F:</p>
<p>3、然后输入cd 你的以.cpp为后缀代码文件的文件夹</p>
<p>4、然后输入dir,查看此文件夹中的文件目录 </p>
<p>5、输入cl  /d1  reportSingleClassLayout查看的类名  “所属文件名”  （cl是字母cl，/d后面的是数字1，而且cl 和/d1之间有空格）</p>
<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<p>​            就是类似于先有爸爸，才生的出来儿子一样的</p>
</blockquote>
<h4 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域，格式即：类对象.父类类名 :: 父类中同名的函数( );</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">	<span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一个：：代表通过类名的方式访问  第二个::代表访问父类作用域下</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//子类类名::父类类名::父类静态成员函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
<p>​           切记在类外访问类内非静态成员函数的时候，不能通过<strong>类名::函数名</strong>的方式直接访问，并且静态成员函数只能访问静态成员变量</p>
</blockquote>
<h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_C = <span class="number">300</span>;</span><br><span class="line">		m_D = <span class="number">400</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当父类中出现同名的成员，需要加作用域进行区分</span></span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p><strong>菱形继承概念：</strong></p>
<p>​    两个派生类继承同一个基类</p>
<p>​    又有某个类同时继承者两个派生类</p>
<p>​    这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>菱形继承问题：</strong></p>
<ol>
<li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
</code></pre>
</li>
<li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。
</code></pre>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">	st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h4 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Speak函数就是虚函数，此时的animal类的Speak也就是动态化的一个函数</span></span><br><span class="line">	<span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了，就会根据运行阶段进行函数的地址，实现晚绑定</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(cat);<span class="comment">//Animal &amp;animal = cat</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数，但是不要加virtual</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类的 指针 或 引用 指向子类对象</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
<h4 id="多态案例一-计算器类"><a href="#多态案例一-计算器类" class="headerlink" title="多态案例一-计算器类"></a>多态案例一-计算器类</h4><p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//普通实现测试</span></span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">	c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//创建加法计算器</span></span><br><span class="line">	AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁，只是把堆区的abc的值删除了，但是abc的指针并没有删除，故后面直接用abc指向新的对象即可。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建减法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建乘法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>C++多态组织结构清晰，可读性强，便于前后期的扩展以及维护</li>
<li>使用条件：父类的 “指针” 或者 “子类” 指向子类对象</li>
</ul>
<h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，如果父类中的虚函数对项目的开发毫无用处，那就可以定义成一个<strong>纯虚函数</strong>进行开发</p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象，只能通过指针</li>
<li>子类必须重写抽象（父）类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">//1、抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//2、子类必须重写父类中的纯虚函数，否则也属于抽象类，无法实例化对象</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base * base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;<span class="comment">//或者Base * base = NULL;base = new Son;写成一句话 Base * base = new Son;</span></span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;<span class="comment">//记得销毁.释放base指针的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="多态案例二-制作饮品"><a href="#多态案例二-制作饮品" class="headerlink" title="多态案例二-制作饮品"></a>多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶，实现烧、冲、倒、加等功能</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);<span class="comment">//即让void DoWork(AbstractDrinking* drink)中的* drink指针指向Coffee并调用DoWork函数，此时Coffee便会调用继承下来的void MakeDrink()和已经重写好的void MakeDrink()函数中的烧、冲、倒、加等功能</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);<span class="comment">//同理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code> virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数加上virtual关键字，变成虚析构函数，来解决父类指针释放子类对象不干净的问题</span></span><br><span class="line">	<span class="comment">//virtual ~Animal()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//纯虚析构函数，但是需要对此纯虚构函数进行 声明和实现</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Name;</span><br><span class="line">			m_Name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过父类指针去释放，不会调用子类中的析构函数，子类如果有堆区属性，会造成内存泄漏</span></span><br><span class="line">	<span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">	<span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象的问题，并且纯虚析构和虚析构都需要进行声明和实现，来防止父类开辟堆区对象时的问题</p>
<p>​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<pre><code> 3. 拥有纯虚析构函数的类也属于抽象类
</code></pre>
<h4 id="多态案例三-电脑组装"><a href="#多态案例三-电脑组装" class="headerlink" title="多态案例三-电脑组装"></a>多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的计算函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的显示函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的存储函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供工作的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">		m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放CPU零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_cpu;</span><br><span class="line">			m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放显卡零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_vc;</span><br><span class="line">			m_vc = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放内存条零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_mem;</span><br><span class="line">			m_mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">	VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">	Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一台电脑零件</span></span><br><span class="line">	CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建第一台电脑</span></span><br><span class="line">	Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>C++笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DataStructure-Tree</title>
    <url>/2023/06/22/DataStructure-Tree/</url>
    <content><![CDATA[<h2 id="常见二叉树类型"><a href="#常见二叉树类型" class="headerlink" title="常见二叉树类型"></a>常见二叉树类型</h2><h3 id="完美二叉树（满二叉树）"><a href="#完美二叉树（满二叉树）" class="headerlink" title="完美二叉树（满二叉树）"></a>完美二叉树（满二叉树）</h3><p>除了最底层外，其余所有层的节点都被完全填满。在 完美二叉树中，叶节点的度都为0，其余所有节点的度都为2，如果树的高度为h，那么节点总数是2^h+1^ - 1。</p>
<p>如图</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230822094928786.png" alt="完美二叉树"></p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>只有底层没有被填满，且最底层节点尽量靠左填充。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230822094506044.png" alt="完全二叉树"></p>
<h3 id="完满二叉树"><a href="#完满二叉树" class="headerlink" title="完满二叉树"></a>完满二叉树</h3><p>除了叶子节点之外，其余所有节点都有两个子节点。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230822094559922.png" alt="完美二叉树"></p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>任意节点的左子树和右子树的高度之差绝对值不超过1</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230822094659513.png" alt="平衡二叉树"></p>
<blockquote>
<p>二叉树如果没有特殊限制（例如平衡二叉树）的话，可能会成为线性结构。即子节点要么全部在左子树，要么全部在右子树。</p>
</blockquote>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><h3 id="层序遍历（广度优先遍历）"><a href="#层序遍历（广度优先遍历）" class="headerlink" title="层序遍历（广度优先遍历）"></a>层序遍历（广度优先遍历）</h3><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230822095757441.png" alt="广度优先遍历"></p>
<blockquote>
<p> 一般通过队列实现，队列遵循“先进先出”的规则，广度优先是“逐层推进”十分相似。</p>
</blockquote>
<p>代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化队列，加入根节点</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 队列出队</span></span><br><span class="line">        list.add(node.val);           <span class="comment">// 保存节点值</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">            queue.offer(node.left);   <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">            queue.offer(node.right);  <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程如下：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230822101651356.png" alt="image-20230822101651356"></p>
<p><strong>时间复杂度</strong>：所有节点被访问一次，使用 O(n) 时间，其中n为节点数量。</p>
<p><strong>空间复杂度</strong>：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 (n + 1) / 2个节点，占用  O(n)  空间。</p>
<h3 id="前序、中序、后序遍历（深度优先遍历）"><a href="#前序、中序、后序遍历（深度优先遍历）" class="headerlink" title="前序、中序、后序遍历（深度优先遍历）"></a>前序、中序、后序遍历（深度优先遍历）</h3><p>主要的思想就是“先走到尽头，再回溯继续”的遍历方式。</p>
<blockquote>
<p>前序遍历：遵循根-&gt;左-&gt;右</p>
<p>中序遍历：遵循左-&gt;根-&gt;右</p>
<p>后序遍历可以看成高仿版的倒过来的层次遍历，只不过是对于左子树或者右子树来说，从叶子结点向上依次遍历遵循左-&gt;右-&gt;根。</p>
</blockquote>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230822103648425.png" alt="image-20230822103648425"></p>
<p>代码样例如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：所有节点被访问一次，使用O(n)时间，其中n为节点数量。</p>
<p><strong>空间复杂度</strong>：在最差情况下，即树退化为链表时，递归深度达到n，系统占用 O(n)栈帧空间。</p>
<blockquote>
<p>上述代码实际上使用的就是递归的思想：</p>
<p>递：表示开启新方法，程序在此过程中访问下一个节点</p>
<p>归：表示函数返回，代表当前节点已经访问完毕</p>
</blockquote>
<h2 id="二叉树数组表示"><a href="#二叉树数组表示" class="headerlink" title="二叉树数组表示"></a>二叉树数组表示</h2><h3 id="表示完美二叉树"><a href="#表示完美二叉树" class="headerlink" title="表示完美二叉树"></a>表示完美二叉树</h3><p>根据层序遍历的特性<strong>若节点的索引为i，则该节点的左子节点索引为2i + 1 ，右子节点索引为2i + 2</strong> </p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230822152757206.png" alt="image-20230822152757206"></p>
<h3 id="表示任意二叉树"><a href="#表示任意二叉树" class="headerlink" title="表示任意二叉树"></a>表示任意二叉树</h3><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230822153450501.png" alt="image-20230822153450501"></p>
<p>这个时候就不能通过公式的方式获取到对应的索引下标了，那么我们就可以<strong>通过层序遍历显式的写出所有NULL，</strong>对于上图代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的数组表示 */</span></span><br><span class="line"><span class="comment">// 使用 int 的包装类 Integer ，就可以使用 null 来标记空位</span></span><br><span class="line">Integer[] tree = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="literal">null</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">12</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">15</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>对于完全二叉树，由于它是只有最底层且靠右的位置才会出现无子节点的情况，所以所有的null都只会出现在数组的末尾，可以通过数组的方式来按顺序存储。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230822153845470.png" alt="image-20230822153845470"></p>
<h3 id="优势和弊端"><a href="#优势和弊端" class="headerlink" title="优势和弊端"></a>优势和弊端</h3><p>优势：</p>
<ul>
<li>数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。</li>
<li>不需要存储指针，比较节省空间。</li>
<li>允许随机访问节点。</li>
</ul>
<p>弊端：</p>
<ul>
<li>数组存储需要连续内存空间，因此不适合存储数据量过大的树。</li>
<li>增删节点需要通过数组插入与删除操作实现，效率较低。</li>
<li>当二叉树中存在大量 NULL 时，数组中包含的节点数据比重较低，空间利用率较低。</li>
</ul>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="满足条件（性质）："><a href="#满足条件（性质）：" class="headerlink" title="满足条件（性质）："></a>满足条件（性质）：</h3><p><strong>左右子树所有节点值 &lt; 根节点值 &lt; 右子树所有节点的值</strong></p>
<h3 id="查找节点："><a href="#查找节点：" class="headerlink" title="查找节点："></a>查找节点：</h3><p>给出目标值num，需要在树中找到和num相等的节点。可以声明一个cur节点表示目前所指向的节点的位置。</p>
<ul>
<li>如果cur.val &lt; num，说明目标节点在cur的右子树中，执行cur = cur.right;</li>
<li>如果cur.val &gt; num，说明目标节点在cur的左子树中，执行cur = cur.left;</li>
<li>如果cur.val = num，说明找到了目标节点，直接返回cur即可。</li>
</ul>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查找节点 */</span></span><br><span class="line">TreeNode <span class="title function_">search</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur.val &gt; num)</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        <span class="comment">// 找到目标节点，跳出循环</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回目标节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>给定一个待插入元素 <code>num</code>，根据二叉搜索树性质，思路如下：</p>
<p>1、查找出插入的位置，通过搜索的方式，从根节点出发，比较当前节点和num的大小，循环向下搜索直到越过叶子结点（遍历 至null）时跳出循环。</p>
<p>2、初始化节点num，并将此节点置于null的位置。</p>
<blockquote>
<p>注意：</p>
<ul>
<li>二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回。</li>
<li>为了实现插入节点，我们需要借助节点 <code>pre</code> 保存上一轮循环的节点。这样在遍历至 NULL时，我们可以获取到其父节点，从而完成节点插入操作。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 若树为空，直接提前返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root, pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到重复节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val == num)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(num);</span><br><span class="line">    <span class="keyword">if</span> (pre.val &lt; num)</span><br><span class="line">        pre.right = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre.left = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与查找节点相同，插入节点使用 O(log n)时间。</p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>大概思路就是先查找到要删除的节点，然后进行删除，具体思路如下：</p>
<p>1、如果要删除的节点的度（子节点个数）为0的话，表示待删除的节点是叶子结点，可以直接删除</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230823154749524.png" alt="image-20230823154749524"></p>
<p>2、如果要删除的节点的度是1的话，就将待删除节点替换成其子节点即可。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230823154736089.png" alt="image-20230823154736089"></p>
<p>3、如果要删除的节点的度是2的话，所以可以用这个要删除的节点的右子树的最小节点或者左子树的最大节点进行替换。（保持二叉搜索树“左 &lt; 右 &lt; 根”的性质）</p>
<p>拿右子树的最大节点举例（即要删除的节点的中序遍历的下一个节点）：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230823160312476.png" alt="image-20230823160312476"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230823160319223.png" alt="image-20230823160319223"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230823160253181.png" alt="image-20230823160253181"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230823160259329.png" alt="image-20230823160259329"></p>
<p>删除节点操作同样使用O(log n)时间，其中查找待删除节点需要 O(log n)时间，获取中序遍历后继节点需要 O(log n) 时间。</p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 若树为空，直接提前返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root, pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到待删除节点，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val == num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若无待删除节点，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 子节点数量 = 0 or 1</span></span><br><span class="line">    <span class="keyword">if</span> (cur.left == <span class="literal">null</span> || cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当子节点数量 = 0 / 1 时， child = null / 该子节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">child</span> <span class="operator">=</span> cur.left != <span class="literal">null</span> ? cur.left : cur.right;</span><br><span class="line">        <span class="comment">// 删除节点 cur</span></span><br><span class="line">        <span class="keyword">if</span> (cur != root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.left == cur)</span><br><span class="line">                pre.left = child;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre.right = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若删除节点为根节点，则重新指定根节点</span></span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点数量 = 2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取中序遍历中 cur 的下一个节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.right;</span><br><span class="line">        <span class="keyword">while</span> (tmp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归删除节点 tmp</span></span><br><span class="line">        remove(tmp.val);</span><br><span class="line">        <span class="comment">// 用 tmp 覆盖 cur</span></span><br><span class="line">        cur.val = tmp.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="平衡二叉搜索树的效率"><a href="#平衡二叉搜索树的效率" class="headerlink" title="平衡二叉搜索树的效率"></a>平衡二叉搜索树的效率</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">无序数组</th>
<th align="left">二叉搜索树</th>
</tr>
</thead>
<tbody><tr>
<td align="left">查找元素</td>
<td align="left">O(n)</td>
<td align="left">O(\log n)</td>
</tr>
<tr>
<td align="left">插入元素</td>
<td align="left">O(1)</td>
<td align="left">O(\log n)</td>
</tr>
<tr>
<td align="left">删除元素</td>
<td align="left">O(n)</td>
<td align="left">O(\log n)</td>
</tr>
</tbody></table>
<p>然而，如果我们在二叉搜索树中不断地插入和删除节点，可能导致二叉树退化为图 7-23 所示的链表，这时各种操作的时间复杂度也会退化为 O(n)。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230823164351313.png" alt="image-20230823164351313"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用</title>
    <url>/2023/05/29/Docker%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h2><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230529235020493.png" alt="image-20230529235020493"></p>
<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul>
<li>docker images</li>
</ul>
<blockquote>
<p>罗列出docker的所有的镜像相关信息</p>
</blockquote>
<ul>
<li>docker search 某个xxx镜像的名字</li>
</ul>
<blockquote>
<p>在hub仓库查询是否有相关的镜像 –limit 默认罗列前25个</p>
</blockquote>
<ul>
<li>docker pull 某个xxx镜像名[:tag]</li>
</ul>
<blockquote>
<p>tag:表示版本号    </p>
</blockquote>
<ul>
<li><p>docker system df 查看镜像/容器/数据卷所占空间</p>
</li>
<li><p>docker rmi 某个xxx镜像的id或者名字  -f强制删除</p>
<blockquote>
<p>docker rmi hello-world 或 docker rmi 9c7a54a9a43c<br>删除多个:</p>
<pre><code>docker rmi -f 镜像名1:tag 镜像名2:tag....
docker rmi -f $(docker images -qa)
</code></pre>
</blockquote>
<p>什么叫虚悬镜像？</p>
<p>仓库名、标签都是<none>的，俗称虚悬镜像，通常会把他删掉</none></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Basics</title>
    <url>/2023/12/01/Java-Basics/</url>
    <content><![CDATA[<h3 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a><strong>基本类型和包装类型的区别</strong></h3><ul>
<li>存放方式：基本数据类型的<strong>局部变量</strong>存放在Java虚拟机栈中的局部变量表中，基本数据类型的<strong>成员变量（未被static修饰）</strong>存放在Java虚拟机中的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li>
<li>占用空间：基本数据类型占用空间往往小于对应类型的包装类型</li>
<li>默认值：成员变量中包装类型不赋值就是<code>null</code>，而基本类型有默认值而不是<code>null</code>。</li>
<li>比较方式：对于基本数据类型用<code>==</code>，包装类型用<code>equals</code>方法</li>
</ul>
<h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a><strong>包装类型的缓存机制</strong></h3><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer缓存源码</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// high value may be configured by property</span></span><br><span class="line"></span><br><span class="line">         <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><code>Boolean</code> <strong>缓存源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p>
<blockquote>
<p><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
</blockquote>
<h3 id="浮点数运算精度丢失"><a href="#浮点数运算精度丢失" class="headerlink" title="浮点数运算精度丢失"></a><strong>浮点数运算精度丢失</strong></h3><p>通过<code>BigDecimal</code>可以实现对浮点数的运算以及精度的解决，一般用于金钱交易计算的场景才会用到</p>
<h3 id="超过long整型数据如何表示"><a href="#超过long整型数据如何表示" class="headerlink" title="超过long整型数据如何表示"></a><strong>超过long整型数据如何表示</strong></h3><p>使用<code>BigInteger</code>内部使用<code>int[]</code>数组来存储任意大小的整形数据，但是相较于基本数据类型的计算效率会较低</p>
<h3 id="成员变量与局部变量区别"><a href="#成员变量与局部变量区别" class="headerlink" title="成员变量与局部变量区别"></a><strong>成员变量与局部变量区别</strong></h3><ul>
<li>语法：成员变量可以被private、public、static等修饰，局部变量不能被访问修饰符、static修饰，但是成员变量和局部变量都能被<code>final</code>修饰</li>
<li>存储方式：<ul>
<li>成员变量如果被static修饰，那么这个成员变量属于类，如果没有static修饰这个成员变量就是属于实例，存储在堆内存中</li>
<li>局部变量存储在栈内存中</li>
</ul>
</li>
<li>生存时间：<ul>
<li>成员变量没有被static修饰的情况下，随着对象的创建而存在；被static修饰的情况下，类被卸载时，静态变量被销毁，并释放内存空间。static变量的生命周期取决于类的生命周期。</li>
<li>局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡</li>
</ul>
</li>
<li>默认值：成员变量一般自动以类型的默认值而赋值（final修饰的话必须被显式的赋值），局部变量不会自动赋值</li>
</ul>
<h3 id="静态变量的作用"><a href="#静态变量的作用" class="headerlink" title="静态变量的作用"></a><strong>静态变量的作用</strong></h3><p>一般经常使用的常量就会放在一个专用的<code>constant</code>类中，通过static类进行修饰，可以被类的所有实例共享，由于static修饰的变量只会被分配一次内存，即使创建多个对象也只会分配一次，可以很大程度上的节约内存空间。</p>
<p>通常情况下<code>static</code>会和<code>final</code>连用</p>
<h3 id="静态方法能否调用非静态成员？"><a href="#静态方法能否调用非静态成员？" class="headerlink" title="静态方法能否调用非静态成员？"></a><strong>静态方法能否调用非静态成员？</strong></h3><p>不能，因为静态成员在类加载的时候就已经分配好了内存，也就是说静态成员属于类，而非静态成员只有在创建实例对象的时候才会生成，所以在静态方法中调用还没有生成的非静态成员属于非法操作</p>
<h3 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a><strong>重写和重载的区别</strong></h3><p>重写发生在子类对父类的某一行为进行重新编写</p>
<p>重载发生在同一类中，方法名相同，参数不同、返回类型不同</p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>void或基本数据类型不可修改，引用类型可修改成该引用类型的子类</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>子类抛出比父类声明异常类更小或相等</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可以修改</td>
<td>子类可访问修饰符权限比父类松（比如父类是public、子类只能是public、而不能是protected、private、default这些）</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改（参数属性，顺序）</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<p>注意：重写时，如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<h3 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a><strong>面向过程和面向对象</strong></h3><p>面向对象：将对象抽象出来、然后调用对象的内部方法解决问题</p>
<p>面向过程：把解决问题的过程拆分成一个个方法，然后通过一个个方法的执行解决问题</p>
<h3 id="对象实体和对象引用关系"><a href="#对象实体和对象引用关系" class="headerlink" title="对象实体和对象引用关系"></a><strong>对象实体和对象引用关系</strong></h3><ul>
<li>一个对象引用可以指向0或1个对象</li>
<li>一个对象可以有n个引用指向它</li>
</ul>
<p>对象实体存在内存之中，对象引用存在栈内存中</p>
<h3 id="接口和抽象类的异同点"><a href="#接口和抽象类的异同点" class="headerlink" title="接口和抽象类的异同点"></a><strong>接口和抽象类的异同点</strong></h3><p>共同点：</p>
<ul>
<li>都不可以被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认实现方法</li>
</ul>
<p>不同点：</p>
<ul>
<li>接口是对行为的约束，实现了某一个接口就代表拥有了这个行为；抽象类是代码复用、强调的是从属关系。</li>
<li>接口的成员变量必须被public static final修饰，抽象类变量默认default且可在子类被重新定义和赋值</li>
<li>一个类只能继承一个类、但是一个类可以实现多个接口</li>
</ul>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a><strong>深拷贝和浅拷贝</strong></h3><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/d4cf78ef9da72e3efcd689ad4b4fa92.png" alt="d4cf78ef9da72e3efcd689ad4b4fa92"></p>
<p>浅拷贝：会再堆上创建一个新的对象，不过原对象内部的属性有引用类型的话，浅拷贝会直接内部对象的引用地址，即：拷贝对象和原始对象的内部对象共用一个内部对象。</p>
<p>深拷贝：会完全复制整个对象，包括这个对象所含的内部对象，也会对这个内部对象重新复制并分配一个新的内存空间，此时拷贝对象的内部对象指向新的被拷贝的引用地址。即拷贝对象和原始对象的内部对象的地址不是同一个了、也就不共用了。</p>
<h3 id="和equals-方法区别"><a href="#和equals-方法区别" class="headerlink" title="==和equals()方法区别"></a><strong>==和equals()方法区别</strong></h3><p><code>==</code> 对于基本数据类型和引用类型效果不同:</p>
<ul>
<li>对于基本数据类型，比较的是值的大小</li>
<li>对于引用数据类型，比较的是对象的内存地址是否相等</li>
</ul>
<p><code>equals()</code>主要是重写和未重写的两种情况</p>
<ul>
<li>对于重写了的对象，比较的是对象的值/属性是否相等。(String包装类就是被重写了，比较的时候就会比较String的值是否相等)</li>
<li>没有重写的，比较的是对象的内存地址是否相等，即跟<code>==</code>意义相等</li>
</ul>
<h3 id="hashcode-的作用"><a href="#hashcode-的作用" class="headerlink" title="hashcode()的作用"></a><strong>hashcode()的作用</strong></h3><p>确定对象在哈希表中的索引位置，确定两个对象是否相等的前提就是先判断两个对象的哈希码是否相等，如果不相等就会默认这两个对象是两个不同的对象，如果哈希码相等就会再通过equals()方法进行进一步的判断。</p>
<p>总结如下：</p>
<ul>
<li>如果两个对象的哈希值相等，那么这两个对象不一定相等。</li>
<li>如果两个对象的哈希值相等且equals()方法返回也是true，那么这两个对象相等</li>
<li>如果亮哥对象的哈希值不相等，那么这两个对象不相等。</li>
</ul>
<h3 id="String、StringBuilder、StringBuffer区别"><a href="#String、StringBuilder、StringBuffer区别" class="headerlink" title="String、StringBuilder、StringBuffer区别"></a><strong>String、StringBuilder、StringBuffer区别</strong></h3><ul>
<li>可变性：String不可变，由于<code>final</code>和<code>private</code>修饰，且String类没有暴露的可以修改方法，其他两个都继承自一个类，他们都有<code>append()</code>方法可以对字符串进行修改</li>
<li>安全性：<ul>
<li><code>String</code>不可变，线程安全</li>
<li><code>StringBuilder</code> 没有同步锁或者对方法加同步锁，可能会出现线程安全问题</li>
<li><code>StringBuffer</code>通过对方法加了同步锁或者调用的方法加了同步锁，线程安全</li>
</ul>
</li>
<li>性能：<ul>
<li><code>String</code> 每次改变都会创建一个新的String对象，然后指针指向新的对象</li>
<li><code>StringBuilder</code>和<code>StringBuffer</code>都是对本身进行操作，而不是创建新的对象并改变对象的引用，但是<code>StringBuilder</code>相较于<code>StringBuffer</code> 只会提升10~15%的性能提升，但是会承担一定的多线程不安全的风险。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>单线程用StringBuilder</li>
<li>多线程用StringBuffer</li>
<li>只进行一次创建操作使用String</li>
</ul>
</blockquote>
<h3 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a><strong>String为什么不可变</strong></h3><ul>
<li><code>final</code>和<code>private</code>修饰的数组，String类没有可以提供/暴露修改这个字符串的方法</li>
<li>String类被<code>final</code>修饰导致其不能被继承，进而避免了子类破坏<code>String</code>的不可变</li>
</ul>
<blockquote>
<p>1、final修饰的如果是基本数据类型的话，则值不可变。如果修饰的是引用类型则此引用不能指向新的引用（新的对象）</p>
<p>2、final修饰的数组Array只能表示此时这个引用类型的地址不可变，而不是说存在这个数组里面的值不可变，示例如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] value = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="type">int</span> []another = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">value = another;<span class="comment">//此时意味着要value数组的地址指向another数组的地址，编译器会报错，但是如果是直接修改value数组里面的值，是完全可以的</span></span><br></pre></td></tr></table></figure>

<p>修改被<code>final</code>修饰的value数组里面的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] value = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">value[<span class="number">2</span>] = <span class="number">100</span>;<span class="comment">//此时数组value变成了&#123;1,2,100&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="使用-号连接字符串还是StringBuilder"><a href="#使用-号连接字符串还是StringBuilder" class="headerlink" title="使用+号连接字符串还是StringBuilder"></a>使用+号连接字符串还是StringBuilder</h3><p>使用+号实际上就是通过<code>StringBuilder</code> 的<code>append()方法</code>实现的，拼接完成之后调用<code>toString()</code>方法得到一个<code>String</code>对象。</p>
<p>如果是多次进行+号拼接的话，实际上就是通过for循环，创建多个<code>StringBuilder</code> 循环添加，而不是对同一个<code>StringBuilder</code>进行复用。</p>
<h3 id="对字符串常量池的理解"><a href="#对字符串常量池的理解" class="headerlink" title="对字符串常量池的理解"></a>对字符串常量池的理解</h3><p>字符串常量池是JVM为了提升性能减少内存消耗针对<code>String</code>类开辟的一片区域，主要是为了防止字符串的重复创建导致的内存不必要的消耗问题。</p>
<h3 id="String-str-new-String-“abc“-会创建几个字符串对象？"><a href="#String-str-new-String-“abc“-会创建几个字符串对象？" class="headerlink" title="String str = new String(“abc“);会创建几个字符串对象？"></a>String str = new String(“abc“);会创建几个字符串对象？</h3><p>1或2个字符串对象</p>
<p>1、如果”abc”不在字符串常量池中，就在堆内存中创建两个字符串对象，其中一个会将其引用保存在字符串常量池中并返回</p>
<p>2、如果“abc”在字符串常量池中，就会直接返回引用，并在堆中创建一个字符串对象。</p>
<h3 id="String-intern-方法的作用"><a href="#String-intern-方法的作用" class="headerlink" title="String.intern()方法的作用"></a>String.intern()方法的作用</h3><p>1、如果字符串常量池中有这个字符串对象的引用，就会直接返回此引用</p>
<p>2、如果字符串中没有保存这个字符串对象的引用，就会在字符串常量池中创建一个指向该字符串对象的引用并返回</p>
<blockquote>
<p>注意：new一个对象的时候，和String.intern()对象如果字符串常量池中没有对应的字符串对象引用的时候，此时两种情况下创建的字符串引用的位置不一样，</p>
<p>1、new的时候是在堆中创建一个字符串对象，然后将这个对象的引用保存在字符串常量池中</p>
<p>2、intern()方法是直接在字符串常量池中创建字符串对象的引用并返回</p>
</blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>作用：使用泛型参数可以增强代码的可读性和稳定性。白话来说，就是编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型，比如<code>ArrayList&lt;Person&gt; arr = new ArrayList&lt;&gt;();</code> 以前没有泛型的List返回类型是Object，需要手动转换类型，使用泛型之后编译器自动转换。</p>
<p>使用方式：</p>
<ul>
<li>泛型类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(T key)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化泛型类实例</span></span><br><span class="line">Result&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;<span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口但是不指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口指定类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">   &#123;</span><br><span class="line">         <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//不同类型的包装类型调用泛型方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建不同类型数组：Integer和 String</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure>

<p>项目实践：</p>
<p>自定义后端返回结果的时候<code>Result&lt;T&gt;</code> </p>
<h3 id="序列化、反序列化"><a href="#序列化、反序列化" class="headerlink" title="序列化、反序列化"></a>序列化、反序列化</h3><ul>
<li>序列化：将数据结构或对象转换成二进制字节流的过程</li>
<li>反序列化：将序列化生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>应用场景：</p>
<ul>
<li>将对象存储到redis之类的数据库的时候需要将数据进行序列化、将对象读取出来的时候需要进行反序列化</li>
<li>将对象写入内存的时候需要将数据进行序列化、将数据读取出来的时候需要进行反序列化。</li>
</ul>
<blockquote>
<p>序列化的主要目的就是通过网络传输数据或者将数据存储到文件系统，数据库，内存等中，将数据转换成二进制字节流或其他可取用的数据格式。</p>
</blockquote>
<p>有些字段不想被序列化的时候怎么解决？</p>
<p>可以用<code>transient</code>关键字修饰，阻止被transient序列化的实例对象被序列化，如果某个对象先前已经被序列化，然后被transient修饰，再反序列化之后此变量值不会被持久化和恢复，而是被置成类型的默认值，如果是int那么反序列化之后就是0。</p>
<blockquote>
<ul>
<li>被<code>transient</code>修饰的变量，被反序列化的情况下不会被持久化和恢复，而是被默认置成此类型的默认值</li>
<li><code>transient</code>只能修饰变量，而不能修饰类或方法</li>
<li><code>transient</code>对于static修饰的变量无用，因为<code>transient</code>修饰的变量是对象，但是<code>static</code>修饰的变量不属于任何变量，所以没用</li>
</ul>
</blockquote>
<p>为什么不使用jdk自带的序列化工具？</p>
<ul>
<li>不支持跨语言的调用</li>
<li>性能差</li>
<li>存在安全问题，输入的反序列化数据可被用户控制，攻击者可以通过构造恶意输入。</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Deque</title>
    <url>/2024/03/10/Java-Deque/</url>
    <content><![CDATA[<p>&emsp;Java Deque是一种结合了普通Queue和Stack的数据结构，实际上就是一个接口，linkedlist和arraydeque都有对这个接口的实现。您可以在 Deque 的头部和尾部添加和删除元素。如果当队列使用就是先进先出，如果是栈就是先进后出</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>Java 中的 Deque 是一个接口，它的实现提供了对可变大小数组的支持。所以你有一个数组不受限制的容量，你可以根据你的需要添加新的元素。</li>
<li>Deque 不支持多个线程的当前访问</li>
<li>在没有外部同步的情况下，双端队列不是线程安全的。</li>
<li>数组双端队列中不允许有 Null 元素。</li>
</ul>
<h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><ul>
<li>boolean add(element)添加一个元素到双端队列的尾部。成功时返回 true，如果当前没有可用空间则抛出 IllegalStateException。</li>
<li>addFirst(element)将一个元素添加到 Deque 的头部。</li>
<li>addLast(element)将一个元素添加到双端队列的尾部。</li>
<li>offer(element)在尾部添加一个元素并返回一个布尔值来说明插入是否成功。</li>
<li>offerFirst(element)向头部添加一个元素并返回一个布尔值来说明插入是否成功。</li>
<li>offerLast(element)在尾部添加一个元素并返回一个布尔值来说明插入是否成功。</li>
<li>iterator()返回双端队列的迭代器。</li>
<li>descendingIterator()返回一个迭代器，该迭代器具有与此双端队列相反的顺序。</li>
<li>push(element)向头部添加一个元素。</li>
<li>pop(element)从头部移除一个元素并返回它。</li>
<li>removeFirst()删除头部的元素。</li>
<li>removeLast()删除尾部的元素。</li>
<li>poll()检索并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空，则返回 null。</li>
<li>pollFirst()检索并删除此双端队列的第一个元素，如果此双端队列为空，则返回 null。</li>
<li>pollLast()检索并删除此双端队列的最后一个元素，如果此双端队列为空，则返回 null。</li>
<li>peek()检索但不移除此双端队列所代表的队列的头部（换句话说，此双端队列的第一个元素），或者如果此双端队列为空则返回 null。</li>
<li>peekFirst()检索但不删除此双端队列的第一个元素，如果此双端队列为空，则返回 null。</li>
<li>peekLast()检索但不删除此双端队列的最后一个元素，如果此双端队列为空，则返回 null。</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2023/02/01/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Java基础（一）"><a href="#Java基础（一）" class="headerlink" title="Java基础（一）"></a>Java基础（一）</h2><h3 id="Java语言的特点："><a href="#Java语言的特点：" class="headerlink" title="Java语言的特点："></a>Java语言的特点：</h3><ul>
<li>简单易学</li>
<li>面向对象（封装、继承、多态）</li>
<li>平台无关性（Java虚拟机实现平台无关性）</li>
<li>支持多线程</li>
<li>可靠性</li>
<li>安全性</li>
<li>支持网络编程并且很方便</li>
<li>编译与解释并存</li>
</ul>
<h3 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a>什么是字节码？采用字节码的好处是什么？</h3><p>JVM可以理解的代码就是字节码（扩展名.class文件），JVM解释器进行对字节码的解释比较慢、引入了JIT编译器，JIT属于运行时编译，当JIT编译完成第一次编译之后，热点代码和方法的字节码对应机器码会被保存下来，下次可以直接进行使用，而不需要再次被解释器进行解释。</p>
<p>好处：</p>
<ul>
<li>通过字节码的方式，在一定程度上解决了传统解释性语言执行效率低的问题，同时又保留了解释型语言可移植的特点</li>
<li>字节码不针对某一特定机器，所以Java不需要重新编译就可以在不同的操作系统的计算机运行。</li>
</ul>
<h3 id="Java源码一次编写，为啥能到处运行？"><a href="#Java源码一次编写，为啥能到处运行？" class="headerlink" title="Java源码一次编写，为啥能到处运行？"></a>Java源码一次编写，为啥能到处运行？</h3><p>&emsp;JVM（Java虚拟机）是关键原因。</p>
<p>&emsp;<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230204194523252.png" alt="image-20230204194523252"></p>
<blockquote>
<p>注意：Java程序是跨平台的程序、JVM是C/C++开发的软件，不同平台下的JVM版本不一样</p>
</blockquote>
<h3 id="为什么说Java语言“编译与解释并存”？"><a href="#为什么说Java语言“编译与解释并存”？" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h3><blockquote>
<p><strong>编译型：</strong>编译型语言可以通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较开，开发效率比较低，常见的编译型语言就是C、C++、GO等</p>
<p><strong>解释型：</strong>通过解释器将代码一句句解释成机器代码，解释型语言开发快，执行速度慢，常见的解释型语言就是PHP、Python、JavaScript等。</p>
</blockquote>
<p>&ensp;因为Java要先通过javac编译器将程序编译成字节码(.class文件)，然后通过Java解释器来解释执行。</p>
<h3 id="一个Java程序可包含多个类吗？（内部类除外）"><a href="#一个Java程序可包含多个类吗？（内部类除外）" class="headerlink" title="一个Java程序可包含多个类吗？（内部类除外）"></a>一个Java程序可包含多个类吗？（内部类除外）</h3><p>&emsp;可以包含多个类，但是被public修饰的类只有一个，且被public修饰的这个类必须跟类文件名同名</p>
<h3 id="Java的访问权限：private、protected、default、public"><a href="#Java的访问权限：private、protected、default、public" class="headerlink" title="Java的访问权限：private、protected、default、public"></a>Java的访问权限：private、protected、default、public</h3><p>&emsp;private &lt; default &lt; protected &lt; public：从左到右权限依次变大</p>
<p>&emsp;对成员变量/成员方法而言：</p>
<p>&emsp;&emsp;1、private：仅限该类内部成员访问</p>
<p>&emsp;&emsp;2、default：同包下的其他类成员以及该类内部成员可以访问</p>
<p>&emsp;&emsp;3、protected：同包下的其他类成员、该类内部成员、以及子类可以访问。</p>
<p>&emsp;&emsp;4、public：任意包下的任意类的成员均可访问。</p>
<p>&emsp;修饰类时，仅有default、public两种修饰符：</p>
<p>&emsp;&emsp;1、default：同包下的其他类可以访问</p>
<p>&emsp;&emsp;2、public：任意包下的任意类可以访问</p>
<blockquote>
<p>注：没有任何修饰符修饰，默认为default</p>
</blockquote>
<h3 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h3><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230204213714958.png" alt="image-20230204213714958"></p>
<p>byte(1 byte = 8 bits)&emsp;&emsp;&emsp;&emsp;&emsp;short(2 byte = 16 bits)&emsp;&emsp;&emsp;&emsp;&emsp;int(4 byte = 32 bits)&emsp;&emsp;&emsp;&emsp;&emsp;long(8 byte = 64 bits)</p>
<p>float(4 byte = 32 bits)&emsp;&emsp;&emsp;&emsp;double(8 byte = 64bits)&emsp;&emsp;&emsp;&emsp;&emsp;char(2byte = 16bits)&emsp;&emsp;&emsp;&emsp;&emsp;boolean(根据Java规范规定，不同JVM实现机制不同)</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>访问控制</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>类、方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td>enum</td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td>assert</td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p>
<ul>
<li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li>
<li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li>
<li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li>
</ul>
</blockquote>
<h3 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h3><p>这个需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><p><strong>1、调用方式</strong></p>
<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p>
<p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p>
<p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staicMethod</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 调用实例方法</span></span><br><span class="line">        person.method();</span><br><span class="line">        <span class="comment">// 调用静态方法</span></span><br><span class="line">        Person.staicMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、访问类成员是否存在限制</strong></p>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
<h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><ul>
<li>成员变量包装类型不赋值就<strong>是 <code>null</code></strong> ，而基本类型**有默认值且不是 <code>null</code>**。</li>
<li>包装类型可用于泛型，而基本类型不可以。</li>
<li>基本数据类型的<strong>局部变量</strong>存放在 Java 虚拟机<strong>栈</strong>中的局部变量表中，基本数据类型的<strong>成员变量（未被 <code>static</code> 修饰 ）</strong>存放在 Java 虚拟机的<strong>堆</strong>中。包装类型属于对象类型，我们知道<strong>几乎所有对象实例都存在于堆中</strong>。</li>
<li>相比于对象类型， 基本数据类型占用的空间非常小。</li>
</ul>
<p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p>
<p>⚠️ 注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果<strong>没有</strong>被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicTypeVar</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆区、栈区、方法区的区别："><a href="#堆区、栈区、方法区的区别：" class="headerlink" title="堆区、栈区、方法区的区别："></a>堆区、栈区、方法区的区别：</h3><p><strong>堆区:</strong> </p>
<p>1、存储的全部是对象 ，每个对象都包含一个与之对应的Class的信息。(Class的目的是得到操作指令) </p>
<p>2、JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 ，即实例对象</p>
<p><strong>栈区:</strong> </p>
<p>1、每个线程包含一个栈区 ，栈中 只保存基础数据类型的对象和自定义对象的引用(不是对象) ，对象都存放在堆区中 </p>
<p>2、每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问 。 </p>
<p>3、栈分为3个部分： 基本类型变量区、执行环境上下文、操作指令区(存放操作指令) 。 </p>
<p><strong>方法区:</strong> </p>
<p>1、又叫 静态区 ，跟堆一样， 被所有的线程共享 。方法区 包含所有的Class和static变量 。</p>
<p>2、方法区中包含的都是在整个程序中永远唯一的元素，如Class，static变量。</p>
<h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h3><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p><strong>Integer 缓存源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Character</code> 缓存源码:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Boolean</code> 缓存源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p>
<p><strong>OS:所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<h3 id="自动拆箱和自动装箱，原理是什么？"><a href="#自动拆箱和自动装箱，原理是什么？" class="headerlink" title="自动拆箱和自动装箱，原理是什么？"></a>自动拆箱和自动装箱，原理是什么？</h3><ul>
<li>拆箱：将包装类型转换成基本数据类型</li>
<li>装箱：将基本数据类型用对应的引用类型（包装类型）包装起来</li>
</ul>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>对应的字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure>

<p>装箱其实就是调用了包装类的<strong>valueOf()<strong>方法，</strong>拆箱</strong>其实就是调用了**xxxValue()**方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; =====&gt; <span class="type">Integer</span>  <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>)</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;  ======&gt;  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>GO-50度灰</title>
    <url>/2023/09/30/GO-50%E5%BA%A6%E7%81%B0/</url>
    <content><![CDATA[<h2 id="初级篇：1-34"><a href="#初级篇：1-34" class="headerlink" title="初级篇：1-34"></a>初级篇：1-34</h2><h3 id="1-左大括号-不能单独放一行"><a href="#1-左大括号-不能单独放一行" class="headerlink" title="1. 左大括号 { 不能单独放一行"></a>1. 左大括号 <code>&#123;</code> 不能单独放一行</h3><p>在其他大多数语言中，<code>&#123;</code> 的位置你自行决定。Go 比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加 <code>;</code> 来分隔多条语句，比如会在 <code>)</code> 后加分号：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>;    <span class="comment">// 无函数体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>./main.go: missing function body</p>
</blockquote>
<blockquote>
<p>./main.go: syntax error: unexpected semicolon or newline before {</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-未使用的变量"><a href="#2-未使用的变量" class="headerlink" title="2. 未使用的变量"></a>2. 未使用的变量</h3><p>如果在函数体代码中有未使用的变量，则无法通过编译，不过全局变量声明但不使用是可以的。</p>
<p>即使变量声明后为变量赋值，依旧无法通过编译，需在某处使用它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">var</span> gvar <span class="type">int</span>     <span class="comment">// 全局变量，声明不使用也可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> one <span class="type">int</span>     <span class="comment">// error: one declared and not used</span></span><br><span class="line">    two := <span class="number">2</span>    <span class="comment">// error: two declared and not used</span></span><br><span class="line">    <span class="keyword">var</span> three <span class="type">int</span>    <span class="comment">// error: three declared and not used</span></span><br><span class="line">    three = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以直接注释或移除未使用的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> one <span class="type">int</span></span><br><span class="line">    _ = one</span><br><span class="line"></span><br><span class="line">    two := <span class="number">2</span></span><br><span class="line">    <span class="built_in">println</span>(two)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> three <span class="type">int</span></span><br><span class="line">    one = three</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> four <span class="type">int</span></span><br><span class="line">    four = four</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-未使用的-import"><a href="#3-未使用的-import" class="headerlink" title="3. 未使用的 import"></a>3. 未使用的 import</h3><p>如果你 import 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。</p>
<p>可以使用 <code>_</code> 下划线符号作为别名来忽略导入的包，从而避免编译错误，这只会执行 package 的 <code>init()</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>    <span class="comment">// imported and not used: &quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span>    <span class="comment">// imported and not used: &quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span>    <span class="comment">// imported and not used: &quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以使用 goimports 工具来注释或移除未使用到的包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = log.Println</span><br><span class="line">    _ = time.Now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-简短声明的变量只能在函数内部使用"><a href="#4-简短声明的变量只能在函数内部使用" class="headerlink" title="4. 简短声明的变量只能在函数内部使用"></a>4. 简短声明的变量只能在函数内部使用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">myvar := <span class="number">1</span>    <span class="comment">// syntax error: non-declaration statement outside function body</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">var</span>  myvar = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-使用简短声明来重复声明变量"><a href="#5-使用简短声明来重复声明变量" class="headerlink" title="5. 使用简短声明来重复声明变量"></a>5. 使用简短声明来重复声明变量</h3><p>不能用简短声明方式来单独为一个变量重复声明， <code>:=</code> 左侧至少有一个新变量，才允许多变量的重复声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one := <span class="number">1</span> <span class="comment">// error: no new variables on left side of :=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one, two := <span class="number">1</span>, <span class="number">2</span>    <span class="comment">// two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err</span></span><br><span class="line">    one, two = two, one    <span class="comment">// 交换两个变量值的简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-不能使用简短声明来设置字段的值"><a href="#6-不能使用简短声明来设置字段的值" class="headerlink" title="6. 不能使用简短声明来设置字段的值"></a>6. 不能使用简短声明来设置字段的值</h3><p>struct 的变量字段不能使用 <code>:=</code> 来赋值以使用预定义的变量来避免解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">    result <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    data.result, err := work()    <span class="comment">// error: non-name data.result on left side of :=</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span>    <span class="comment">// err 需要预声明</span></span><br><span class="line"></span><br><span class="line">    data.result, err = work()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;info: %+v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-不小心覆盖了变量"><a href="#7-不小心覆盖了变量" class="headerlink" title="7. 不小心覆盖了变量"></a>7. 不小心覆盖了变量</h3><p>对从动态语言转过来的开发者来说，简短声明很好用，这可能会让人误会 <code>:=</code> 是一个赋值操作符。</p>
<p>如果你在新的代码块中像下边这样误用了 <code>:=</code>，编译不会报错，但是变量不会按你的预期工作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    <span class="built_in">println</span>(x)        <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println</span>(x)    <span class="comment">// 1</span></span><br><span class="line">        x := <span class="number">2</span></span><br><span class="line">        <span class="built_in">println</span>(x)    <span class="comment">// 2    // 新的 x 变量的作用域只在代码块内部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(x)        <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 Go 开发者常犯的错，而且不易被发现。</p>
<p>可使用 <a href="http://godoc.org/golang.org/x/tools/cmd/vet">vet</a> 工具来诊断这种变量覆盖，Go 默认不做覆盖检查，添加 <code>-shadow</code> 选项来启用：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&gt; go tool vet -shadow <span class="selector-tag">main</span><span class="selector-class">.go</span></span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">9</span>: declaration of <span class="string">&quot;x&quot;</span> shadows declaration at <span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>注意 vet 不会报告全部被覆盖的变量，可以使用 <a href="https://github.com/barakmich/go-nyet">go-nyet</a> 来做进一步的检测：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&gt; $GOPATH/bin/<span class="keyword">go</span>-nyet main.<span class="keyword">go</span></span><br><span class="line">main.<span class="keyword">go</span>:<span class="number">10</span>:<span class="number">3</span>:Shadowing variable <span class="string">`x`</span></span><br></pre></td></tr></table></figure>

<h3 id="8-显式类型的变量无法使用-nil-来初始化"><a href="#8-显式类型的变量无法使用-nil-来初始化" class="headerlink" title="8. 显式类型的变量无法使用 nil 来初始化"></a>8. 显式类型的变量无法使用 nil 来初始化</h3><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span>    <span class="comment">// error: use of untyped nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-直接使用值为-nil-的-slice、map"><a href="#9-直接使用值为-nil-的-slice、map" class="headerlink" title="9. 直接使用值为 nil 的 slice、map"></a>9. 直接使用值为 nil 的 slice、map</h3><p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">    m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>        <span class="comment">// error: panic: assignment to entry in nil map</span></span><br><span class="line">    <span class="comment">// m := make(map[string]int)// map 的正确声明，分配了实际的内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-map-容量"><a href="#10-map-容量" class="headerlink" title="10. map 容量"></a>10. map 容量</h3><p>在创建 map 类型的变量时可以指定容量，但不能像 slice 一样使用 <code>cap()</code> 来检测分配空间的大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="built_in">println</span>(<span class="built_in">cap</span>(m))     <span class="comment">// error: invalid argument m1 (type map[string]int) for cap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-string-类型的变量值不能为-nil"><a href="#11-string-类型的变量值不能为-nil" class="headerlink" title="11. string 类型的变量值不能为 nil"></a>11. string 类型的变量值不能为 nil</h3><p>对那些喜欢用 <code>nil</code> 初始化字符串的人来说，这就是坑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">string</span> = <span class="literal">nil</span>    <span class="comment">// cannot use nil as type string in assignment</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;    <span class="comment">// invalid operation: s == nil (mismatched types string and nil)</span></span><br><span class="line">        s = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">string</span>    <span class="comment">// 字符串类型的零值是空串 &quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        s = <span class="string">&quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-Array-类型的值作为函数参数"><a href="#12-Array-类型的值作为函数参数" class="headerlink" title="12. Array 类型的值作为函数参数"></a>12. Array 类型的值作为函数参数</h3><p>在 C/C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。</p>
<p>在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组使用值拷贝传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)            <span class="comment">// [1 2 3]    // 并不是你以为的 [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想修改参数数组：</p>
<ul>
<li>直接传递指向这个数组的指针类型：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传址会修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        (*arr)[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr)    <span class="comment">// &amp;[7 2 3]</span></span><br><span class="line">    &#125;(&amp;x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array）</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会修改 slice 的底层 array，从而修改 slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-range-遍历-slice-和-array-时混淆了返回值"><a href="#13-range-遍历-slice-和-array-时混淆了返回值" class="headerlink" title="13. range 遍历 slice 和 array 时混淆了返回值"></a>13. range 遍历 slice 和 array 时混淆了返回值</h3><p>与其他编程语言中的 <code>for-in</code> 、<code>foreach</code> 遍历语句不同，Go 中的 <code>range</code> 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">        fmt.Println(v)    <span class="comment">// 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;    <span class="comment">// 使用 _ 丢弃索引</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-slice-和-array-其实是一维数据"><a href="#14-slice-和-array-其实是一维数据" class="headerlink" title="14. slice 和 array 其实是一维数据"></a>14. slice 和 array 其实是一维数据</h3><p>看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。</p>
<p>对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。</p>
<p>可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。</p>
<ol>
<li>使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。</li>
<li>使用“独立”的切片分两步：</li>
</ol>
<ul>
<li><p>创建外部 slice</p>
</li>
<li><p>对每个内部 slice 进行内存分配<br>注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">2</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="type">int</span>, x)</span><br><span class="line">    <span class="keyword">for</span> i  := <span class="keyword">range</span> table &#123;</span><br><span class="line">        table[i] = <span class="built_in">make</span>([]<span class="type">int</span>, y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用“共享底层数组”的切片</li>
</ol>
<ul>
<li><p>创建一个存放原始数据的容器 slice</p>
</li>
<li><p>创建其他的 slice</p>
</li>
<li><p>切割原始 slice 来初始化其他的 slice</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    h, w := <span class="number">2</span>, <span class="number">4</span></span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">int</span>, h*w)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> raw &#123;</span><br><span class="line">        raw[i] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化原始 slice</span></span><br><span class="line">    fmt.Println(raw, &amp;raw[<span class="number">4</span>])    <span class="comment">// [0 1 2 3 4 5 6 7] 0xc420012120</span></span><br><span class="line"></span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="type">int</span>, h)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> table &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等间距切割原始 slice，创建动态多维数组 table</span></span><br><span class="line">        <span class="comment">// 0: raw[0*4: 0*4 + 4]</span></span><br><span class="line">        <span class="comment">// 1: raw[1*4: 1*4 + 4]</span></span><br><span class="line">        table[i] = raw[i*w : i*w + w]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(table, &amp;table[<span class="number">1</span>][<span class="number">0</span>])    <span class="comment">// [[0 1 2 3] [4 5 6 7]] 0xc420012120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多关于多维数组的参考</p>
<p><a href="https://stackoverflow.com/questions/39561140/go-how-is-two-dimensional-arrays-memory-representation">go-how-is-two-dimensional-arrays-memory-representation</a></p>
<p><a href="https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go">what-is-a-concise-way-to-create-a-2d-slice-in-go</a></p>
<h3 id="15-访问-map-中不存在的-key"><a href="#15-访问-map-中不存在的-key" class="headerlink" title="15. 访问 map 中不存在的 key"></a>15. 访问 map 中不存在的 key</h3><p>和其他编程语言类似，如果访问了 map 中不存在的 key 则希望能返回 nil，比如在 PHP 中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> php <span class="operator">-</span>r &#x27;<span class="variable">$v</span> <span class="operator">=</span> [<span class="string">&quot;x&quot;</span><span class="operator">=&gt;</span><span class="number">1</span>, <span class="string">&quot;y&quot;</span><span class="operator">=&gt;</span><span class="number">2</span>]; <span class="meta">@var_dump</span>(<span class="variable">$v</span>[<span class="string">&quot;z&quot;</span>]);&#x27;</span><br><span class="line"><span class="type">NULL</span></span><br></pre></td></tr></table></figure>

<p>Go 则会返回元素对应数据类型的零值，比如 <code>nil</code>、<code>&#39;&#39;</code> 、<code>false</code> 和 0，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。</p>
<p>检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的 key 检测方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> v := x[<span class="string">&quot;two&quot;</span>]; v == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)    <span class="comment">// 键 two 存不存在都会返回的空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;2&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="string">&quot;three&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> _, ok := x[<span class="string">&quot;two&quot;</span>]; !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key two is no entry&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-string-类型的值是常量，不可更改"><a href="#16-string-类型的值是常量，不可更改" class="headerlink" title="16. string 类型的值是常量，不可更改"></a>16. string 类型的值是常量，不可更改</h3><p>尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。</p>
<p>string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改字符串的错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    x[<span class="number">0</span>] = <span class="string">&quot;T&quot;</span>        <span class="comment">// error: cannot assign to x[0]</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    xBytes := []<span class="type">byte</span>(x)</span><br><span class="line">    xBytes[<span class="number">0</span>] = <span class="string">&#x27;T&#x27;</span>    <span class="comment">// 注意此时的 T 是 rune 类型</span></span><br><span class="line">    x = <span class="type">string</span>(xBytes)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。</p>
<p>更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;text&quot;</span></span><br><span class="line">    xRunes := []<span class="type">rune</span>(x)</span><br><span class="line">    xRunes[<span class="number">0</span>] = <span class="string">&#x27;我&#x27;</span></span><br><span class="line">    x = <span class="type">string</span>(xRunes)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// 我ext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-string-与-byte-slice-之间的转换"><a href="#17-string-与-byte-slice-之间的转换" class="headerlink" title="17. string 与 byte slice 之间的转换"></a>17. string 与 byte slice 之间的转换</h3><p>当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。</p>
<p>Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配：</p>
<ul>
<li>在 <code>map[string]</code> 中查找 key 时，使用了对应的 <code>[]byte</code>，避免做 <code>m[string(key)]</code> 的内存分配</li>
<li>使用 <code>for range</code> 迭代 string 转换为 []byte 的迭代：<code>for i,v := range []byte(str) &#123;...&#125;</code></li>
</ul>
<p>雾：<a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#string_byte_slice_conv">参考原文</a></p>
<h3 id="18-string-与索引操作符"><a href="#18-string-与索引操作符" class="headerlink" title="18. string 与索引操作符"></a>18. string 与索引操作符</h3><p>对字符串用索引访问返回的不是字符，而是一个 byte 值。</p>
<p>这种处理方式和其他语言一样，比如 PHP 中：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt; php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name);&#x27;</span>    <span class="comment"># &quot;中文&quot; 占用 6 个字节</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;中文&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0]);&#x27;</span> <span class="comment"># 把第一个字节当做 Unicode 字符读取，显示 U+FFFD</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;�&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; php -r <span class="string">&#x27;$name=&quot;中文&quot;; var_dump($name[0].$name[1].$name[2]);&#x27;</span></span><br><span class="line"><span class="keyword">string</span>(<span class="number">3</span>) <span class="string">&quot;中&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;ascii&quot;</span></span><br><span class="line">    fmt.Println(x[<span class="number">0</span>])        <span class="comment">// 97</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, x[<span class="number">0</span>])<span class="comment">// uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要使用 <code>for range</code> 迭代访问字符串中的字符（unicode code point / rune），标准库中有 <code>&quot;unicode/utf8&quot;</code> 包来做 UTF8 的相关解码编码。另外 <a href="https://godoc.org/golang.org/x/exp/utf8string">utf8string</a> 也有像 <code>func (s *String) At(i int) rune</code> 等很方便的库函数。</p>
<h3 id="19-字符串并不都是-UTF8-文本"><a href="#19-字符串并不都是-UTF8-文本" class="headerlink" title="19. 字符串并不都是 UTF8 文本"></a>19. 字符串并不都是 UTF8 文本</h3><p>string 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。</p>
<p>判断字符串是否是 UTF8 文本，可使用 “unicode/utf8” 包中的 <code>ValidString()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str1 := <span class="string">&quot;ABC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str1))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    str2 := <span class="string">&quot;A\xfeC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str2))    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    str3 := <span class="string">&quot;A\\xfeC&quot;</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str3))    <span class="comment">// true    // 把转义字符转义成字面值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-字符串的长度"><a href="#20-字符串的长度" class="headerlink" title="20. 字符串的长度"></a>20. 字符串的长度</h3><p>在 Python 中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">u&#x27;♥&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(data)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>然而在 Go 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(char))    <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 的内建函数 <code>len()</code> 返回的是字符串的 byte 数量，而不是像 Python 中那样是计算 Unicode 字符数。</p>
<p>如果要得到字符串的字符数，可使用 “unicode/utf8” 包中的 <code>RuneCountInString(str string) (n int)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">&quot;♥&quot;</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>RuneCountInString</code> 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 rune：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    <span class="keyword">char</span> := <span class="string">&quot;é&quot;</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(len(<span class="keyword">char</span>))    <span class="comment">// 3</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(utf8.RuneCountInString(<span class="keyword">char</span>))    <span class="comment">// 2</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">&quot;cafe\u0301&quot;</span>)    <span class="comment">// café    // 法文的 cafe，实际上是两个 rune 的组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.golang.org/normalization">normalization</a></p>
<h3 id="21-在多行-array、slice、map-语句中缺少-号"><a href="#21-在多行-array、slice、map-语句中缺少-号" class="headerlink" title="21. 在多行 array、slice、map 语句中缺少 , 号"></a>21. 在多行 array、slice、map 语句中缺少 <code>,</code> 号</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="type">int</span> &#123;</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>    <span class="comment">// syntax error: unexpected newline, expecting comma or &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    y := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;</span><br><span class="line">    z := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明语句中 <code>&#125;</code> 折叠到单行后，尾部的 <code>,</code> 不是必需的。</p>
<h3 id="22-log-Fatal-和-log-Panic-不只是-log"><a href="#22-log-Fatal-和-log-Panic-不只是-log" class="headerlink" title="22. log.Fatal 和 log.Panic 不只是 log"></a>22. <code>log.Fatal</code> 和 <code>log.Panic</code> 不只是 log</h3><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 <code>Fatal*()</code>、<code>Panic*()</code> 时能做更多日志外的事，如中断程序的执行等：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;Fatal level log: log entry&quot;</span>)        <span class="comment">// 输出信息后，程序终止执行</span></span><br><span class="line">    log.Println(<span class="string">&quot;Nomal level log: log entry&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-对内建数据结构的操作并不是同步的"><a href="#23-对内建数据结构的操作并不是同步的" class="headerlink" title="23. 对内建数据结构的操作并不是同步的"></a>23. 对内建数据结构的操作并不是同步的</h3><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。</p>
<p>goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。</p>
<h3 id="24-range-迭代-string-得到的值"><a href="#24-range-迭代-string-得到的值" class="headerlink" title="24. range 迭代 string 得到的值"></a>24. range 迭代 string 得到的值</h3><p>range 得到的索引是字符值（Unicode point / rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。</p>
<p>注意一个字符可能占多个 rune，比如法文单词 café 中的 é。操作特殊字符可使用<a href="https://golang.org/pkg/vendor/golang_org/x/text/unicode/norm/">norm</a> 包。</p>
<p>for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="string">&quot;A\xfe\x02\xff\x04&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)    <span class="comment">// 0x41 0xfffd 0x2 0xfffd 0x4    // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="type">byte</span>(data) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%#x &quot;</span>, v)    <span class="comment">// 0x41 0xfe 0x2 0xff 0x4    // 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-range-迭代-map"><a href="#25-range-迭代-map" class="headerlink" title="25. range 迭代 map"></a>25. range 迭代 map</h3><p>如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。</p>
<p>Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>, <span class="string">&quot;four&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你去 <a href="https://play.golang.org/">Go Playground</a> 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079494-de9e6a55-0bd7-4d37-9cf8-4edc3c9ee978.png" alt="img"></p>
<h3 id="26-switch-中的-fallthrough-语句"><a href="#26-switch-中的-fallthrough-语句" class="headerlink" title="26. switch 中的 fallthrough 语句"></a>26. switch 中的 fallthrough 语句</h3><p><code>switch</code> 语句中的 <code>case</code> 代码块会默认带上 break，但可以使用 <code>fallthrough</code> 来强制执行下一个 case 代码块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:    <span class="comment">// 空格符会直接 break，返回 false // 和其他语言不一样</span></span><br><span class="line">        <span class="comment">// fallthrough    // 返回 true</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过你可以在 case 代码块末尾使用 <code>fallthrough</code>，强制执行下一个 case 代码块。</p>
<p>也可以改写 case 为多条件判断：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27;\t&#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">&#x27; &#x27;</span>))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27-自增和自减运算"><a href="#27-自增和自减运算" class="headerlink" title="27. 自增和自减运算"></a>27. 自增和自减运算</h3><p>很多编程语言都自带前置后置的 <code>++</code>、<code>--</code> 运算。但 Go 特立独行，去掉了前置操作，同时 <code>++</code>、<code>—</code> 只作为运算符而非表达式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    ++i            <span class="comment">// syntax error: unexpected ++, expecting &#125;</span></span><br><span class="line">    fmt.Println(data[i++])    <span class="comment">// syntax error: unexpected ++, expecting :</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    i++</span><br><span class="line">    fmt.Println(data[i])    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-按位取反"><a href="#28-按位取反" class="headerlink" title="28. 按位取反"></a>28. 按位取反</h3><p>很多编程语言使用 <code>~</code> 作为一元按位取反（NOT）操作符，Go 重用 <code>^</code> XOR 操作符来按位取反：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的取反操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(~<span class="number">2</span>)        <span class="comment">// bitwise complement operator is ^</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d <span class="type">uint8</span> = <span class="number">2</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, d)        <span class="comment">// 00000010</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b\n&quot;</span>, ^d)    <span class="comment">// 11111101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时 <code>^</code> 也是按位异或（XOR）操作符。</p>
<p>一个操作符能重用两次，是因为一元的 NOT 操作 <code>NOT 0x02</code>，与二元的 XOR 操作 <code>0x22 XOR 0xff</code> 是一致的。</p>
<p>Go 也有特殊的操作符 AND NOT <code>&amp;^</code> 操作符，不同位才取1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">uint8</span> = <span class="number">0x82</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">uint8</span> = <span class="number">0x02</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b [A]\n&quot;</span>, a)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b [B]\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b (NOT B)\n&quot;</span>, ^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [B XOR 0xff]\n&quot;</span>, b, <span class="number">0xff</span>, b^<span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b ^ %08b = %08b [A XOR B]\n&quot;</span>, a, b, a^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b &amp; %08b = %08b [A AND B]\n&quot;</span>, a, b, a&amp;b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b &amp;^%08b = %08b [A &#x27;AND NOT&#x27; B]\n&quot;</span>, a, b, a&amp;^b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n&quot;</span>, a, b, a&amp;(^b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">10000010</span> [A]</span><br><span class="line"><span class="number">00000010</span> [B]</span><br><span class="line"><span class="number">11111101</span> (NOT B)</span><br><span class="line"><span class="number">00000010</span> ^ <span class="number">11111111</span> = <span class="number">11111101</span> [B XOR <span class="number">0xff</span>]</span><br><span class="line"><span class="number">10000010</span> ^ <span class="number">00000010</span> = <span class="number">10000000</span> [A XOR B]</span><br><span class="line"><span class="number">10000010</span> &amp; <span class="number">00000010</span> = <span class="number">00000010</span> [A AND B]</span><br><span class="line"><span class="number">10000010</span> &amp;^<span class="number">00000010</span> = <span class="number">10000000</span> [A <span class="string">&#x27;AND NOT&#x27;</span> B]</span><br><span class="line"><span class="number">10000010</span>&amp;(^<span class="number">00000010</span>)= <span class="number">10000000</span> [A AND (NOT B)]</span><br></pre></td></tr></table></figure>

<h3 id="29-运算符的优先级"><a href="#29-运算符的优先级" class="headerlink" title="29. 运算符的优先级"></a>29. 运算符的优先级</h3><p>除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;0x2 &amp; 0x2 + 0x4 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>&amp;<span class="number">0x2</span>+<span class="number">0x4</span>)    <span class="comment">// &amp; 优先 +</span></span><br><span class="line">    <span class="comment">//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:    (0x2 &amp; 0x2) + 0x4</span></span><br><span class="line">    <span class="comment">//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n&quot;</span>, <span class="number">0x2</span>+<span class="number">0x2</span>&lt;&lt;<span class="number">0x1</span>)    <span class="comment">// &lt;&lt; 优先 +</span></span><br><span class="line">    <span class="comment">//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:     0x2 + (0x2 &lt;&lt; 0x1)</span></span><br><span class="line">    <span class="comment">//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;0xf | 0x2 ^ 0x2 -&gt; %#x\n&quot;</span>, <span class="number">0xf</span>|<span class="number">0x2</span>^<span class="number">0x2</span>)    <span class="comment">// | 优先 ^</span></span><br><span class="line">    <span class="comment">//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span></span><br><span class="line">    <span class="comment">//Go:    (0xf | 0x2) ^ 0x2</span></span><br><span class="line">    <span class="comment">//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级列表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Precedence    Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure>

<h3 id="30-不导出的-struct-字段无法被-encode"><a href="#30-不导出的-struct-字段无法被-encode" class="headerlink" title="30. 不导出的 struct 字段无法被 encode"></a>30. 不导出的 struct 字段无法被 encode</h3><p>以小写字母开头的字段成员是无法被外部直接访问的，所以 <code>struct</code> 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := MyData&#123;<span class="number">1</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, in)    <span class="comment">// main.MyData&#123;One:1, two:&quot;two&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">    encoded, _ := json.Marshal(in)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(encoded))    <span class="comment">// &#123;&quot;One&quot;:1&#125;    // 私有字段 two 被忽略了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> out MyData</span><br><span class="line">    json.Unmarshal(encoded, &amp;out)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, out)     <span class="comment">// main.MyData&#123;One:1, two:&quot;&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="31-程序退出时还有-goroutine-在执行"><a href="#31-程序退出时还有-goroutine-在执行" class="headerlink" title="31. 程序退出时还有 goroutine 在执行"></a>31. 程序退出时还有 goroutine 在执行</h3><p>程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主程序会直接退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> doIt(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)        <span class="comment">// 模拟 goroutine 正在执行</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下，<code>main()</code> 主程序不等两个 goroutine 执行完就直接退出了：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079610-d9523090-8363-463a-b6f0-aa4e55a1b7ef.png" alt="img"></p>
<p>常用解决办法：使用 “WaitGroup” 变量，它会让主程序等待所有 goroutine 执行完毕再退出。</p>
<p>如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 <code>kill</code> 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 进入死锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, done, wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079522-5d8f767c-aa6d-4960-bcd3-795aca54b1da.png" alt="img"></p>
<p>看起来好像 goroutine 都执行完了，然而报错：</p>
<p>fatal error: all goroutines are asleep - deadlock!</p>
<p>为什么会发生死锁？goroutine 在退出前调用了 <code>wg.Done()</code> ，程序应该正常退出的。</p>
<p>原因是 goroutine 得到的 “WaitGroup” 变量是 <code>var wg WaitGroup</code> 的一份拷贝值，即 <code>doIt()</code> 传参只传值。所以哪怕在每个 goroutine 中都调用了 <code>wg.Done()</code>， 主程序中的 <code>wg</code> 变量并不会受到影响。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 使用传址方式为 WaitGroup 变量传参</span></span><br><span class="line"><span class="comment">// 使用 channel 关闭 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, ch, done, &amp;wg)    <span class="comment">// wg 传指针，doIt() 内部会改变 wg 的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;    <span class="comment">// 向 ch 中发送数据，关闭 goroutine</span></span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    fmt.Println(<span class="string">&quot;all done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="type">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;[%v] is running\n&quot;</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%v] m =&gt; %v\n&quot;</span>, workerID, m)</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;[%v] is done\n&quot;</span>, workerID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079530-48ae068a-8fe5-49b8-ba79-6aecc941525a.png" alt="img"></p>
<h3 id="32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回"><a href="#32-向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回" class="headerlink" title="32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回"></a>32. 向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回</h3><p>只有在数据被 receiver 处理时，sender 才会阻塞。因运行环境而异，在 sender 发送完数据后，receiver 的 goroutine 可能没有足够的时间处理下一个数据。如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Processed:&quot;</span>, m)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)    <span class="comment">// 模拟需要长时间运行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">&quot;cmd.1&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;cmd.2&quot;</span> <span class="comment">// 不会被接收处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079544-84c1140a-23ae-4858-80b7-b0adf759ee18.png" alt="img"></p>
<h3 id="33-向已关闭的-channel-发送数据会造成-panic"><a href="#33-向已关闭的-channel-发送数据会造成-panic" class="headerlink" title="33. 向已关闭的 channel 发送数据会造成 panic"></a>33. 向已关闭的 channel 发送数据会造成 panic</h3><p>从已关闭的 channel 接收数据是安全的：</p>
<p>接收状态值 <code>ok</code> 是 <code>false</code> 时表明 channel 中已没有数据可以接收了。类似的，从有缓冲的 channel 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 <code>false</code></p>
<p>向已关闭的 channel 中发送数据会造成 panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- idx</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-ch)        <span class="comment">// 输出第一个发送的值</span></span><br><span class="line">    <span class="built_in">close</span>(ch)            <span class="comment">// 不能关闭，还有其他的 sender</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)    <span class="comment">// 模拟做其他的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079495-645d7d98-a284-417a-94d0-a0b810b6d032.png" alt="img"></p>
<p>针对上边有 bug 的这个例子，可使用一个废弃 channel <code>done</code> 来告诉剩余的 goroutine 无需再向 ch 发送数据。此时 <code>&lt;- done</code> 的结果是 <code>&#123;&#125;</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>:</span><br><span class="line">                fmt.Println(idx, <span class="string">&quot;Send result&quot;</span>)</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                fmt.Println(idx, <span class="string">&quot;Exiting&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079515-81889255-1ad8-424a-9b46-20de774153b4.png" alt="img"></p>
<h3 id="34-使用了值为-nil-的-channel"><a href="#34-使用了值为-nil-的-channel" class="headerlink" title="34. 使用了值为 nil 的 channel"></a>34. 使用了值为 <code>nil</code> 的 channel</h3><p>在一个值为 nil 的 channel 上发送和接收数据将永久阻塞：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// 未初始化，值为 nil</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Result: &quot;</span>, &lt;-ch)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtime 死锁错误：</p>
<p>fatal error: all goroutines are asleep - deadlock!</p>
<p>goroutine 1 [chan receive (nil chan)]</p>
<p>利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> in &lt;-<span class="keyword">chan</span> <span class="type">int</span> = inCh</span><br><span class="line">        <span class="keyword">var</span> out <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line">        <span class="keyword">var</span> val <span class="type">int</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> out &lt;- val:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;--------&quot;</span>)</span><br><span class="line">                out = <span class="literal">nil</span></span><br><span class="line">                in = inCh</span><br><span class="line">            <span class="keyword">case</span> val = &lt;-in:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">&quot;++++++++++&quot;</span>)</span><br><span class="line">                out = outCh</span><br><span class="line">                in = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> r := <span class="keyword">range</span> outCh &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Result: &quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">0</span>)</span><br><span class="line">    inCh &lt;- <span class="number">1</span></span><br><span class="line">    inCh &lt;- <span class="number">2</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079586-ec05c601-40cf-4ae1-b8f6-c02b63226d74.png" alt="img"></p>
<h3 id="34-若函数-receiver-传参是传值方式，则无法修改参数的原有值"><a href="#34-若函数-receiver-传参是传值方式，则无法修改参数的原有值" class="headerlink" title="34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值"></a>34. 若函数 receiver 传参是传值方式，则无法修改参数的原有值</h3><p>方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。</p>
<p>除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num   <span class="type">int</span></span><br><span class="line">    key   *<span class="type">string</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span></span> pointerFunc() &#123;</span><br><span class="line">    this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span></span> valueFunc() &#123;</span><br><span class="line">    this.num = <span class="number">8</span></span><br><span class="line">    *this.key = <span class="string">&quot;valueFunc.key&quot;</span></span><br><span class="line">    this.items[<span class="string">&quot;valueFunc&quot;</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    key := <span class="string">&quot;key1&quot;</span></span><br><span class="line"></span><br><span class="line">    d := data&#123;<span class="number">1</span>, &amp;key, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.pointerFunc()    <span class="comment">// 修改 num 的值为 7</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.valueFunc()    <span class="comment">// 修改 key 和 items 的值</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;num=%v  key=%v  items=%v\n&quot;</span>, d.num, *d.key, d.items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079495-aac01481-dec9-4479-b0be-d9f7165af772.png" alt="img"></p>
<h2 id="中级篇：35-50"><a href="#中级篇：35-50" class="headerlink" title="中级篇：35-50"></a>中级篇：35-50</h2><h3 id="35-关闭-HTTP-的响应体"><a href="#35-关闭-HTTP-的响应体" class="headerlink" title="35. 关闭 HTTP 的响应体"></a>35. 关闭 HTTP 的响应体</h3><p>使用 HTTP 标准库发起请求、获取响应时，即使你不从响应中读取任何数据或响应为空，都需要手动关闭响应体。新手很容易忘记手动关闭，或者写在了错误的位置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求失败造成 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()    <span class="comment">// resp 可能为 nil，不能读取 Body</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边的代码能正确发起请求，但是一旦请求失败，变量 <code>resp</code> 值为 <code>nil</code>，造成 panic：</p>
<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
<p>应该先检查HTTP 响应错误为 <code>nil</code>，再调用 <code>resp.Body.Close()</code> 来关闭响应体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大多数情况正确的示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;https://api.ipify.org?format=json&quot;</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()    <span class="comment">// 绝大多数情况下的正确关闭方式</span></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>Get <a href="https://api.ipify.org/?format=json">https://api.ipify.org?format=…</a>: x509: certificate signed by unknown authority</p>
<p>绝大多数请求失败的情况下，<code>resp</code> 的值为 <code>nil</code> 且 <code>err</code> 为 <code>non-nil</code>。但如果你得到的是重定向错误，那它俩的值都是 <code>non-nil</code>，最后依旧可能发生内存泄露。2 个解决办法：</p>
<ul>
<li>可以直接在处理 HTTP 响应错误的代码块中，直接关闭非 nil 的响应体。</li>
<li>手动调用 <code>defer</code> 来关闭响应体：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭 resp.Body 的正确姿势</span></span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkError(err)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resp.Body.Close()</code> 早先版本的实现是读取响应体的数据之后丢弃，保证了 keep-alive 的 HTTP 连接能重用处理不止一个请求。但 Go 的最新版本将读取并丢弃数据的任务交给了用户，如果你不处理，HTTP 连接可能会直接关闭而非重用，参考在 Go 1.5 版本文档。</p>
<p>如果程序大量重用 HTTP 长连接，你可能要在处理响应的逻辑代码中加入：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">_, <span class="keyword">err</span> = io.<span class="keyword">Copy</span>(ioutil.<span class="keyword">Discard</span>, resp.Body)    <span class="comment">// 手动丢弃读取完毕的数据</span></span><br></pre></td></tr></table></figure>

<p>如果你需要完整读取响应，上边的代码是需要写的。比如在解码 API 的 JSON 响应数据：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">json</span>.<span class="type">NewDecoder</span>(resp.<span class="type">Body</span>).<span class="type">Decode</span>(&amp;<span class="class"><span class="keyword">data</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="36-关闭-HTTP-连接"><a href="#36-关闭-HTTP-连接" class="headerlink" title="36. 关闭 HTTP 连接"></a>36. 关闭 HTTP 连接</h3><p>一些支持 HTTP1.1 或 HTTP1.0 配置了 <code>connection: keep-alive</code> 选项的服务器会保持一段时间的长连接。但标准库 “net/http” 的连接默认只在服务器主动要求关闭时才断开，所以你的程序可能会消耗完 socket 描述符。解决办法有 2 个，请求结束后：</p>
<ul>
<li>直接设置请求变量的 <code>Close</code> 字段值为 <code>true</code>，每次请求结束后就会主动关闭连接。</li>
<li>设置 Header 请求头部选项 <code>Connection: close</code>，然后服务器返回的响应头部也会有这个选项，此时 HTTP 标准库会主动断开连接。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主动关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://golang.org&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    req.Close = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//req.Header.Add(&quot;Connection&quot;, &quot;close&quot;)    // 等效的关闭方式</span></span><br><span class="line"></span><br><span class="line">    resp, err := http.DefaultClient.Do(req)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以创建一个自定义配置的 HTTP transport 客户端，用来取消 HTTP 全局的复用连接：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tr := http.Transport&#123;DisableKeepAlives: <span class="literal">true</span>&#125;</span><br><span class="line">    client := http.Client&#123;Transport: &amp;tr&#125;</span><br><span class="line"></span><br><span class="line">    resp, err := client.Get(<span class="string">&quot;https://golang.google.cn/&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    &#125;</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(resp.StatusCode)    <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(<span class="type">string</span>(body)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据需求选择使用场景：</p>
<ul>
<li>若你的程序要向同一服务器发大量请求，使用默认的保持长连接。</li>
<li>若你的程序要连接大量的服务器，且每台服务器只请求一两次，那收到请求后直接关闭连接。或增加最大文件打开数 <code>fs.file-max</code> 的值。</li>
</ul>
<h3 id="37-将-JSON-中的数字解码为-interface-类型"><a href="#37-将-JSON-中的数字解码为-interface-类型" class="headerlink" title="37. 将 JSON 中的数字解码为 interface 类型"></a>37. 将 JSON 中的数字解码为 interface 类型</h3><p>在 encode/decode JSON 数据时，Go 默认会将数值当做 float64 处理，比如下边的代码会造成 panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, result[<span class="string">&quot;status&quot;</span>])    <span class="comment">// float64</span></span><br><span class="line">    <span class="keyword">var</span> status = result[<span class="string">&quot;status&quot;</span>].(<span class="type">int</span>)    <span class="comment">// 类型断言错误</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>panic: interface conversion: interface {} is float64, not int</p>
<p>如果你尝试 decode 的 JSON 字段是整型，你可以：</p>
<ul>
<li>将 int 值转为 float 统一使用</li>
<li>将 decode 后需要的 float 值转为 int 使用</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 decode 的值转为 int 使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(data, &amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> status = <span class="type">uint64</span>(result[<span class="string">&quot;status&quot;</span>].(<span class="type">float64</span>))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>Decoder</code> 类型来 decode JSON 数据，明确表示字段的值类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">    decoder.UseNumber()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> status, _ = result[<span class="string">&quot;status&quot;</span>].(json.Number).Int64()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 你可以使用 string 来存储数值数据，在 decode 时再决定按 int 还是 float 使用</span></span><br><span class="line"> <span class="comment">// 将数据转为 decode 为 string</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> data = []<span class="type">byte</span>(&#123;<span class="string">&quot;status&quot;</span>: <span class="number">200</span>&#125;)</span><br><span class="line">      <span class="keyword">var</span> result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">      <span class="keyword">var</span> decoder = json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">      decoder.UseNumber()</span><br><span class="line">      <span class="keyword">if</span> err := decoder.Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatalln(err)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">var</span> status <span class="type">uint64</span></span><br><span class="line">      err := json.Unmarshal([]<span class="type">byte</span>(result[<span class="string">&quot;status&quot;</span>].(json.Number).String()), &amp;status);</span><br><span class="line">    checkError(err)</span><br><span class="line">       fmt.Println(<span class="string">&quot;Status value: &quot;</span>, status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>- 使用 <code>struct</code> 类型将你需要的数据映射为数值型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// struct 中指定字段类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">var</span> data = []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;: 200&#125;`</span>)</span><br><span class="line">      <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">          Status <span class="type">uint64</span> <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result)</span><br><span class="line">      checkError(err)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Result: %+v&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用 <code>struct</code> 将数值类型映射为 <code>json.RawMessage</code> 原生数据类型<br>适用于如果 JSON 数据不着急 decode 或 JSON 某个字段的值类型不固定等情况：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态名称可能是 int 也可能是 string，指定为 json.RawMessage 类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    records := [][]<span class="type">byte</span>&#123;</span><br><span class="line">        []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:200, &quot;tag&quot;:&quot;one&quot;&#125;`</span>),</span><br><span class="line">        []<span class="type">byte</span>(<span class="string">`&#123;&quot;status&quot;:&quot;ok&quot;, &quot;tag&quot;:&quot;two&quot;&#125;`</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, record := <span class="keyword">range</span> records &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">            StatusCode <span class="type">uint64</span></span><br><span class="line">            StatusName <span class="type">string</span></span><br><span class="line">            Status     json.RawMessage <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">            Tag        <span class="type">string</span>          <span class="string">`json:&quot;tag&quot;`</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result)</span><br><span class="line">        checkError(err)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">        err = json.Unmarshal(result.Status, &amp;name)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            result.StatusName = name</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> code <span class="type">uint64</span></span><br><span class="line">        err = json.Unmarshal(result.Status, &amp;code)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            result.StatusCode = code</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(<span class="string">&quot;[%v] result =&gt; %+v\n&quot;</span>, idx, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="38-struct、array、slice-和-map-的值比较"><a href="#38-struct、array、slice-和-map-的值比较" class="headerlink" title="38. struct、array、slice 和 map 的值比较"></a>38. struct、array、slice 和 map 的值比较</h3><p>可以使用相等运算符 <code>==</code> 来比较结构体变量，前提是两个结构体的成员都是可比较的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num     <span class="type">int</span></span><br><span class="line">    fp      <span class="type">float32</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="type">complex64</span></span><br><span class="line">    str     <span class="type">string</span></span><br><span class="line">    char    <span class="type">rune</span></span><br><span class="line">    yes     <span class="type">bool</span></span><br><span class="line">    events  &lt;-<span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">    handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ref     *<span class="type">byte</span></span><br><span class="line">    raw     [<span class="number">10</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num    <span class="type">int</span></span><br><span class="line">    checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>        <span class="comment">// 无法比较</span></span><br><span class="line">    doIt   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>        <span class="comment">// 无法比较</span></span><br><span class="line">    m      <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>    <span class="comment">// 无法比较</span></span><br><span class="line">    bytes  []<span class="type">byte</span>            <span class="comment">// 无法比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, v1 == v2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invalid operation: v1 == v2 (struct containing [10]func() bool cannot be compared)</p>
<p>Go 提供了一些库函数来比较那些无法使用 <code>==</code> 比较的变量，比如使用 “reflect” 包的 <code>DeepEqual()</code> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较相等运算符无法比较的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;one&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(m1, m2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    s2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">       <span class="comment">// 注意两个 slice 相等，值和顺序必须一致</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(s1, s2))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种比较方式可能比较慢，根据你的程序需求来使用。<code>DeepEqual()</code> 还有其他用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, reflect.DeepEqual(b1, b2))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>DeepEqual()</code> 并不总适合于比较 slice</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;one&quot;</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;one&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;str == in: &quot;</span>, reflect.DeepEqual(str, in))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    v1 := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    v2 := []<span class="type">string</span>&#123;<span class="string">&quot;two&quot;</span>, <span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;v1 == v2: &quot;</span>, reflect.DeepEqual(v1, v2))    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;code&quot;</span>:  <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    encoded, _ := json.Marshal(data)</span><br><span class="line">    <span class="keyword">var</span> decoded <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    json.Unmarshal(encoded, &amp;decoded)</span><br><span class="line">    fmt.Println(<span class="string">&quot;data == decoded: &quot;</span>, reflect.DeepEqual(data, decoded))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要大小写不敏感来比较 byte 或 string 中的英文文本，可以使用 “bytes” 或 “strings” 包的 <code>ToUpper()</code> 和 <code>ToLower()</code> 函数。比较其他语言的 byte 或 string，应使用 <code>bytes.EqualFold()</code> 和 <code>strings.EqualFold()</code></p>
<p>如果 byte slice 中含有验证用户身份的数据（密文哈希、token 等），不应再使用 <code>reflect.DeepEqual()</code>、<code>bytes.Equal()</code>、 <code>bytes.Compare()</code>。这三个函数容易对程序造成 <a href="http://en.wikipedia.org/wiki/Timing_attack">timing attacks</a>，此时应使用 “crypto/subtle” 包中的 <code>subtle.ConstantTimeCompare()</code> 等函数</p>
<ul>
<li><code>reflect.DeepEqual()</code> 认为空 slice 与 nil slice 并不相等，但注意 <code>byte.Equal()</code> 会认为二者相等：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="type">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b1 与 b2 长度相等、有相同的字节序</span></span><br><span class="line">    <span class="comment">// nil 与 slice 在字节上是相同的</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b1 == b2: &quot;</span>, bytes.Equal(b1, b2))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="39-从-panic-中恢复"><a href="#39-从-panic-中恢复" class="headerlink" title="39. 从 panic 中恢复"></a>39. 从 panic 中恢复</h3><p>在一个 defer 延迟执行的函数中调用 <code>recover()</code> ，它便能捕捉 / 中断 panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">recover</span>()    <span class="comment">// 什么都不会捕捉</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)    <span class="comment">// 发生 panic，主程序退出</span></span><br><span class="line">    <span class="built_in">recover</span>()    <span class="comment">// 不会被执行</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;recovered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上边可以看出，<code>recover()</code> 仅在 defer 执行的函数中调用才会生效。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        doRecover()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;not good&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;recobered: &quot;</span>, <span class="built_in">recover</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>recobered:  panic: not good</p>
<h3 id="40-在-range-迭代-slice、array、map-时通过更新引用来更新元素"><a href="#40-在-range-迭代-slice、array、map-时通过更新引用来更新元素" class="headerlink" title="40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素"></a>40. 在 range 迭代 slice、array、map 时通过更新引用来更新元素</h3><p>在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v *= <span class="number">10</span>        <span class="comment">// data 中原有元素是不会被修改的</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;data: &quot;</span>, data)    <span class="comment">// data:  [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要修改原有元素的值，应该使用索引直接访问：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        data[i] = v * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;data: &quot;</span>, data)    <span class="comment">// data:  [10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []*<span class="keyword">struct</span>&#123; num <span class="type">int</span> &#125;&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;,&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v.num *= <span class="number">10</span>    <span class="comment">// 直接使用指针更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])    <span class="comment">// &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="41-slice-中隐藏的数据"><a href="#41-slice-中隐藏的数据" class="headerlink" title="41. slice 中隐藏的数据"></a>41. slice 中隐藏的数据</h3><p>从 slice 中重新切出新 slice 时，新 slice 会引用原 slice 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    <span class="keyword">return</span> raw[:<span class="number">3</span>]    <span class="comment">// 重新分配容量为 10000 的 slice</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])    <span class="comment">// 3 10000 0xc420080000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过拷贝临时 slice 的数据，而不是重新切片来解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> (res []<span class="type">byte</span>) &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    res = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res, raw[:<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])    <span class="comment">// 3 3 0xc4200160b8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="42-Slice-中数据的误用"><a href="#42-Slice-中数据的误用" class="headerlink" title="42. Slice 中数据的误用"></a>42. Slice 中数据的误用</h3><p>举个简单例子，重写文件路径（存储在 slice 中）</p>
<p>分割路径来指向每个不同级的目录，修改第一个目录名再重组子目录名，创建新路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误使用 slice 的拼接示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">println</span>(sepIndex)</span><br><span class="line"></span><br><span class="line">    dir1 := path[:sepIndex]</span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAA</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// BBBBBBBBB</span></span><br><span class="line"></span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line">       <span class="built_in">println</span>(<span class="string">&quot;current path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffixBBBB</span></span><br><span class="line"></span><br><span class="line">    path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAAsuffix</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// uffixBBBB</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffix/uffixBBBB    // 错误结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拼接的结果不是正确的 <code>AAAAsuffix/BBBBBBBBB</code>，因为 dir1、 dir2 两个 slice 引用的数据都是 <code>path</code> 的底层数组，第 13 行修改 <code>dir1</code> 同时也修改了 <code>path</code>，也导致了 <code>dir2</code> 的修改</p>
<p>解决方法：</p>
<ul>
<li>重新分配新的 slice 并拷贝你需要的数据</li>
<li>使用完整的 slice 表达式：<code>input[low:high:max]</code>，容量便调整为 max - low</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 full slice expression</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    path := []<span class="type">byte</span>(<span class="string">&quot;AAAA/BBBBBBBBB&quot;</span>)</span><br><span class="line">    sepIndex := bytes.IndexByte(path, <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 4</span></span><br><span class="line">    dir1 := path[:sepIndex:sepIndex]        <span class="comment">// 此时 cap(dir1) 指定为4， 而不是先前的 16</span></span><br><span class="line">    dir2 := path[sepIndex+<span class="number">1</span>:]</span><br><span class="line">    dir1 = <span class="built_in">append</span>(dir1, <span class="string">&quot;suffix&quot;</span>...)</span><br><span class="line"></span><br><span class="line">    path = bytes.Join([][]<span class="type">byte</span>&#123;dir1, dir2&#125;, []<span class="type">byte</span>&#123;<span class="string">&#x27;/&#x27;</span>&#125;)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir1: &quot;</span>, <span class="type">string</span>(dir1))        <span class="comment">// AAAAsuffix</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;dir2: &quot;</span>, <span class="type">string</span>(dir2))        <span class="comment">// BBBBBBBBB</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;new path: &quot;</span>, <span class="type">string</span>(path))    <span class="comment">// AAAAsuffix/BBBBBBBBB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 6 行中第三个参数是用来控制 dir1 的新容量，再往 dir1 中 append 超额元素时，将分配新的 buffer 来保存。而不是覆盖原来的 path 底层数组</p>
<h3 id="43-旧-slice"><a href="#43-旧-slice" class="headerlink" title="43. 旧 slice"></a>43. 旧 slice</h3><p>当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。</p>
<p>某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过容量将重新分配数组来拷贝值、重新存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)    <span class="comment">// 3 3 [1 2 3 ]</span></span><br><span class="line"></span><br><span class="line">    s2 := s1[<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)    <span class="comment">// 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时的 s1 与 s2 是指向同一个底层数组的</span></span><br><span class="line">    fmt.Println(s1)        <span class="comment">// [1 22 23]</span></span><br><span class="line">    fmt.Println(s2)        <span class="comment">// [22 23]</span></span><br><span class="line"></span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">4</span>)    <span class="comment">// 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s1)        <span class="comment">// [1 22 23]    // 此时的 s1 不再更新，为旧数据</span></span><br><span class="line">    fmt.Println(s2)        <span class="comment">// [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44-类型声明与方法"><a href="#44-类型声明与方法" class="headerlink" title="44. 类型声明与方法"></a>44. 类型声明与方法</h3><p>从一个现有的非 interface 类型创建新类型时，并不会继承原有的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Mutex 的自定义类型</span></span><br><span class="line"><span class="keyword">type</span> myMutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mtx myMutex</span><br><span class="line">    mtx.Lock()</span><br><span class="line">    mtx.UnLock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mtx.Lock undefined (type myMutex has no field or method Lock)…</p>
<p>如果你需要使用原类型的方法，可将原类型以匿名字段的形式嵌到你定义的新 struct 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型以字段形式直接嵌入</span></span><br><span class="line"><span class="keyword">type</span> myLocker <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> locker myLocker</span><br><span class="line">    locker.Lock()</span><br><span class="line">    locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>interface 类型声明也保留它的方法集：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myLocker sync.Locker</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> locker myLocker</span><br><span class="line">    locker.Lock()</span><br><span class="line">    locker.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="45-跳出-for-switch-和-for-select-代码块"><a href="#45-跳出-for-switch-和-for-select-代码块" class="headerlink" title="45. 跳出 for-switch 和 for-select 代码块"></a>45. 跳出 for-switch 和 for-select 代码块</h3><p>没有指定标签的 break 只会跳出 switch/select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// break 配合 label 跳出指定代码块</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">loop:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;breaking out...&quot;</span>)</span><br><span class="line">            <span class="comment">//break    // 死循环，一直打印 breaking out...</span></span><br><span class="line">            <span class="keyword">break</span> loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;out...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>goto</code> 虽然也能跳转到指定位置，但依旧会再次进入 for-switch，死循环。</p>
<h3 id="46-for-语句中的迭代变量与闭包函数"><a href="#46-for-语句中的迭代变量与闭包函数" class="headerlink" title="46. for 语句中的迭代变量与闭包函数"></a>46. for 语句中的迭代变量与闭包函数</h3><p>for 语句中的迭代变量在每次迭代中都会重用，即 for 中创建的闭包函数接收到的参数始终是同一个变量，在 goroutine 开始执行时都会得到同一个迭代值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的解决方法：无需修改 goroutine 函数，在 for 内部使用局部变量保存迭代值，再传参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        vCopy := v</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(vCopy)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个解决方法：直接将当前的迭代值以参数形式传递给匿名函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">string</span>&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(in)</span><br><span class="line">        &#125;(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意下边这个稍复杂的 3 个示例区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> field <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *field)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">    fmt.Println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v := v</span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []*field&#123;&#123;<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="string">&quot;three&quot;</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;    <span class="comment">// 此时迭代值 v 是三个元素值的地址，每次 v 指向的值不同</span></span><br><span class="line">        <span class="keyword">go</span> v.<span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="47-defer-函数的参数值"><a href="#47-defer-函数的参数值" class="headerlink" title="47. defer 函数的参数值"></a>47. defer 函数的参数值</h3><p>对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 defer 函数中参数会提前求值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;result: &quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;())</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>result: 2</p>
<h3 id="48-defer-函数的执行时机"><a href="#48-defer-函数的执行时机" class="headerlink" title="48. defer 函数的执行时机"></a>48. defer 函数的执行时机</h3><p>对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。</p>
<p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行参数指定目录名</span></span><br><span class="line"><span class="comment">// 遍历读取目录下的文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dir := os.Args[<span class="number">1</span>]</span><br><span class="line">    start, err := os.Stat(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir() &#123;</span><br><span class="line">        os.Exit(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> targets []<span class="type">string</span></span><br><span class="line">    filepath.Walk(dir, <span class="function"><span class="keyword">func</span><span class="params">(fPath <span class="type">string</span>, fInfo os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !fInfo.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targets = <span class="built_in">append</span>(targets, fPath)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        f, err := os.Open(target)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)    <span class="comment">//error:too many open files</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()    <span class="comment">// 在每次 for 语句块结束时，不会关闭文件资源</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 f 资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建 10000 个文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"><span class="keyword">for</span> n in &#123;<span class="number">1.</span><span class="number">.10000</span>&#125;; do</span><br><span class="line">    echo content &gt; <span class="string">&quot;file$&#123;n&#125;.txt&quot;</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079519-ec32c68a-4892-4e5c-bced-cd3d864c960f.png" alt="img"></p>
<p>解决办法：defer 延迟执行的函数写入匿名函数中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目录遍历正常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, err := os.Open(target)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;bad target:&quot;</span>, target, <span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span>    <span class="comment">// 在匿名函数内使用 return 代替 break 即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close()    <span class="comment">// 匿名函数执行结束，调用关闭文件资源</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 f 资源</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 <code>f.Close()</code> 来关闭。</p>
<h3 id="49-失败的类型断言"><a href="#49-失败的类型断言" class="headerlink" title="49. 失败的类型断言"></a>49. 失败的类型断言</h3><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// data 混用</span></span><br><span class="line">    <span class="keyword">if</span> data, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)    <span class="comment">// [isn&#x27;t a int], data:  0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;great&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res, ok := data.(<span class="type">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[is an int], data: &quot;</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[not an int], data: &quot;</span>, data)    <span class="comment">// [not an int], data:  great</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="50-阻塞的-gorutinue-与资源泄露"><a href="#50-阻塞的-gorutinue-与资源泄露" class="headerlink" title="50. 阻塞的 gorutinue 与资源泄露"></a>50. 阻塞的 gorutinue 与资源泄露</h3><p>在 2012 年 Google I/O 大会上，Rob Pike 的 <a href="https://talks.golang.org/2012/concurrency.slide#1">Go Concurrency Patterns</a> 演讲讨论 Go 的几种基本并发模式，如 <a href="https://repl.it/@pllv/Google-Search-Gorountine-Parallel-Replicas-Rob-Pike">完整代码</a> 中从数据集中获取第一条数据的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas []Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    replicaSearch := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> replicaSearch(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在搜索重复时依旧每次都起一个 goroutine 去处理，每个 goroutine 都把它的搜索结果发送到结果 channel 中，channel 中收到的第一条数据会直接返回。</p>
<p>返回完第一条数据后，其他 goroutine 的搜索结果怎么处理？他们自己的协程如何处理？</p>
<p>在 <code>First()</code> 中的结果 channel 是无缓冲的，这意味着只有第一个 goroutine 能返回，由于没有 receiver，其他的 goroutine 会在发送上一直阻塞。如果你大量调用，则可能造成资源泄露。</p>
<p>为避免泄露，你应该确保所有的 goroutine 都能正确退出，有 2 个解决方法：</p>
<ul>
<li>使用带缓冲的 channel，确保能接收全部 goroutine 的返回结果：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="built_in">len</span>(replicas))</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>select</code> 语句，配合能保存一个缓冲值的 channel <code>default</code> 语句：<br><code>default</code> 的缓冲 channel 保证了即使结果 channel 收不到数据，也不会阻塞 goroutine</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result,<span class="number">1</span>)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用特殊的废弃（cancellation） channel 来中断剩余 goroutine 的执行：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">    searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- replicas[i](query):</span><br><span class="line">        <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line">        <span class="keyword">go</span> searchReplica(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rob Pike 为了简化演示，没有提及演讲代码中存在的这些问题。不过对于新手来说，可能会不加思考直接使用。</p>
<h2 id="高级篇：51-57"><a href="#高级篇：51-57" class="headerlink" title="高级篇：51-57"></a>高级篇：51-57</h2><h3 id="51-使用指针作为方法的-receiver"><a href="#51-使用指针作为方法的-receiver" class="headerlink" title="51. 使用指针作为方法的 receiver"></a>51. 使用指针作为方法的 receiver</h3><p>只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。</p>
<p>但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *data)</span></span> <span class="built_in">print</span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;name: &quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := data&#123;<span class="string">&quot;one&quot;</span>&#125;</span><br><span class="line">    d1.<span class="built_in">print</span>()    <span class="comment">// d1 变量可寻址，可直接调用指针 receiver 的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> in printer = data&#123;<span class="string">&quot;two&quot;</span>&#125;</span><br><span class="line">    in.<span class="built_in">print</span>()    <span class="comment">// 类型不匹配</span></span><br><span class="line"></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: data&#123;<span class="string">&quot;three&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].<span class="built_in">print</span>()    <span class="comment">// m[&quot;x&quot;] 是不可寻址的    // 变动频繁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cannot use data literal (type data) as type printer in assignment:</p>
<p>data does not implement printer (print method has pointer receiver)</p>
<p>cannot call pointer method on m[“x”]</p>
<p>cannot take the address of m[“x”]</p>
<h3 id="52-更新-map-字段的值"><a href="#52-更新-map-字段的值" class="headerlink" title="52. 更新 map 字段的值"></a>52. 更新 map 字段的值</h3><p>如果 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无法直接更新 struct 的字段值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cannot assign to struct field m[“x”].name in map</p>
<p>因为 map 中的元素是不可寻址的。需区分开的是，slice 的元素可寻址：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []data&#123;&#123;<span class="string">&quot;Tom&quot;</span>&#125;&#125;</span><br><span class="line">    s[<span class="number">0</span>].name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">    fmt.Println(s)    <span class="comment">// [&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不久前 gccgo 编译器可更新 map struct 元素的字段值，不过很快便修复了，官方认为是 Go1.3 的潜在特性，无需及时实现，依旧在 todo list 中。</p>
<p>更新 map 中 struct 元素的字段值，有 2 个方法：</p>
<ul>
<li>使用局部变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取整个 struct 到局部变量中，修改字段值后再整个赋值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    r := m[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">    r.name = <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>] = r</span><br><span class="line">    fmt.Println(m)    <span class="comment">// map[x:&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用指向元素的 map 指针</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m[<span class="string">&quot;x&quot;</span>].name = <span class="string">&quot;Jerry&quot;</span>    <span class="comment">// 直接修改 m[&quot;x&quot;] 中的字段</span></span><br><span class="line">    fmt.Println(m[<span class="string">&quot;x&quot;</span>])    <span class="comment">// &amp;&#123;Jerry&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是要注意下边这种误用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]*data&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>: &#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">&quot;z&quot;</span>].name = <span class="string">&quot;what???&quot;</span></span><br><span class="line">    fmt.Println(m[<span class="string">&quot;x&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
<h3 id="53-nil-interface-和-nil-interface-值"><a href="#53-nil-interface-和-nil-interface-值" class="headerlink" title="53. nil interface 和 nil interface 值"></a>53. nil interface 和 nil interface 值</h3><p>虽然 interface 看起来像指针类型，但它不是。interface 类型的变量只有在类型和值均为 nil 时才为 nil</p>
<p>如果你的 interface 变量的值是跟随其他变量变化的（雾），与 nil 比较相等时小心：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data *<span class="type">byte</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(data, data == <span class="literal">nil</span>)    <span class="comment">// &lt;nil&gt; true</span></span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)    <span class="comment">// &lt;nil&gt; true</span></span><br><span class="line"></span><br><span class="line">    in = data</span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)    <span class="comment">// &lt;nil&gt; false    // data 值为 nil，但 in 值不为 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的函数返回值类型是 interface，更要小心这个坑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)    <span class="comment">// Good result:  &lt;nil&gt;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, res)            <span class="comment">// *struct &#123;&#125;    // res 不是 nil，它的值为 nil</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, res)            <span class="comment">// &lt;nil&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">int</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>    <span class="comment">// 明确指明返回 nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Good result: &quot;</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Bad result: &quot;</span>, res)    <span class="comment">// Bad result:  &lt;nil&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="54-堆栈变量"><a href="#54-堆栈变量" class="headerlink" title="54. 堆栈变量"></a>54. 堆栈变量</h3><p>你并不总是清楚你的变量是分配到了堆还是栈。</p>
<p>在 C++ 中使用 <code>new</code> 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 <code>new()</code>、<code>make()</code> 来创建变量，变量为内存分配位置依旧归 Go 编译器管。</p>
<p>Go 编译器会根据变量的大小及其 “escape analysis” 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C/C++ 中是不行的。</p>
<p>在 go build 或 go run 时，加入 -m 参数，能准确分析程序的变量分配位置：</p>
<p> <img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079583-c6b22446-874e-41ce-8898-39d36c0881b5.png" alt="img"></p>
<h3 id="55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）"><a href="#55-GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）" class="headerlink" title="55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）"></a>55. GOMAXPROCS、Concurrency（并发）and Parallelism（并行）</h3><p>Go 1.4 及以下版本，程序只会使用 1 个执行上下文 / OS 线程，即任何时间都最多只有 1 个 goroutine 在执行。</p>
<p>Go 1.5 版本将可执行上下文的数量设置为 <code>runtime.NumCPU()</code> 返回的逻辑 CPU 核心数，这个数与系统实际总的 CPU 逻辑核心数是否一致，取决于你的 CPU 分配给程序的核心数，可以使用 <code>GOMAXPROCS</code> 环境变量或者动态的使用 <code>runtime.GOMAXPROCS()</code> 来调整。</p>
<p>误区：<code>GOMAXPROCS</code> 表示执行 goroutine 的 CPU 核心数，参考<a href="https://golang.org/pkg/runtime/">文档</a></p>
<p><code>GOMAXPROCS</code> 的值是可以超过 CPU 的实际数量的，在 1.5 中最大为 256</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))    <span class="comment">// 4</span></span><br><span class="line">    fmt.Println(runtime.NumCPU())    <span class="comment">// 4</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))    <span class="comment">// 20</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">300</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>))    <span class="comment">// Go 1.9.2 // 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="56-读写操作的重新排序"><a href="#56-读写操作的重新排序" class="headerlink" title="56. 读写操作的重新排序"></a>56. 读写操作的重新排序</h3><p>Go 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = runtime.GOMAXPROCS(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">u2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    b = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(a)</span><br><span class="line">    <span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> u1()    <span class="comment">// 多个 goroutine 的执行顺序不定</span></span><br><span class="line">    <span class="keyword">go</span> u2()</span><br><span class="line">    <span class="keyword">go</span> p()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079530-1ec1022c-6083-4b1a-93fd-982ef37ae959.png" alt="img"></p>
<p>如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。</p>
<h3 id="57-优先调度"><a href="#57-优先调度" class="headerlink" title="57. 优先调度"></a>57. 优先调度</h3><p>你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 <code>for</code> 循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code> 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。</p>
<p>调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;not done !&quot;</span>)    <span class="comment">// 并不内联执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以添加 <code>-m</code> 参数来分析 <code>for</code> 代码块中调用的内联函数：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/106947/1575377079553-0bfc962d-ba49-426c-b720-43d42581d3af.png" alt="img"></p>
<p>你也可以使用 runtime 包中的 <code>Gosched()</code> 来 手动启动调度器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;done !&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行效果：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1575377079699-1d179d4e-3e72-4be3-8595-67d600aa223e.png" alt="img"></p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-Grammar</title>
    <url>/2023/09/29/Go-Grammar/</url>
    <content><![CDATA[<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p>Go语言设计的关键字，了解这些关键字有助于命名变量的冲突避免</p>
<h3 id="go的二十五个关键字"><a href="#go的二十五个关键字" class="headerlink" title="go的二十五个关键字"></a>go的二十五个关键字</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>    <span class="keyword">default</span>      func    <span class="keyword">interface</span>    <span class="symbol">select</span></span><br><span class="line"><span class="symbol">case</span>     <span class="symbol">defer</span>        <span class="symbol">go</span>      <span class="symbol">map</span>          <span class="symbol">struct</span></span><br><span class="line"><span class="symbol">chan</span>     <span class="symbol">else</span>         <span class="symbol">goto</span>    <span class="symbol">package</span>      <span class="symbol">switch</span></span><br><span class="line"><span class="symbol">const</span>    <span class="symbol">fallthrough</span>  <span class="symbol">if</span>      <span class="symbol">range</span>        <span class="symbol">type</span></span><br><span class="line"><span class="symbol">continue</span> <span class="symbol">for</span>          <span class="symbol">import</span>  <span class="symbol">return</span>       <span class="symbol">var</span></span><br></pre></td></tr></table></figure>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p><code>var</code>和<code>const</code> 是 Go语言基础里面的变量和常量申明</p>
</li>
<li><p><code>package</code>和<code>import</code> 用于分包和导入</p>
</li>
<li><p><code>func</code> 用于定义函数和方法</p>
</li>
<li><p><code>return</code> 用于从函数返回</p>
</li>
<li><p><code>defer</code> 用于类似析构函数</p>
</li>
<li><p><code>go</code> 用于并发</p>
</li>
<li><p><code>select</code> 用于选择不同类型的通讯</p>
</li>
<li><p><code>interface</code> 用于定义接口</p>
</li>
<li><p><code>struct</code> 用于定义抽象数据类型</p>
</li>
<li><p><code>break</code>、<code>case</code>、<code>continue</code>、<code>for</code>、<code>fallthrough</code>、<code>else</code>、<code>if</code>、<code>switch</code>、<code>goto</code>、<code>default</code> 用于流程控制</p>
</li>
<li><p><code>chan</code>用于channel通讯</p>
</li>
<li><p><code>type</code>用于声明自定义类型</p>
</li>
<li><p><code>map</code>用于声明map类型数据</p>
</li>
<li><p><code>range</code>用于读取slice、map、channel数据</p>
</li>
</ul>
<h1 id="数据类型的定义"><a href="#数据类型的定义" class="headerlink" title="数据类型的定义"></a>数据类型的定义</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>Go语言里面定义变量有多种方式。</p>
<p>使用<code>var</code>关键字是Go最基本的定义变量方式，与C语言不同的是Go把变量类型放在变量名后面：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个名称为“variableName”，类型为&quot;type&quot;的变量</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>定义多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义三个类型都是“type”的变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>定义变量并初始化值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化“variableName”的变量为“value”值，类型是“type”</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span> = value</span><br></pre></td></tr></table></figure>

<p>同时初始化多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个类型都是&quot;type&quot;的变量,并且分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span>= v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>是不是觉得上面这样的定义有点繁琐？有一种写法可以让它变得简单一点。可以直接忽略类型声明，那么上面的代码变成这样了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">    然后Go会根据其相应值的类型来初始化它们</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>觉得上面的还是有些繁琐，继续简化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">    编译器会根据初始化的值自动推导出相应的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>现在是不是看上去非常简洁了？<code>:=</code>这个符号直接取代了<code>var</code>和<code>type</code>,这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用<code>var</code>方式来定义全局变量。</p>
<p><code>_</code>（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，将值<code>35</code>赋予<code>b</code>，并同时丢弃<code>34</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, b := <span class="number">34</span>, <span class="number">35</span></span><br></pre></td></tr></table></figure>

<p>Go对于已声明但未使用的变量会在编译阶段报错，比如下面的代码就会产生一个错误：声明了<code>i</code>但未使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在Go程序中，常量可定义为数值、布尔值或字符串等类型。</p>
<p>它的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> constantName = value</span><br><span class="line"><span class="comment">//如果需要，也可以明确指定常量的类型：</span></span><br><span class="line"><span class="keyword">const</span> Pi <span class="type">float32</span> = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

<p>下面是一些常量声明的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">10000</span></span><br><span class="line"><span class="keyword">const</span> MaxThread = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;astaxie_&quot;</span></span><br></pre></td></tr></table></figure>

<p>Go 常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)，若指定给<code>float32</code>自动缩短为<code>32bit</code>，指定给<code>float64</code>自动缩短为<code>64bit</code>，详情参考 <code>http://golang.org/ref/spec#Constants</code> (需科学上网)</p>
<h2 id="内置基础类型"><a href="#内置基础类型" class="headerlink" title="内置基础类型"></a>内置基础类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>在Go中，布尔值的类型为<code>bool</code>，值是<code>true</code>或<code>false</code>，默认为<code>false</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> isActive <span class="type">bool</span>  <span class="comment">// 全局变量声明</span></span><br><span class="line"><span class="keyword">var</span> enabled, disabled = <span class="literal">true</span>, <span class="literal">false</span>  <span class="comment">// 忽略类型的声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> available <span class="type">bool</span>  <span class="comment">// 一般声明</span></span><br><span class="line">    valid := <span class="literal">false</span>      <span class="comment">// 简短声明</span></span><br><span class="line">    available = <span class="literal">true</span>    <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>整数类型有无符号和带符号两种。Go同时支持<code>int</code>和<code>uint</code>，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：<code>rune</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>和<code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>。其中<code>rune</code>是<code>int32</code>的别称，<code>byte</code>是<code>uint8</code>的别称。</p>
<p>需要注意的一点是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器报错。</p>
<p>如下的代码会产生错误：invalid operation: a + b (mismatched types int8 and int32)</p>
<p>var a int8</p>
<p>var b int32</p>
<p>c:=a + b</p>
<p>另外，尽管int的长度是32 bit, 但int 与 int32并不可以互用。</p>
<p>浮点数的类型有<code>float32</code>和<code>float64</code>两种（没有<code>float</code>类型），默认是<code>float64</code>。</p>
<p>Go还支持复数。它的默认类型是<code>complex128</code>（64位实数+64位虚数）。如果需要小一些的，也有<code>complex64</code>(32位实数+32位虚数)。复数的形式为<code>RE + IMi</code>，其中<code>RE</code>是实数部分，<code>IM</code>是虚数部分，而最后的<code>i</code>是虚数单位。下面是一个使用复数的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="type">complex64</span> = <span class="number">5</span>+<span class="number">5i</span></span><br><span class="line"><span class="comment">//output: (5+5i)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Value is: %v&quot;</span>, c)</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go中的字符串都是采用<code>UTF-8</code>字符集编码。字符串是用一对双引号（<code>&quot;&quot;</code>）或反引号（<code> </code>）括起来定义，它的类型是<code>string</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> frenchHello <span class="type">string</span>  <span class="comment">// 声明变量为字符串的一般方法</span></span><br><span class="line"><span class="keyword">var</span> emptyString <span class="type">string</span> = <span class="string">&quot;&quot;</span>  <span class="comment">// 声明了一个字符串变量，初始化为空字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    no, yes, maybe := <span class="string">&quot;no&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;maybe&quot;</span>  <span class="comment">// 简短声明，同时声明多个变量</span></span><br><span class="line">    japaneseHello := <span class="string">&quot;Konichiwa&quot;</span>  <span class="comment">// 同上</span></span><br><span class="line">    frenchHello = <span class="string">&quot;Bonjour&quot;</span>  <span class="comment">// 常规赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但如果真的想要修改怎么办呢？下面的代码可以实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">c := []<span class="type">byte</span>(s)  <span class="comment">// 将字符串 s 转换为 []byte 类型</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">s2 := <span class="type">string</span>(c)  <span class="comment">// 再转换回 string 类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s2)</span><br></pre></td></tr></table></figure>

<p>Go中可以使用<code>+</code>操作符来连接两个字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hello,&quot;</span></span><br><span class="line">m := <span class="string">&quot; world&quot;</span></span><br><span class="line">a := s + m</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, a)</span><br></pre></td></tr></table></figure>

<p>修改字符串也可写为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s = <span class="string">&quot;c&quot;</span> + s[<span class="number">1</span>:] <span class="comment">// 字符串虽不能更改，但可进行切片操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure>

<p>如果要声明一个多行的字符串怎么办？可以通过```来声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="string">`hello</span></span><br><span class="line"><span class="string">    world`</span></span><br></pre></td></tr></table></figure>

<p>``` 括起的字符串为<code>Raw</code>字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。例如本例中会输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">    world</span><br></pre></td></tr></table></figure>

<h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><p>Go内置有一个<code>error</code>类型，专门用来处理错误信息，Go的<code>package</code>里面还专门有一个包<code>errors</code>来处理错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;emit macho dwarf: elf header corrupted&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分组声明"><a href="#分组声明" class="headerlink" title="分组声明"></a>分组声明</h2><p>在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明。</p>
<p>例如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;Go_&quot;</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> pi <span class="type">float32</span></span><br><span class="line"><span class="keyword">var</span> prefix <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>可以分组写成如下形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    i = <span class="number">100</span></span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    prefix = <span class="string">&quot;Go_&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">    pi <span class="type">float32</span></span><br><span class="line">    prefix <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="iota枚举"><a href="#iota枚举" class="headerlink" title="iota枚举"></a>iota枚举</h2><p>Go里面有一个关键字<code>iota</code>，这个关键字用来声明<code>enum</code>的时候采用，它默认开始值是0，const中每增加一行加1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    x = <span class="literal">iota</span> <span class="comment">// x == 0</span></span><br><span class="line">    y = <span class="literal">iota</span> <span class="comment">// y == 1</span></span><br><span class="line">    z = <span class="literal">iota</span> <span class="comment">// z == 2</span></span><br><span class="line">    w        <span class="comment">// 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> v = <span class="literal">iota</span> <span class="comment">// 每遇到一个const关键字，iota就会重置，此时v == 0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    h, i, j = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//h=0,i=0,j=0 iota在同一行值相同</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a       = <span class="literal">iota</span> <span class="comment">//a=0</span></span><br><span class="line">    b       = <span class="string">&quot;B&quot;</span></span><br><span class="line">    c       = <span class="literal">iota</span>             <span class="comment">//c=2</span></span><br><span class="line">    d, e, f = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//d=3,e=3,f=3</span></span><br><span class="line">    g       = <span class="literal">iota</span>             <span class="comment">//g = 4</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除非被显式设置为其它值或<code>iota</code>，每个<code>const</code>分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是<code>iota</code>，则它也被设置为<code>iota</code>。</p>
<h2 id="Go程序设计的一些规则"><a href="#Go程序设计的一些规则" class="headerlink" title="Go程序设计的一些规则"></a>Go程序设计的一些规则</h2><p>Go之所以会那么简洁，是因为它有一些默认的行为：</p>
<ul>
<li>大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。</li>
<li>大写字母开头的函数也是一样，相当于<code>class</code>中的带<code>public</code>关键词的公有函数；小写字母开头的就是有<code>private</code>关键词的私有函数。</li>
</ul>
<h2 id="array、slice、map"><a href="#array、slice、map" class="headerlink" title="array、slice、map"></a><code>array</code>、<code>slice</code>、<code>map</code></h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a><code>array</code></h3><p><code>array</code>就是数组，它的定义方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [n]<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>在<code>[n]type</code>中，<code>n</code>表示数组的长度，<code>type</code>表示存储元素的类型。对数组的操作和其它语言类似，都是通过<code>[]</code>来进行读取或赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span>  <span class="comment">// 声明了一个int类型的数组</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">42</span>      <span class="comment">// 数组下标是从0开始的</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">13</span>      <span class="comment">// 赋值操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The first element is %d\n&quot;</span>, arr[<span class="number">0</span>])  <span class="comment">// 获取数据，返回42</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The last element is %d\n&quot;</span>, arr[<span class="number">9</span>]) <span class="comment">//返回未赋值的最后一个元素，默认返回0</span></span><br></pre></td></tr></table></figure>

<p>由于长度也是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的<code>slice</code>类型了。</p>
<p>数组可以使用另一种<code>:=</code>来声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为3的int数组</span></span><br><span class="line">b := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0</span></span><br><span class="line">c := [...]<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度</span></span><br></pre></td></tr></table></figure>

<p>Go支持嵌套数组，即多维数组。比如下面的代码就声明了一个二维数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span></span><br><span class="line">doubleArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="type">int</span>&#123;[<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line"><span class="comment">// 上面的声明可以简化，直接忽略内部的类型</span></span><br><span class="line">easyArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a><code>slice</code></h3><p>在很多应用场景中，数组并不能满足需求。在初始定义数组时，并不知道需要多大的数组，因此就需要“动态数组”。在Go里面这种数据结构叫<code>slice</code></p>
<p><code>slice</code>并不是真正意义上的动态数组，而是一个引用类型。<code>slice</code>总是指向一个底层<code>array</code>，<code>slice</code>的声明也可以像<code>array</code>一样，只是不需要长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 和声明array一样，只是少了长度</span></span><br><span class="line"><span class="keyword">var</span> fslice []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>接下来可以声明一个<code>slice</code>，并初始化数据，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="type">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>slice</code>可以从一个数组或一个已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>array[i:j]</code>来获取，其中<code>i</code>是数组的开始位置，<code>j</code>是结束位置，但不包含<code>array[j]</code>，它的长度是<code>j-i</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个含有10个元素元素类型为byte的数组</span></span><br><span class="line"><span class="keyword">var</span> ar = [<span class="number">10</span>]<span class="type">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个含有byte的slice</span></span><br><span class="line"><span class="keyword">var</span> a, b []<span class="type">byte</span></span><br><span class="line"><span class="comment">// a指向数组的第3个元素开始，并到第五个元素结束，</span></span><br><span class="line">a = ar[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">//现在a含有的元素: ar[2]、ar[3]和ar[4]</span></span><br><span class="line"><span class="comment">// b是数组ar的另一个slice</span></span><br><span class="line">b = ar[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// b的元素是：ar[3]和ar[4]</span></span><br></pre></td></tr></table></figure>

<p>注意<code>slice</code>和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用<code>...</code>自动计算长度，而声明<code>slice</code>时，方括号内没有任何字符。</p>
<h4 id="slice有一些简便的操作"><a href="#slice有一些简便的操作" class="headerlink" title="slice有一些简便的操作"></a><code>slice</code>有一些简便的操作</h4><ul>
<li><p><code>slice</code>的默认开始位置是0，<code>ar[:n]</code>等价于<code>ar[0:n]</code></p>
</li>
<li><p><code>slice</code>的第二个序列默认是数组的长度，<code>ar[n:]</code>等价于<code>ar[n:len(ar)]</code></p>
</li>
<li><p>如果从一个数组里面直接获取<code>slice</code>，可以这样<code>ar[:]</code>，因为默认第一个序列是0，第二个是数组的长度，即等价于<code>ar[0:len(ar)]</code></p>
</li>
</ul>
<p>下面这个例子展示了更多关于<code>slice</code>的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>]<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个slice</span></span><br><span class="line"><span class="keyword">var</span> aSlice, bSlice []<span class="type">byte</span></span><br><span class="line"><span class="comment">// 演示一些简便操作</span></span><br><span class="line">aSlice = array[:<span class="number">3</span>] <span class="comment">// 等价于aSlice = array[0:3] aSlice包含元素: a,b,c</span></span><br><span class="line">aSlice = array[<span class="number">5</span>:] <span class="comment">// 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j</span></span><br><span class="line">aSlice = array[:]  <span class="comment">// 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素</span></span><br><span class="line"><span class="comment">// 从slice中获取slice</span></span><br><span class="line">aSlice = array[<span class="number">3</span>:<span class="number">7</span>]  <span class="comment">// aSlice包含元素: d,e,f,g，len=4，cap=7</span></span><br><span class="line">bSlice = aSlice[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f</span></span><br><span class="line">bSlice = aSlice[:<span class="number">3</span>]  <span class="comment">// bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f</span></span><br><span class="line">bSlice = aSlice[<span class="number">0</span>:<span class="number">5</span>] <span class="comment">// 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h</span></span><br><span class="line">bSlice = aSlice[:]   <span class="comment">// bSlice包含所有aSlice的元素: d,e,f,g</span></span><br></pre></td></tr></table></figure>

<p><code>slice</code>是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的<code>aSlice</code>和<code>bSlice</code>，如果修改了<code>aSlice</code>中元素的值，那么<code>bSlice</code>相对应的值也会改变。</p>
<p>从概念上面来说<code>slice</code>像一个结构体，这个结构体包含了三个元素：</p>
<ul>
<li><p>一个指针，指向数组中<code>slice</code>指定的开始位置</p>
</li>
<li><p>长度，即<code>slice</code>的长度</p>
</li>
<li><p>最大长度，也就是<code>slice</code>开始位置到数组的最后位置的长度</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Array_a := [<span class="number">10</span>]<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line">    Slice_a := Array_a[<span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h4 id="slice有几个有用的内置函数"><a href="#slice有几个有用的内置函数" class="headerlink" title="slice有几个有用的内置函数"></a><code>slice</code>有几个有用的内置函数</h4><ul>
<li><p><code>len</code> 获取<code>slice</code>的长度</p>
</li>
<li><p><code>cap</code> 获取<code>slice</code>的最大容量</p>
</li>
<li><p><code>append</code> 向<code>slice</code>里面追加一个或者多个元素，然后返回一个和<code>slice</code>一样类型的<code>slice</code></p>
</li>
<li><p><code>copy</code> 函数<code>copy</code>从源<code>slice</code>的<code>src</code>中复制元素到目标<code>dst</code>，并且返回复制的元素的个数</p>
</li>
</ul>
<p>注：<code>append</code>函数会改变<code>slice</code>所引用的数组的内容，从而影响到引用同一数组的其它<code>slice</code>。</p>
<p>但当<code>slice</code>中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的<code>slice</code>数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的<code>slice</code>则不受影响。</p>
<p>从Go1.2开始<code>slice</code>支持了三个参数的<code>slice</code>，之前一直采用这种方式在<code>slice</code>或者<code>array</code>基础上来获取一个<code>slice</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">slice := array[<span class="number">2</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>这个例子里面slice的容量是8，新版本里面可以指定这个容量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice = array[<span class="number">2</span>:<span class="number">4</span>:<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>上面这个的容量就是<code>7-2</code>，即5。这样这个产生的新的<code>slice</code>就没办法访问最后的三个元素。</p>
<p>如果<code>slice</code>是这样的形式<code>array[:i:j]</code>，即第一个参数为空，默认值就是0。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span><span class="string">`也就是Python中字典的概念，它的格式为`</span><span class="keyword">map</span>[keyType]valueType</span><br></pre></td></tr></table></figure>

<p>看下面的代码，<code>map</code>的读取和设置也类似<code>slice</code>一样，通过<code>key</code>来操作，只是<code>slice</code>的<code>index</code>只能是｀int｀类型，而<code>map</code>多了很多类型，可以是<code>int</code>，可以是<code>string</code>及所有完全定义了<code>==</code>与<code>!=</code>操作的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化</span></span><br><span class="line"><span class="keyword">var</span> numbers <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 另一种map的声明方式</span></span><br><span class="line">numbers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">numbers[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>  <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">&quot;ten&quot;</span>] = <span class="number">10</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">&quot;three&quot;</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;第三个数字是: &quot;</span>, numbers[<span class="string">&quot;three&quot;</span>]) <span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 打印出来如:第三个数字是: 3</span></span><br></pre></td></tr></table></figure>

<p>这个<code>map</code>就像平常看到的表格一样，左边列是<code>key</code>，右边列是值</p>
<p>使用<code>map</code>过程中需要注意的几点：</p>
<ul>
<li><p><code>map</code>是无序的，每次打印出来的<code>map</code>都会不一样，它不能通过<code>index</code>获取，而必须通过<code>key</code>获取</p>
</li>
<li><p><code>map</code>的长度是不固定的，也就是和<code>slice</code>一样，也是一种引用类型</p>
</li>
<li><p>内置的<code>len</code>函数同样适用于<code>map</code>，返回<code>map</code>拥有的<code>key</code>的数量</p>
</li>
<li><p><code>map</code>的值可以很方便的修改，通过<code>numbers[&quot;one&quot;]=11</code>可以很容易的把key为<code>one</code>的字典值改为<code>11</code></p>
</li>
<li><p><code>map</code>和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</p>
</li>
</ul>
<p><code>map</code>的初始化可以通过<code>key:val</code>的方式初始化值，同时<code>map</code>内置有判断是否存在<code>key</code>的方式</p>
<p>通过<code>delete</code>删除<code>map</code>的元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个字典</span></span><br><span class="line">rating := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float32</span>&#123;<span class="string">&quot;C&quot;</span>:<span class="number">5</span>, <span class="string">&quot;Go&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;Python&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;C++&quot;</span>:<span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true</span></span><br><span class="line">csharpRating, ok := rating[<span class="string">&quot;C#&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;C# is in the map and its rating is &quot;</span>, csharpRating)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;We have no rating associated with C# in the map&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(rating, <span class="string">&quot;C&quot;</span>)  <span class="comment">// 删除key为C的元素</span></span><br></pre></td></tr></table></figure>

<p>上面说过了，<code>map</code>也是一种引用类型，如果两个<code>map</code>同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">m[<span class="string">&quot;Hello&quot;</span>] = <span class="string">&quot;Bonjour&quot;</span></span><br><span class="line">m1 := m</span><br><span class="line">m1[<span class="string">&quot;Hello&quot;</span>] = <span class="string">&quot;Salut&quot;</span>  <span class="comment">// 现在m[&quot;hello&quot;]的值已经是Salut了</span></span><br></pre></td></tr></table></figure>

<h2 id="make、new操作"><a href="#make、new操作" class="headerlink" title="make、new操作"></a><code>make</code>、<code>new</code>操作</h2><p><code>make</code>用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配。<code>new</code>用于各种类型的内存分配。</p>
<p>内建函数<code>new</code>本质上说跟其它语言中的同名函数功能一样：<code>new(T)</code>分配了零值填充的<code>T</code>类型的内存空间，并且返回其地址，即一个<code>*T</code>类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型<code>T</code>的零值。有一点非常重要：</p>
<p><code>new</code>返回指针。</p>
<p>内建函数<code>make(T, args)</code>与<code>new(T)</code>有着不同的功能，make只能创建<code>slice</code>、<code>map</code>和<code>channel</code>，并且返回一个有初始值(非零)的<code>T</code>类型，而不是<code>*T</code>。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个<code>slice</code>，是一个包含指向数据（内部<code>array</code>）的指针、长度和容量的三项描述符；在这些项目被初始化之前，<code>slice</code>为<code>nil</code>。对于<code>slice</code>、<code>map</code>和<code>channel</code>来说，<code>make</code>初始化了内部的数据结构，填充适当的值。</p>
<p><code>make</code>返回初始化后的（非零）值。</p>
<h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。</p>
<p>此处罗列 部分类型 的 “零值”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>     <span class="number">0</span></span><br><span class="line"><span class="type">int8</span>    <span class="number">0</span></span><br><span class="line"><span class="type">int32</span>   <span class="number">0</span></span><br><span class="line"><span class="type">int64</span>   <span class="number">0</span></span><br><span class="line"><span class="type">uint</span>    <span class="number">0x0</span></span><br><span class="line"><span class="type">rune</span>    <span class="number">0</span> <span class="comment">//rune的实际类型是 int32</span></span><br><span class="line"><span class="type">byte</span>    <span class="number">0x0</span> <span class="comment">// byte的实际类型是 uint8</span></span><br><span class="line"><span class="type">float32</span> <span class="number">0</span> <span class="comment">//长度为 4 byte</span></span><br><span class="line"><span class="type">float64</span> <span class="number">0</span> <span class="comment">//长度为 8 byte</span></span><br><span class="line"><span class="type">bool</span>    <span class="literal">false</span></span><br><span class="line"><span class="type">string</span>  <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>Go中流程控制分三大类：条件判断，循环控制和无条件跳转。</p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><code>if</code>也许是各种编程语言中最常见的了，它的语法概括起来就是：如果满足条件就做某事，否则做另一件事。</p>
<p>Go里面<code>if</code>条件判断语句中不需要括号，如下代码所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go的<code>if</code>还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算获取值x,然后根据x返回的大小，判断是否大于10。</span></span><br><span class="line"><span class="keyword">if</span> x := computedValue(); x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个地方如果这样调用就编译出错了，因为x是条件里面的变量</span></span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>

<p>多个条件的时候如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> integer == <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is equal to 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> integer &lt; <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is less than 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is greater than 3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>Go有<code>goto</code>语句——请明智地使用它。用<code>goto</code>跳转到必须在当前函数内定义的标签。例如假设这样一个循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">Here:   <span class="comment">//这行的第一个词，以冒号结束作为标签</span></span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">goto</span> Here   <span class="comment">//跳转到Here去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标签名是大小写敏感的。</p>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Go里面最强大的一个控制逻辑就是<code>for</code>，它既可以用来循环读取数据，又可以当作<code>while</code>来控制逻辑，还能迭代操作。它的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> expression1; expression2; expression3 &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expression1</code>、<code>expression2</code>和<code>expression3</code>都是表达式，其中<code>expression1</code>和<code>expression3</code>是变量声明或者函数调用返回值之类的，<code>expression2</code>是用来条件判断，<code>expression1</code>在循环开始之前调用，<code>expression3</code>在每轮循环结束之时调用。</p>
<p>一个例子比上面讲那么多更有用，看看下面的例子吧：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> index:=<span class="number">0</span>; index &lt; <span class="number">10</span> ; index++ &#123;</span><br><span class="line">        sum += index</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum is equal to &quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：sum is equal to 45</span></span><br></pre></td></tr></table></figure>

<p>有些时候需要进行多个赋值操作，由于Go里面没有<code>,</code>操作符，那么可以使用平行赋值<code>i, j = i+1, j-1</code></p>
<p>有些时候如果忽略<code>expression1</code>和<code>expression3</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>;  &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>;</code>也可以省略，那么就变成如下的代码了，这就是<code>while</code>的功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在循环里面有两个关键操作<code>break</code>和<code>continue</code>   ,<code>break</code>操作是跳出当前循环，<code>continue</code>是跳过本次循环。当嵌套过深的时候，<code>break</code>可以配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index := <span class="number">10</span>; index&gt;<span class="number">0</span>; index-- &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">5</span>&#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 或者continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// break打印出来10、9、8、7、6</span></span><br><span class="line"><span class="comment">// continue打印出来10、9、8、7、6、4、3、2、1</span></span><br></pre></td></tr></table></figure>

<p><code>break</code>和<code>continue</code>还可以跟着标号，用来跳到多重循环中的外层循环</p>
<p><code>for</code>配合<code>range</code>可以用于读取<code>slice</code>和<code>map</code>的数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> <span class="keyword">map</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s key:&quot;</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用<code>_</code>来丢弃不需要的返回值</p>
<p>例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> <span class="keyword">map</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>有些时候需要写很多的<code>if-else</code>来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维护，这个时候<code>switch</code>就能很好的解决这个问题。它的语法如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> sExpr &#123;</span><br><span class="line"><span class="keyword">case</span> expr1:</span><br><span class="line">    some instructions</span><br><span class="line"><span class="keyword">case</span> expr2:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">case</span> expr3:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sExpr</code>和<code>expr1</code>、<code>expr2</code>、<code>expr3</code>的类型必须一致。Go的<code>switch</code>非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；而如果<code>switch</code>没有表达式，它会匹配<code>true</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 1&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 2, 3 or 4&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 10&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;All I know is that i is an integer&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第5行中，把很多值聚合在了一个<code>case</code>里面，同时，Go里面<code>switch</code>默认相当于每个<code>case</code>最后带有<code>break</code>，匹配成功后不会自动向下执行其他case，而是跳出整个<code>switch</code>, 但是可以使用<code>fallthrough</code>强制执行后面的case代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">integer := <span class="number">6</span></span><br><span class="line"><span class="keyword">switch</span> integer &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 4&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 5&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 6&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 7&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 8&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default case&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序将输出</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">The <span class="keyword">integer</span> was &lt;= <span class="number">6</span></span><br><span class="line">The <span class="keyword">integer</span> was &lt;= <span class="number">7</span></span><br><span class="line">The <span class="keyword">integer</span> was &lt;= <span class="number">8</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">case</span></span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>函数是Go里面的核心设计，它通过关键字<code>func</code>来声明，它的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(input1 type1, input2 type2)</span></span> (output1 type1, output2 type2) &#123;</span><br><span class="line">    <span class="comment">//这里是处理逻辑代码</span></span><br><span class="line">    <span class="comment">//返回多个值</span></span><br><span class="line">    <span class="keyword">return</span> value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以看出</p>
<ul>
<li><p>关键字<code>func</code>用来声明一个函数<code>funcName</code></p>
</li>
<li><p>函数可以有一个或者多个参数，每个参数后面带有类型，通过<code>,</code>分隔</p>
</li>
<li><p>函数可以返回多个值</p>
</li>
<li><p>上面返回值声明了两个变量<code>output1</code>和<code>output2</code>，如果不想声明也可以，直接就两个类型</p>
</li>
<li><p>如果只有一个返回值且不声明返回值变量，那么可以省略 包括返回值的括号</p>
</li>
<li><p>如果没有返回值，那么就直接省略最后的返回信息</p>
</li>
<li><p>如果有返回值， 那么必须在函数的外层添加return语句</p>
</li>
</ul>
<p>下面来看一个实际应用函数的例子（用来计算Max值）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 返回a、b中最大值.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    z := <span class="number">5</span></span><br><span class="line">    max_xy := max(x, y) <span class="comment">//调用函数max(x, y)</span></span><br><span class="line">    max_xz := max(x, z) <span class="comment">//调用函数max(x, z)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, y, max_xy)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, z, max_xz)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, y, z, max(y,z)) <span class="comment">// 也可在这直接调用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个里面可以看到<code>max</code>函数有两个参数，它们的类型都是<code>int</code>，那么第一个变量的类型可以省略（即 a,b int,而非 a int, b int)，默认为离它最近的类型，同理多于2个同类型的变量或者返回值。同时注意到它的返回值就是一个类型，这个就是省略写法。</p>
<h2 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h2><p>Go语言比C更先进的特性，其中一点就是函数能够返回多个值。</p>
<p>直接看例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//返回 A+B 和 A*B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    xPLUSy, xTIMESy := SumAndProduct(x, y)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>, x, y, xPLUSy)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d * %d = %d\n&quot;</span>, x, y, xTIMESy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子可以看到直接返回了两个参数，当然也可以命名返回参数的变量，这个例子里面只是用了两个类型，也可以改成如下这样的定义，然后返回的时候不用带上变量名，因为直接在函数里面初始化了。但如果函数是导出的(首字母大写)，官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (add <span class="type">int</span>, Multiplied <span class="type">int</span>) &#123;</span><br><span class="line">    add = A+B</span><br><span class="line">    Multiplied = A*B</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h2><p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(arg ...<span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>arg ...int</code>告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是<code>int</code>。在函数体中，变量<code>arg</code>是一个<code>int</code>的<code>slice</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arg &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;And the number is: %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传值与传指针"><a href="#传值与传指针" class="headerlink" title="传值与传指针"></a>传值与传指针</h2><p>传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。</p>
<p>为了验证上面的说法，来看一个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a = a+<span class="number">1</span> <span class="comment">// 改变了a的值</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="comment">//返回一个新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">    x1 := add1(x)  <span class="comment">//调用add1(x)</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出&quot;x+1 = 4&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出&quot;x = 3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然调用了<code>add1</code>函数，并且在<code>add1</code>中执行<code>a = a+1</code>操作，但是上面例子中<code>x</code>变量的值没有发生变化</p>
<p>理由很简单：因为当调用<code>add1</code>的时候，<code>add1</code>接收的参数其实是<code>x</code>的copy，而不是<code>x</code>本身。</p>
<p>如果真的需要传这个<code>x</code>本身,该怎么办呢？</p>
<p>这就牵扯到了所谓的指针。变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有<code>add1</code>函数知道<code>x</code>变量所在的地址，才能修改<code>x</code>变量的值。所以需要将<code>x</code>所在地址<code>&amp;x</code>传入函数，并将函数的参数的类型由<code>int</code>改为<code>*int</code>，即改为指针类型，才能在函数中修改<code>x</code>变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// 请注意，</span></span><br><span class="line">    *a = *a+<span class="number">1</span> <span class="comment">// 修改了a的值</span></span><br><span class="line">    <span class="keyword">return</span> *a <span class="comment">// 返回新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">    x1 := add1(&amp;x)  <span class="comment">// 调用 add1(&amp;x) 传x的地址</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出 &quot;x+1 = 4&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出 &quot;x = 4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，就达到了修改<code>x</code>的目的。那么到底传指针有什么好处呢？</p>
<ul>
<li><p>传指针使得多个函数能操作同一个对象。</p>
</li>
<li><p>传指针比较轻量级 (8bytes),只是传内存地址，可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当要传递大的结构体的时候，用指针是一个明智的选择。</p>
</li>
<li><p>Go语言中<code>channel</code>，<code>slice</code>，<code>map</code>这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变<code>slice</code>的长度，则仍需要取地址传递指针）</p>
</li>
</ul>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>Go语言中有种不错的设计，即延迟（defer）语句，可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当进行一些打开资源的操作时，遇到错误需要提前返回，在返回前需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，一般写打开一个资源是这样操作的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"><span class="comment">// 做一些工作</span></span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有很多重复的代码，Go的<code>defer</code>有效解决了这个问题。使用它后，不但代码量减少了很多，而且程序变得更优雅。在<code>defer</code>后指定的函数会在函数退出前调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有很多调用<code>defer</code>，那么<code>defer</code>是采用后进先出模式，所以如下代码会输出<code>4 3 2 1 0</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，defer会用在释放数据库连接，关闭文件等需要在函数结束时处理的操作。</p>
<h2 id="函数作为值、类型"><a href="#函数作为值、类型" class="headerlink" title="函数作为值、类型"></a>函数作为值、类型</h2><p>在Go中函数也是一种变量，可以通过<code>type</code>来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> typeName <span class="function"><span class="keyword">func</span><span class="params">(input1 inputType1 , input2 inputType2 [, ...])</span></span> (result1 resultType1 [, ...])</span><br></pre></td></tr></table></figure>

<p>函数作为类型到底有什么好处呢？那就是可以把这个类型的函数当做值来传递，请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> testInt <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">bool</span> <span class="comment">// 声明了一个函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isOdd</span><span class="params">(integer <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEven</span><span class="params">(integer <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明的函数类型在这个地方当做了一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(slice []<span class="type">int</span>, f testInt)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">if</span> f(value) &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slice := []<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice = &quot;</span>, slice)</span><br><span class="line">    odd := filter(slice, isOdd)    <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Odd elements of slice are: &quot;</span>, odd)</span><br><span class="line">    even := filter(slice, isEven)  <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Even elements of slice are: &quot;</span>, even)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数当做值和类型在写一些通用接口的时候非常有用，通过上面例子看到<code>testInt</code>这个类型是一个函数类型，然后两个<code>filter</code>函数的参数和返回值与<code>testInt</code>类型是一样的，但是可以实现很多种的逻辑，这样使得程序变得非常的灵活。</p>
<h2 id="Panic和Recover"><a href="#Panic和Recover" class="headerlink" title="Panic和Recover"></a>Panic和Recover</h2><p>Go没有像Java那样的异常机制，它不能抛出异常，而是使用了<code>panic</code>和<code>recover</code>机制。一定要记住，应当把它作为最后的手段来使用，也就是说，代码中应当没有，或者很少有<code>panic</code>的东西。这是个强大的工具，请明智地使用它。</p>
<p>Panic</p>
<p>是一个内建函数，可以中断原有的控制流程，进入一个<code>panic</code>状态中。当函数<code>F</code>调用<code>panic</code>，函数F的执行被中断，但是<code>F</code>中的延迟函数会正常执行，然后F返回到调用它的地方。在调用的地方，<code>F</code>的行为就像调用了<code>panic</code>。这一过程继续向上，直到发生<code>panic</code>的<code>goroutine</code>中所有调用的函数返回，此时程序退出。<code>panic</code>可以直接调用<code>panic</code>产生。也可以由运行时错误产生，例如访问越界的数组。</p>
<p>Recover</p>
<p>是一个内建的函数，可以让进入<code>panic</code>状态的<code>goroutine</code>恢复过来。<code>recover</code>仅在延迟函数中有效。在正常的执行过程中，调用<code>recover</code>会返回<code>nil</code>，并且没有其它任何效果。如果当前的<code>goroutine</code>陷入<code>panic</code>状态，调用<code>recover</code>可以捕获到<code>panic</code>的输入值，并且恢复正常的执行。</p>
<p>下面这个函数演示了如何在过程中使用<code>panic</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;no value for $USER&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个函数检查作为其参数的函数在执行时是否会产生<code>panic</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">throwsPanic</span><span class="params">(f <span class="keyword">func</span>()</span></span>) (b <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            b = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    f() <span class="comment">//执行函数f，如果f中出现了panic，那么就可以恢复回来</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><code>defer</code>必须在<code>panic</code>语句之前。</p>
<p><code>recover</code>必须配合<code>defer</code>使用。</p>
<h2 id="main函数和init函数"><a href="#main函数和init函数" class="headerlink" title="main函数和init函数"></a><code>main</code>函数和<code>init</code>函数</h2><p>Go里面有两个保留的函数：<code>init</code>函数（能够应用于所有的<code>package</code>）和<code>main</code>函数（只能应用于<code>package main</code>）。这两个函数在定义时不能有任何的参数和返回值。虽然一个<code>package</code>里面可以写任意多个<code>init</code>函数，但这无论是对于可读性还是以后的可维护性来说，强烈建议用户在一个<code>package</code>中每个文件只写一个<code>init</code>函数。</p>
<p>Go程序会自动调用<code>init()</code>和<code>main()</code>，所以不需要在任何地方调用这两个函数。每个<code>package</code>中的<code>init</code>函数都是可选的，但<code>package main</code>就必须包含一个<code>main</code>函数。</p>
<p>程序的初始化和执行都起始于<code>main</code>包。如果<code>main</code>包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到<code>fmt</code>包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行<code>init</code>函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对<code>main</code>包中的包级常量和变量进行初始化，然后执行<code>main</code>包中的<code>init</code>函数（如果存在的话），最后执行<code>main</code>函数。</p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>在写Go代码的时候经常用到import这个命令用来导入包文件，经常看到的方式参考如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>然后代码里面可以通过如下的方式调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上面这个fmt是Go语言的标准库，其实是去<code>GOROOT</code>环境变量指定目录下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块：</p>
<h3 id="1、相对路径"><a href="#1、相对路径" class="headerlink" title="1、相对路径"></a>1、相对路径</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./model&quot;</span> <span class="comment">//当前文件同一目录的model目录，但是不建议这种方式来import</span></span><br></pre></td></tr></table></figure>

<h3 id="2、绝对路径"><a href="#2、绝对路径" class="headerlink" title="2、绝对路径"></a>2、绝对路径</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;shorturl/model&quot;</span> <span class="comment">//加载gopath/src/shorturl/model模块</span></span><br></pre></td></tr></table></figure>

<p>上面展示了一些import常用的几种方式，但是还有一些</p>
<h3 id="特殊的import"><a href="#特殊的import" class="headerlink" title="特殊的import"></a>特殊的import</h3><h4 id="1、点操作"><a href="#1、点操作" class="headerlink" title="1、点操作"></a>1、点操作</h4><p>有时候会看到如下的方式导入包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    . <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个点操作的含义就是这个包导入之后在调用这个包的函数时，可以省略前缀的包名，也就是前面调用的fmt.Println(“hello world”)可以省略的写成<code>Println(&quot;hello world&quot;)</code></p>
<h4 id="2、别名操作"><a href="#2、别名操作" class="headerlink" title="2、别名操作"></a>2、别名操作</h4><p>别名操作顾名思义可以把包命名成另一个用起来容易记忆的名字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">        f <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>别名操作的话调用包函数时前缀变成了前缀，即<code>f.Println(&quot;hello world&quot;)</code></p>
<h4 id="3、-操作"><a href="#3、-操作" class="headerlink" title="3、_操作"></a>3、_操作</h4><p>这个操作经常是让很多人费解的一个操作符，请看下面这个<code>import</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/ziutek/mymysql/godrv&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>_</code>操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的<code>init函数</code>。</p>
<h1 id="struct类型"><a href="#struct类型" class="headerlink" title="struct类型"></a>struct类型</h1><h2 id="struct类型的声明"><a href="#struct类型的声明" class="headerlink" title="struct类型的声明"></a>struct类型的声明</h2><p>Go语言中，也和C或者其他语言一样，可以声明新的类型，作为其它类型的属性或字段的容器。例如，可以创建一个自定义类型<code>person</code>代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型称之<code>struct</code>。如下代码所示:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个<code>struct</code>如此简单，上面的类型包含有两个字段</p>
<ul>
<li>一个<code>string</code>类型的字段name，用来保存用户名称这个属性</li>
<li>一个<code>int</code>类型的字段age，用来保存用户年龄这个属性</li>
</ul>
<p>使用<code>struct</code>看下面的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> P person  <span class="comment">// P现在就是person类型的变量了</span></span><br><span class="line">P.name = <span class="string">&quot;Astaxie&quot;</span>  <span class="comment">// 赋值&quot;Astaxie&quot;给P的name属性.</span></span><br><span class="line">P.age = <span class="number">25</span>  <span class="comment">// 赋值&quot;25&quot;给变量P的age属性</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The person&#x27;s name is %s&quot;</span>, P.name)  <span class="comment">// 访问P的name属性.</span></span><br></pre></td></tr></table></figure>

<p>除了上面这种P的声明使用之外，还有另外几种声明使用方式：</p>
<ol>
<li><p>按照顺序提供初始化值<br><code>P := person&#123;&quot;Tom&quot;, 25&#125;</code></p>
</li>
<li><p>通过<code>field:value</code>的方式初始化，这样可以任意顺序<br><code>P := person&#123;age:24, name:&quot;Tom&quot;&#125;</code></p>
</li>
<li><p>当然也可以通过<code>new</code>函数分配一个指针，此处P的类型为<code>*person</code><br><code>P := new(person)</code></p>
</li>
</ol>
<p>看一个完整的使用<code>struct</code>的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 声明一个新的类型</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较两个人的年龄，返回年龄大的那个人，并且返回年龄差</span></span><br><span class="line"><span class="comment">// struct也是传值的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Older</span><span class="params">(p1, p2 person)</span></span> (person, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> p1.age&gt;p2.age &#123;  <span class="comment">// 比较p1和p2这两个人的年龄</span></span><br><span class="line">        <span class="keyword">return</span> p1, p1.age-p2.age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2, p2.age-p1.age</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tom person</span><br><span class="line">    <span class="comment">// 赋值初始化</span></span><br><span class="line">    tom.name, tom.age = <span class="string">&quot;Tom&quot;</span>, <span class="number">18</span></span><br><span class="line">    <span class="comment">// 两个字段都写清楚的初始化</span></span><br><span class="line">    bob := person&#123;age:<span class="number">25</span>, name:<span class="string">&quot;Bob&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 按照struct定义顺序初始化值</span></span><br><span class="line">    paul := person&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">43</span>&#125;</span><br><span class="line">    tb_Older, tb_diff := Older(tom, bob)</span><br><span class="line">    tp_Older, tp_diff := Older(tom, paul)</span><br><span class="line">    bp_Older, bp_diff := Older(bob, paul)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        tom.name, bob.name, tb_Older.name, tb_diff)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        tom.name, paul.name, tp_Older.name, tp_diff)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        bob.name, paul.name, bp_Older.name, bp_diff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="struct的匿名字段"><a href="#struct的匿名字段" class="headerlink" title="struct的匿名字段"></a><code>struct</code>的匿名字段</h2><p>定义的时候是字段名与其类型一一对应，实际上Go支持只提供类型，而不写字段名的方式，也就是匿名字段，也称为嵌入字段。</p>
<p>当匿名字段是一个<code>struct</code>的时候，那么这个<code>struct</code>所拥有的全部字段都被隐式地引入了当前定义的这个<code>struct</code>。</p>
<p>看一个例子，让上面说的这些更具体化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个学生</span></span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="number">120</span>&#125;, <span class="string">&quot;Computer Science&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His name is &quot;</span>, mark.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is &quot;</span>, mark.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is &quot;</span>, mark.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改对应的备注信息</span></span><br><span class="line">    mark.speciality = <span class="string">&quot;AI&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark changed his speciality&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改他的年龄信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark become old&quot;</span>)</span><br><span class="line">    mark.age = <span class="number">46</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is&quot;</span>, mark.age)</span><br><span class="line">    <span class="comment">// 修改他的体重信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark is not an athlet anymore&quot;</span>)</span><br><span class="line">    mark.weight += <span class="number">60</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is&quot;</span>, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到Student访问属性age和name的时候，就像访问自己所有用的字段一样，匿名字段就是这样，能够实现字段的继承。student还能访问Human这个字段作为字段名。请看下面的代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mark.Human = Human&#123;<span class="string">&quot;Marcus&quot;</span>, <span class="number">55</span>, <span class="number">220</span>&#125;</span><br><span class="line">mark.Human.age -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通过匿名访问和修改字段相当的有用，但是不仅仅是<code>struct</code>字段，所有的内置类型和自定义类型都是可以作为匿名字段的。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Skills []<span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，struct</span></span><br><span class="line">    Skills <span class="comment">// 匿名字段，自定义的类型string slice</span></span><br><span class="line">    <span class="type">int</span>    <span class="comment">// 内置类型作为匿名字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化学生Jane</span></span><br><span class="line">    jane := Student&#123;Human:Human&#123;<span class="string">&quot;Jane&quot;</span>, <span class="number">35</span>, <span class="number">100</span>&#125;, speciality:<span class="string">&quot;Biology&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 现在访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Her name is &quot;</span>, jane.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her age is &quot;</span>, jane.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her weight is &quot;</span>, jane.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her speciality is &quot;</span>, jane.speciality)</span><br><span class="line">    <span class="comment">// 修改他的skill技能字段</span></span><br><span class="line">    jane.Skills = []<span class="type">string</span>&#123;<span class="string">&quot;anatomy&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her skills are &quot;</span>, jane.Skills)</span><br><span class="line">    fmt.Println(<span class="string">&quot;She acquired two new ones &quot;</span>)</span><br><span class="line">    jane.Skills = <span class="built_in">append</span>(jane.Skills, <span class="string">&quot;physics&quot;</span>, <span class="string">&quot;golang&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her skills now are &quot;</span>, jane.Skills)</span><br><span class="line">    <span class="comment">// 修改匿名内置类型字段</span></span><br><span class="line">    jane.<span class="type">int</span> = <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Her preferred number is&quot;</span>, jane.<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面例子看出来<code>struct</code>不仅仅能够将<code>struct</code>作为匿名字段，自定义类型、内置类型都可以作为匿名字段，而且可以在相应的字段上面进行函数操作（如例子中的append）。</p>
<p>这里有一个问题：如果human里面有一个字段叫做phone，而student也有一个字段叫做phone，那么该怎么办呢？</p>
<p>Go里面很简单的解决了这个问题，最外层的优先访问，也就是当通过<code>student.phone</code>访问的时候，是访问student里面的字段，而不是human里面的字段。</p>
<p>这样就允许去重载通过匿名字段继承的一些字段，当然如果想访问重载后对应匿名类型里面的字段，可以通过匿名字段名来访问。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span>  <span class="comment">// Human类型拥有的字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段Human</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">    phone <span class="type">string</span>  <span class="comment">// 雇员的phone字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Employee&#123;Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">34</span>, <span class="string">&quot;777-444-XXXX&quot;</span>&#125;, <span class="string">&quot;Designer&quot;</span>, <span class="string">&quot;333-222&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s work phone is:&quot;</span>, Bob.phone)</span><br><span class="line">    <span class="comment">// 如果要访问Human的phone字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s personal phone is:&quot;</span>, Bob.Human.phone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="method"><a href="#method" class="headerlink" title="method"></a>method</h1><p>函数的另一种形态，带有接收者的函数，称为<code>method</code></p>
<h2 id="method-1"><a href="#method-1" class="headerlink" title="method"></a>method</h2><p>现在假设有这么一个场景，定义了一个struct叫做长方形，现在想要计算他的面积，那么按照一般的思路应该会用下面的方式来实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">(r Rectangle)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, area(r1))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, area(r2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以计算出来长方形的面积，但是area()不是作为Rectangle的方法实现的（类似面向对象里面的方法），而是将Rectangle的对象（如r1,r2）作为参数传入函数计算面积的。</p>
<p>这样实现当然没有问题，但是当需要增加圆形、正方形、五边形甚至其它多边形的时候，想计算他们的面积的时候怎么办？那就只能增加新的函数，但是函数名就必须要跟着换了，变成<code>area_rectangle, area_circle, area_triangle...</code></p>
<p> 椭圆代表函数, 而这些函数并不从属于struct(或者以面向对象的术语来说，并不属于class)，他们是单独存在于struct外围，而非在概念上属于某个struct的。</p>
<p>很显然，这样的实现并不优雅，并且从概念上来说”面积”是”形状”的一个属性，它是属于这个特定的形状的，就像长方形的长和宽一样。</p>
<p>基于上面的原因所以就有了<code>method</code>的概念，<code>method</code>是附属在一个给定的类型上的，他的语法和函数的声明语法几乎一样，只是在<code>func</code>后面增加了一个receiver(也就是method所依从的主体)。</p>
<p>用上面提到的形状的例子来说，method <code>area()</code> 是依赖于某个形状(比如说Rectangle)来发生作用的。Rectangle.area()的发出者是Rectangle， area()是属于Rectangle的方法，而非一个外围函数。</p>
<p>更具体地说，Rectangle存在字段 height 和 width, 同时存在方法area(), 这些字段和方法都属于Rectangle。</p>
<p>用Rob Pike的话来说就是：</p>
<p>“A method is a function with an implicit first argument, called a receiver.”</p>
<p>method的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r ReceiverType)</span></span> funcName(parameters) (results)</span><br></pre></td></tr></table></figure>

<p>下面用最开始的例子用method来实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">    c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">    c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, r1.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, r2.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of c1 is: &quot;</span>, c1.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of c2 is: &quot;</span>, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用method的时候重要注意几点</p>
<ul>
<li><p>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</p>
</li>
<li><p>method里面可以访问接收者的字段</p>
</li>
<li><p>调用method通过<code>.</code>访问，就像struct里面访问字段一样</p>
</li>
</ul>
<p>在上例，method area() 分别属于Rectangle和Circle， 于是他们的 Receiver 就变成了Rectangle 和 Circle, 或者说，这个area()方法 是由 Rectangle/Circle 发出的。</p>
<p>值得说明的一点是，图示中method用虚线标出，意思是<strong>此处方法的Receiver是以值传递，而非引用传递，是的，Receiver还可以是指针, 两者的差别在于, 指针作为Receiver会对实例对象的内容发生操作,而普通类型作为Receiver仅仅是以副本作为操作对象,并不对原实例对象发生操作。</strong></p>
<p>那是不是method只能作用在struct上面呢？当然不是，他可以定义在任何自定义的类型、内置类型、struct等各种类型上面。什么叫自定义类型，自定义类型不就是struct，其实不是这样的，struct只是自定义类型里面一种比较特殊的类型而已，还有其他自定义类型申明，可以通过如下这样的申明来实现。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">typeName </span>typeLiteral</span><br></pre></td></tr></table></figure>

<p>请看下面这个申明自定义类型的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ages <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> money <span class="type">float32</span></span><br><span class="line"><span class="keyword">type</span> months <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m := months &#123;</span><br><span class="line">    <span class="string">&quot;January&quot;</span>:<span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;February&quot;</span>:<span class="number">28</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;December&quot;</span>:<span class="number">31</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以在自己的代码里面定义有意义的类型了，实际上只是一个定义了一个别名,有点类似于c中的typedef，例如上面ages替代了int，回到<code>method</code> 可以在任何的自定义类型中定义任意多的<code>method</code>，接下来让看一个复杂一点的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    WHITE = <span class="literal">iota</span><span class="comment">//0</span></span><br><span class="line">    BLACK<span class="comment">//1</span></span><br><span class="line">    BLUE<span class="comment">//2</span></span><br><span class="line">    RED<span class="comment">//3</span></span><br><span class="line">    YELLOW<span class="comment">//4</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Color <span class="type">byte</span></span><br><span class="line"><span class="keyword">type</span> Box <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height, depth <span class="type">float64</span></span><br><span class="line">    color Color</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> BoxList []Box <span class="comment">//a slice of boxes，以Box为类型的切片类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Box)</span></span> Volume() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.width * b.height * b.depth</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> SetColor(c Color) &#123;</span><br><span class="line">    b.color = c</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span></span> BiggestColor() Color &#123;</span><br><span class="line">    v := <span class="number">0.00</span></span><br><span class="line">    k := Color(WHITE)</span><br><span class="line">    <span class="keyword">for</span> _, b := <span class="keyword">range</span> bl &#123;</span><br><span class="line">        <span class="keyword">if</span> bv := b.Volume(); bv &gt; v &#123;</span><br><span class="line">            v = bv</span><br><span class="line">            k = b.color</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span></span> PaintItBlack() &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> bl &#123;</span><br><span class="line">        bl[i].SetColor(BLACK)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Color)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    strings := []<span class="type">string</span> &#123;<span class="string">&quot;WHITE&quot;</span>, <span class="string">&quot;BLACK&quot;</span>, <span class="string">&quot;BLUE&quot;</span>, <span class="string">&quot;RED&quot;</span>, <span class="string">&quot;YELLOW&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> strings[c]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    boxes := BoxList &#123;</span><br><span class="line">        Box&#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, RED&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, YELLOW&#125;,</span><br><span class="line">        Box&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">20</span>, BLACK&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, BLUE&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">1</span>, WHITE&#125;,</span><br><span class="line">        Box&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, YELLOW&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;We have %d boxes in our set\n&quot;</span>, <span class="built_in">len</span>(boxes))</span><br><span class="line">    fmt.Println(<span class="string">&quot;The volume of the first one is&quot;</span>, boxes[<span class="number">0</span>].Volume(), <span class="string">&quot;cm³&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;The color of the last one is&quot;</span>,boxes[<span class="built_in">len</span>(boxes)<span class="number">-1</span>].color.String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestColor().String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Let&#x27;s paint them all black&quot;</span>)</span><br><span class="line">    boxes.PaintItBlack()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The color of the second one is&quot;</span>, boxes[<span class="number">1</span>].color.String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Obviously, now, the biggest one is&quot;</span>, boxes.BiggestColor().String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码通过const定义了一些常量，然后定义了一些自定义类型</p>
<ul>
<li><p>Color作为byte的别名</p>
</li>
<li><p>定义了一个struct:Box，含有三个长宽高字段和一个颜色属性</p>
</li>
<li><p>定义了一个slice:BoxList，含有Box</p>
</li>
</ul>
<p>然后以上面的自定义类型为接收者定义了一些method</p>
<ul>
<li><p>Volume()定义了接收者为Box，返回Box的容量</p>
</li>
<li><p>SetColor(c Color)，把Box的颜色改为c</p>
</li>
<li><p>BiggestColor()定在在BoxList上面，返回list里面容量最大的颜色</p>
</li>
<li><p>PaintItBlack()把BoxList里面所有Box的颜色全部变成黑色</p>
</li>
<li><p>String()定义在Color上面，返回Color的具体颜色(字符串格式)</p>
</li>
</ul>
<p>上面的代码通过文字描述出来之后是不是很简单？一般解决问题都是通过问题的描述，去写相应的代码实现。</p>
<h2 id="指针作为receiver"><a href="#指针作为receiver" class="headerlink" title="指针作为receiver"></a>指针作为receiver</h2><p>现在让回过头来看看SetColor这个method，它的receiver是一个指向Box的指针，可以使用*Box。</p>
<p><strong>定义SetColor的真正目的是想改变这个Box的颜色，如果不传Box的指针，那么SetColor接受的其实是Box的一个copy，也就是说method内对于颜色值的修改，其实只作用于Box的copy，而不是真正的Box。所以需要传入指针。</strong></p>
<p>这里可以把receiver当作method的第一个参数来看，然后结合前面函数讲解的传值和传引用就不难理解</p>
<p>这里也许会问SetColor函数里面应该这样定义<code>*b.Color=c</code>,而不是<code>b.Color=c</code>,需要读取到指针相应的值。</p>
<p>其实Go里面这两种方式都是正确的，当用指针去访问相应的字段时(虽然指针没有任何的字段)，Go知道要通过指针去获取这个值。PaintItBlack里面调用SetColor的时候是不是应该写成<code>(&amp;bl[i]).SetColor(BLACK)</code>，因为SetColor的receiver是*Box，而不是Box。这两种方式都可以，因为Go知道receiver是指针，他自动转了。</p>
<p>也就是说：</p>
<p>如果一个method的receiver是*T,可以在一个T类型的实例变量V上面调用这个method，而不需要&amp;V去调用这个method</p>
<p>类似的</p>
<p>如果一个method的receiver是T，可以在一个*T类型的变量P上面调用这个method，而不需要 *P去调用这个method</p>
<p>所以不用担心是调用的指针的method还是不是指针的method，Go知道要做的一切，这对于有多年C/C++编程经验的同学来说，真是解决了一个很大的痛苦。</p>
<h2 id="method继承"><a href="#method继承" class="headerlink" title="method继承"></a>method继承</h2><p>通过字段的继承的学习，发现Go的一个神奇之处，method也是可以继承的。如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method。来看下面这个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在human上面定义了一个method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="method重写"><a href="#method重写" class="headerlink" title="method重写"></a>method重写</h2><p>上面的例子中，如果Employee想要实现自己的SayHi,怎么办？简单，和匿名字段冲突一样的道理，可以在Employee上面定义一个method，重写了匿名字段的方法。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这些内容，可以设计出基本的面向对象的程序了，但是Go里面的面向对象是如此的简单，没有任何的私有、公有关键字，通过大小写来实现(<strong>大写开头的为公有，小写开头的为私有</strong>)，方法也同样适用这个原则。</p>
<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><p>Go语言里面设计最精妙的应该算<code>interface</code>，它让面向对象，内容组织实现非常的方便</p>
<h2 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h2><p>简单的说，<code>interface</code>是一组<code>method</code>签名的组合，通过<code>interface</code>来定义对象的一组行为。</p>
<p>前面例子中<code>Student</code>和<code>Employee</code>都能<code>SayHi</code>，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能<code>say hi</code></p>
<p>继续做更多的扩展，<code>Student</code>和<code>Employee</code>实现另一个方法<code>Sing</code>，然后<code>Student</code>实现方法<code>BorrowMoney</code>而<code>Employee</code>实现<code>SpendSalary</code>。</p>
<p>这样<code>Student</code>实现了三个方法：<code>SayHi</code>、<code>Sing</code>、<code>BorrowMoney</code>；而<code>Employee</code>实现了<code>SayHi</code>、<code>Sing</code>、<code>SpendSalary</code>。</p>
<p>上面这些方法的组合称为<code>interface</code>(被对象<code>Student</code>和<code>Employee</code>实现)。例如<code>Student</code>和<code>Employee</code>都实现了<code>interface</code>：<code>SayHi</code>和<code>Sing</code>，也就是这两个对象是该<code>interface</code>类型。而<code>Employee</code>没有实现这个<code>interface：SayHi、Sing</code>和<code>BorrowMoney</code>，因为<code>Employee</code>没有实现<code>BorrowMoney</code>这个方法。</p>
<h2 id="interface类型"><a href="#interface类型" class="headerlink" title="interface类型"></a>interface类型</h2><p><code>interface</code>类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法参考下面这个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human，可以看出此时Employee类也继承了Human类的所有属性及方法</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Human对象实现SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Human对象实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la, la la la, la la la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human对象实现Guzzle方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Guzzle(beerStein <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Guzzle Guzzle Guzzle...&quot;</span>, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Student实现BorrowMoney方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> BorrowMoney(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    s.loan += amount <span class="comment">// (again and again and...)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee重载Human的SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//此句可以分成多行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee实现SpendSalary方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SpendSalary(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    e.money -= amount <span class="comment">// More vodka please!!! Get me through the day!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">    Guzzle(beerStein <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> YoungChap <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    BorrowMoney(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ElderlyGent <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    SpendSalary(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以知道，<strong>interface可以被任意的对象实现</strong>。看到上面的Men interface被Human、Student和Employee实现。同理，<strong>一个对象可以实现任意多个interface</strong>，例如上面的Student实现了Men和YoungChap两个interface。</p>
<p>最后，任意的类型都实现了空interface(这样定义：interface{})，也就是包含0个method的interface。</p>
<h2 id="interface值"><a href="#interface值" class="headerlink" title="interface值"></a>interface值</h2><p>那么interface里面到底能存什么值呢？如果定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值。</p>
<p>因为m能够持有这三种类型的对象，所以可以定义一个包含Men类型元素的slice，这个slice可以被赋予实现了Men接口的任意结构的对象，这个和传统意义上面的slice有所不同。</p>
<p>来看一下下面这个例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human实现SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee重载Human的SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Interface Men被Human,Student和Employee实现</span></span><br><span class="line"><span class="comment">// 因为这三个类型都实现了这两个方法</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mike := Student&#123;Human&#123;<span class="string">&quot;Mike&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-XXX&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>, <span class="number">0.00</span>&#125;</span><br><span class="line">    paul := Student&#123;Human&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">26</span>, <span class="string">&quot;111-222-XXX&quot;</span>&#125;, <span class="string">&quot;Harvard&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">36</span>, <span class="string">&quot;444-222-XXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc.&quot;</span>, <span class="number">1000</span>&#125;</span><br><span class="line">    tom := Employee&#123;Human&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">37</span>, <span class="string">&quot;222-444-XXX&quot;</span>&#125;, <span class="string">&quot;Things Ltd.&quot;</span>, <span class="number">5000</span>&#125;</span><br><span class="line">    <span class="comment">//定义Men类型的变量i</span></span><br><span class="line">    <span class="keyword">var</span> i Men</span><br><span class="line">    <span class="comment">//i能存储Student</span></span><br><span class="line">    i = mike</span><br><span class="line">    fmt.Println(<span class="string">&quot;This is Mike, a Student:&quot;</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">&quot;November rain&quot;</span>)</span><br><span class="line">    <span class="comment">//i也能存储Employee</span></span><br><span class="line">    i = tom</span><br><span class="line">    fmt.Println(<span class="string">&quot;This is tom, an Employee:&quot;</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">&quot;Born to be wild&quot;</span>)</span><br><span class="line">    <span class="comment">//定义了slice Men</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Let&#x27;s use a slice of Men and see what happens&quot;</span>)</span><br><span class="line">    x := <span class="built_in">make</span>([]Men, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">//这三个都是不同类型的元素，但是他们实现了interface同一个接口</span></span><br><span class="line">    x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>] = paul, sam, mike</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> x&#123;</span><br><span class="line">        value.SayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，发现<code>interface</code>就是一组抽象方法的集合，它必须由其他非interface类型实现，而不能自我实现， Go通过interface实现了<code>duck-typing</code>:即”当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”。</p>
<h2 id="空interface"><a href="#空interface" class="headerlink" title="空interface"></a>空interface</h2><p>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义a为空接口</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">s := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">// a可以存储任意类型的数值</span></span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure>

<p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回<code>interface&#123;&#125;</code>,那么也就可以返回任意类型的值。是不是很有用啊！</p>
<h2 id="interface函数参数"><a href="#interface函数参数" class="headerlink" title="interface函数参数"></a>interface函数参数</h2><p>interface的变量可以持有任意实现该interface类型的对象，这给编写函数(包括method)提供了一些额外的思考，是不是可以通过定义interface参数，让函数接受各种类型的参数。</p>
<p>举个例子：fmt.Println是常用的一个函数，是否注意到它可以接受任意类型的数据。打开fmt的源码文件，会看到这样一个定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">     String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，任何实现了String方法的类型都能作为参数被<code>fmt.Println</code>调用,来试一试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过这个方法 Human 实现了 fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;❰&quot;</span>+h.name+<span class="string">&quot; - &quot;</span>+strconv.Itoa(h.age)+<span class="string">&quot; years -  ✆ &quot;</span> +h.phone+<span class="string">&quot;❱&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">39</span>, <span class="string">&quot;000-7777-XXX&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;This Human is : &quot;</span>, Bob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在再回顾一下前面的Box示例，发现Color结构也定义了一个<code>method：String</code>。其实这也是实现了<code>fmt.Stringer</code>这个<code>interface</code>，即如果需要某个类型能被fmt包以特殊的格式输出，就必须实现<code>Stringer</code>这个接口。如果没有实现这个接口，fmt将以默认的方式输出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现同样的功能</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestsColor().String())</span><br><span class="line">fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestsColor())</span><br></pre></td></tr></table></figure>

<p>注：实现了<code>error</code>接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必再定义String()方法了。</p>
<h2 id="interface变量存储的类型"><a href="#interface变量存储的类型" class="headerlink" title="interface变量存储的类型"></a>interface变量存储的类型</h2><p>interface的变量里面可以存储任意类型的数值(该类型实现了interface)。那么怎么反向知道这个变量里面实际保存了的是哪个类型的对象呢？目前常用的有两种方法：</p>
<ul>
<li>Comma-ok断言</li>
</ul>
<p>Go语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok = element.(T)，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。</p>
<p>如果element里面确实存储了T类型的数值，那么ok返回true，否则返回false。</p>
<p>通过一个例子来更加深入的理解。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了String方法，实现了fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">// a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> value, ok := element.(<span class="type">int</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(<span class="type">string</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(Person); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is of a different type\n&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是否注意到了多个if里面，if里面允许初始化变量。断言的类型越多，那么if else也就越多，所以才引出了下面要介绍的switch。</p>
<ul>
<li>switch测试</li>
</ul>
<p>重写上面的这个实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">//an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">//a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list&#123;</span><br><span class="line">        <span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">case</span> Person:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;list[%d] is of a different type&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一点需要强调的是：<code>element.(type)</code>语法不能在switch外的任何逻辑里面使用，如果要在switch外面判断一个类型就使用<code>comma-ok</code>。</p>
<h2 id="嵌入interface"><a href="#嵌入interface" class="headerlink" title="嵌入interface"></a>嵌入interface</h2><p>Go里面真正吸引人的是它内置的逻辑语法，就像在学习Struct时学习的匿名字段，那么相同的逻辑引入到interface里面，更加完美了。如果一个interface1作为interface2的一个嵌入字段，那么interface2隐式的包含了interface1里面的method。</p>
<p>可以看到源码包<code>container/heap</code>里面有这样的一个定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface <span class="comment">//嵌入字段sort.Interface</span></span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">//a Push method to push elements into the heap</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125; <span class="comment">//a Pop elements that pops elements from the heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>sort.Interface</code>其实就是嵌入字段，把<code>sort.Interface</code>的所有<code>method</code>给隐式的包含进来了。也就是下面三个方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    <span class="comment">// Less returns whether the element with index i should sort</span></span><br><span class="line">    <span class="comment">// before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子就是io包下面的 <code>io.ReadWriter</code> ，它包含了io包下面的<code>Reader</code>和<code>Writer</code>两个<code>interface</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.ReadWriter</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Go语言实现了反射，所谓反射就是能检查程序在运行时的状态。一般用到的包是<code>reflect</code>包。如何运用<code>reflect</code>包，官方的这篇文章详细的讲解了<code>reflect</code>包的实现原理，<code>laws of reflection</code> 链接地址为 <a href="http://golang.org/doc/articles/laws_of_reflection.html">http://golang.org/doc/articles/laws_of_reflection.html</a></p>
<p>使用reflect一般分成三步，下面简要的讲解一下：要去反射是一个类型的值(这些值都实现了<code>空interface</code>)，首先需要把它转化成<code>reflect</code>对象(<code>reflect.Type</code>或者<code>reflect.Value</code>，根据不同的情况调用不同的函数)。这两种获取方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := reflect.TypeOf(i)    <span class="comment">//得到类型的元数据,通过t能获取类型定义里面的所有元素</span></span><br><span class="line">v := reflect.ValueOf(i)   <span class="comment">//得到实际的值，通过v获取存储在里面的值，还可以去改变值</span></span><br></pre></td></tr></table></figure>

<p>转化为reflect对象之后就可以进行一些操作了，也就是将reflect对象转化成相应的值，例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tag := t.Elem().Field(<span class="number">0</span>).Tag  <span class="comment">//获取定义在struct里面的标签</span></span><br><span class="line">name := v.Elem().Field(<span class="number">0</span>).String()  <span class="comment">//获取存储在第一个字段里面的值</span></span><br></pre></td></tr></table></figure>

<p>获取反射值能返回相应的类型和数值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;kind is float64:&quot;</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())</span><br></pre></td></tr></table></figure>

<p>最后，反射的话，那么反射的字段必须是可修改的，前面学习过传值和传引用，这个里面也是一样的道理。反射的字段必须是可读写的意思是，如果下面这样写，那么会发生错误</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>

<p>如果要修改相应的值，必须这样写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">v := p.Elem()</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>Go从语言层面支持了并行。</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p><code>goroutine</code>是<code>Go</code>并行设计的核心。<code>goroutine</code>说到底其实就是协程，但是它比线程更小，十几个<code>goroutine</code>可能体现在底层就是五六个线程，Go语言内部实现了这些<code>goroutine</code>之间的内存共享。执行<code>goroutine</code>只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。<code>goroutine</code>比<code>thread</code>更易用、更高效、更轻便。</p>
<p><code>goroutine</code>是通过Go的<code>runtime</code>管理的一个线程管理器。<code>goroutine</code>通过<code>go</code>关键字实现了，其实就是一个普通的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> hello(a, b, c)</span><br></pre></td></tr></table></figure>

<p>通过关键字go就启动了一个<code>goroutine</code>。来看一个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>) <span class="comment">//开一个新的Goroutines执行</span></span><br><span class="line">    say(<span class="string">&quot;hello&quot;</span>) <span class="comment">//当前Goroutines执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上程序执行后将输出：</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>可以看到go关键字很方便的就实现了并发编程。</p>
<p>上面的多个<code>goroutine</code>运行在同一个进程里面，共享内存数据，不过设计上要遵循：<strong>不要通过共享来通信，而要通过通信来共享。</strong></p>
<p><code>runtime.Gosched()</code>表示让CPU把时间片让给别人,下次某个时候继续恢复执行该<code>goroutine</code>。</p>
<p>默认情况下，在Go 1.5将标识并发系统线程个数的<code>runtime.GOMAXPROCS</code>的初始值由1改为了<code>运行环境的CPU核数</code>。</p>
<p>但在Go 1.5以前调度器仅使用单线程，也就是说只实现了并发。想要发挥多核处理器的并行，需要程序中显式调用 <code>runtime.GOMAXPROCS(n)</code> 告诉调度器同时使用多个线程。<code>GOMAXPROCS</code> 设置了同时运行逻辑代码的系统线程的最大数量，并返回之前的设置。如果<code>n &lt; 1</code>，不会改变当前设置。</p>
<h2 id="channels"><a href="#channels" class="headerlink" title="channels"></a>channels</h2><p><code>goroutine</code>运行在相同的地址空间，因此访问共享内存必须做好同步。那么<code>goroutine</code>之间如何进行数据的通信呢，Go提供了一个很好的通信机制<code>channel</code>。<code>channel</code>可以与<code>Unix shell</code> 中的双向管道做类比：可以通过它发送或者接收值。这些值只能是特定的类型：<code>channel类型</code>。定义一个<code>channel</code>时，也需要定义发送到<code>channel</code>的值的类型。注意，必须使用<code>make</code> 创建<code>channel</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ci := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">cf := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p><code>channel</code>通过操作符<code>&lt;-</code>来接收和发送数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 发送v到channel ch.</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从ch中接收数据，并赋值给v</span></span><br></pre></td></tr></table></figure>

<p>把这些应用到例子中来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        total += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- total  <span class="comment">// send total to c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(a[:<span class="built_in">len</span>(a)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(a[<span class="built_in">len</span>(a)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c  <span class="comment">// receive from c</span></span><br><span class="line">    fmt.Println(x, y, x + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>channel</code>接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得<code>Goroutines</code>同步变的更加的简单，而不需要显式的<code>lock</code>。所谓阻塞，也就是如果读取（<code>value := &lt;-ch</code>）它将会被阻塞，直到有数据接收。其次，任何发送（<code>ch&lt;-5</code>）将会被阻塞，直到数据被读出。无缓冲<code>channel</code>是在多个<code>goroutine</code>之间同步很棒的工具。</p>
<h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>上面介绍了默认的非缓存类型的channel，不过Go也允许指定channel的缓冲大小，很简单，就是channel可以存储多少元素。<code>ch:= make(chan bool</code>, 4)，创建了可以存储4个元素的bool 型channel。在这个channel 中，前4个元素可以无阻塞的写入。当写入第5个元素时，代码将会阻塞，直到其他goroutine从channel 中读取一些元素，腾出空间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, value)</span><br></pre></td></tr></table></figure>

<p>当 <code>value = 0</code> 时，channel 是无缓冲阻塞读写的，当<code>value &gt; 0</code> 时，channel 有缓冲、是非阻塞的，直到写满 value 个元素才阻塞写入。</p>
<p>看一下下面这个例子，可以在自己本机测试一下，修改相应的value值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)<span class="comment">//修改2为1就报错，修改2为3可以正常运行</span></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改为1报如下的错误:</span></span><br><span class="line"><span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></table></figure>

<h2 id="Range和Close"><a href="#Range和Close" class="headerlink" title="Range和Close"></a>Range和Close</h2><p>上面这个例子中，需要读取两次c，这样不是很方便，Go考虑到了这一点，所以也可以通过range，像操作slice或者map一样操作缓存类型的channel，请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x + y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for i := range c</code>能够不断的读取<code>channel</code>里面的数据，直到该<code>channel</code>被显式的关闭。上面代码看到可以显式的关闭<code>channel</code>，生产者通过内置函数<code>close</code>关闭<code>channel</code>。关闭<code>channel</code>之后就无法再发送任何数据了，在消费方可以通过语法<code>v, ok := &lt;-ch</code>测试<code>channel</code>是否被关闭。如果ok返回false，那么说明<code>channel</code>已经没有任何数据并且已经被关闭。</p>
<p><strong>记住应该在生产者的地方关闭<code>channel</code>，而不是消费的地方去关闭它，这样容易引起<code>panic</code></strong></p>
<p>另外记住一点的就是<code>channel</code>不像文件之类的，不需要经常去关闭，只有确实没有任何发送数据了，或者想显式的结束<code>range</code>循环之类的</p>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>上面介绍的都是只有一个<code>channel</code>的情况，那么如果存在多个<code>channel</code>的时候，该如何操作呢，Go里面提供了一个关键字<code>select</code>，通过<code>select</code>可以监听<code>channel</code>上的数据流动。</p>
<p><code>select</code>默认是阻塞的，只有当监听的<code>channel</code>中有发送或接收可以进行时才会运行，当多个<code>channel</code>都准备好的时候，<code>select</code>是随机的选择一个执行的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x + y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>select</code>里面还有<code>default</code>语法，<code>select</code>其实就是类似<code>switch</code>的功能，<code>default</code>就是当监听的<code>channel</code>都没有准备好的时候，默认执行的（<code>select</code>不再阻塞等待<code>channel</code>）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// use i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 当c阻塞的时候执行这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>有时候会出现<code>goroutine</code>阻塞的情况，那么如何避免整个程序进入阻塞的情况呢？可以利用<code>select</code>来设置超时，通过如下的方式实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> v := &lt;- c:</span><br><span class="line">                    <span class="built_in">println</span>(v)</span><br><span class="line">                <span class="keyword">case</span> &lt;- time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">                    <span class="built_in">println</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">                    o &lt;- <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="runtime-goroutine"><a href="#runtime-goroutine" class="headerlink" title="runtime goroutine"></a>runtime goroutine</h2><p><code>runtime</code>包中有几个处理<code>goroutine</code>的函数：</p>
<ul>
<li><p><code>Goexit</code> : 退出当前执行的goroutine，但是defer函数还会继续调用</p>
</li>
<li><p><code>Gosched</code>: 让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p>
</li>
<li><p><code>NumCPU</code> : 返回 CPU 核数量</p>
</li>
<li><p><code>NumGoroutine</code>: 返回正在执行和排队的任务总数</p>
</li>
<li><p><code>GOMAXPROCS</code> : 用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p>
</li>
</ul>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Go语言主要的设计准则是：简洁、明白，简洁是指语法和C类似，相当的简单，明白是指任何语句都是很明显的，不含有任何隐含的东西，在错误处理方案的设计中也贯彻了这一思想。</p>
<p>在C语言里面是通过返回<code>-1</code>或者<code>NULL</code>之类的信息来表示错误，但是对于使用者来说，不查看相应的API说明文档，根本搞不清楚这个返回值究竟代表什么意思，比如:返回0是成功，还是失败,而<code>Go</code>定义了一个叫做<code>error</code>的类型，来显式表达错误。在使用时，通过把返回的<code>error</code>变量与<code>nil</code>的比较，来判定操作是否成功。例如<code>os.Open</code>函数在打开文件失败时将返回一个不为<code>nil</code>的<code>error</code>变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>下面这个例子通过调用<code>os.Open</code>打开一个文件，如果出现错误，那么就会调用<code>log.Fatal</code>来输出错误信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">&quot;filename.ext&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于<code>os.Open</code>函数，标准包中所有可能出错的API都会返回一个<code>error</code>变量，以方便错误处理，这个小节将详细地介绍<code>error</code>类型的设计，和讨论开发Web应用中如何更好地处理<code>error</code>。</p>
<h2 id="Error类型"><a href="#Error类型" class="headerlink" title="Error类型"></a>Error类型</h2><p>error类型是一个接口类型，这是它的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>error是一个内置的接口类型，可以在<code>/builtin/</code>包下面找到相应的定义。而在很多内部包里面用到的 <code>error</code>是<code>errors</code>包下面的实现的私有结构<code>errorString</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过<code>errors.New</code>把一个字符串转化为<code>errorString</code>，以得到一个满足接口<code>error</code>的对象，其内部实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个例子演示了如何使用<code>errors.New</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的例子中，在调用Sqrt的时候传递的一个负数，然后就得到了<code>non-nil</code>的<code>error</code>对象，将此对象与<code>nil</code>比较，结果为<code>true</code>，所以<code>fmt.Println</code>(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := Sqrt(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义Error"><a href="#自定义Error" class="headerlink" title="自定义Error"></a>自定义Error</h2><p><code>error</code>是一个<code>interface</code>，所以在实现自己的包的时候，通过定义实现此接口的结构，就可以实现自己的错误定义，请看来自Json包的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyntaxError <span class="keyword">struct</span> &#123;</span><br><span class="line">    msg    <span class="type">string</span> <span class="comment">// 错误描述</span></span><br><span class="line">    Offset <span class="type">int64</span>  <span class="comment">// 错误发生的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *SyntaxError)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> e.msg &#125;</span><br></pre></td></tr></table></figure>

<p><code>Offset</code>字段在调用<code>Error</code>的时候不会被打印，但可以通过类型断言获取错误类型，然后可以打印相应的错误信息，请看下面的例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;val); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> serr, ok := err.(*json.SyntaxError); ok &#123;</span><br><span class="line">        line, col := findLine(f, serr.Offset)</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s:%d:%d: %v&quot;</span>, f.Name(), line, col, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，函数返回自定义错误时，返回值推荐设置为<code>error</code>类型，而非自定义错误类型，特别需要注意的是不应预声明自定义错误类型的变量。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">()</span></span> *SyntaxError &#123; <span class="comment">// 错误，将可能导致上层调用者err!=nil的判断永远为true。</span></span><br><span class="line">    <span class="keyword">var</span> err *SyntaxError     <span class="comment">// 预声明错误变量</span></span><br><span class="line">    <span class="keyword">if</span> 出错条件 &#123;</span><br><span class="line">        err = &amp;SyntaxError&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err               <span class="comment">// 错误，err永远等于非nil，导致上层调用者err!=nil的判断始终为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因见 <code>http://golang.org/doc/faq#nil_error</code> (需科学上网)</p>
<p>上面例子简单的演示了如何自定义Error类型。但是如果还需要更复杂的错误处理呢？此时，来参考一下net包采用的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">error</span></span><br><span class="line">    Timeout() <span class="type">bool</span>   <span class="comment">// Is the error a timeout?</span></span><br><span class="line">    Temporary() <span class="type">bool</span> <span class="comment">// Is the error temporary?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用的地方，通过类型断言<code>err</code>是不是<code>net.Error</code>,来细化错误的处理，例如下面的例子，如果一个网络发生临时性错误，那么将会sleep 1秒之后重试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;</span><br><span class="line">    time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go在错误处理上采用了与C类似的检查返回值的方式，而不是其他多数主流语言采用的异常方式，这造成了代码编写上的一个很大的缺点:错误处理代码的冗余，对于这种情况是通过复用检测函数来减少类似的代码。</p>
<p>请看下面这个例子代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/view&quot;</span>, viewRecord)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中获取数据和模板展示调用时都有检测错误，当有错误发生时，调用了统一的处理函数<code>http.Error</code>，返回给客户端500错误码，并显示相应的错误数据。但是当越来越多的<code>HandleFunc</code>加入之后，这样的错误处理逻辑代码就会越来越多，其实可以通过自定义路由器来缩减代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := fn(w, r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义了自定义的路由器，然后可以通过如下方式来注册函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">&quot;/view&quot;</span>, appHandler(viewRecord))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当请求<code>/view</code>的时候逻辑处理可以变成如下代码，和第一种实现方式相比较已经简单了很多。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> viewTemplate.Execute(w, record)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子错误处理的时候所有的错误返回给用户的都是500错误码，然后打印出来相应的错误代码，其实可以把这个错误信息定义的更加友好，调试的时候也方便定位问题，可以自定义返回的错误类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> appError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Error   <span class="type">error</span></span><br><span class="line">    Message <span class="type">string</span></span><br><span class="line">    Code    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样自定义路由器可以改成如下方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> *appError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> e := fn(w, r); e != <span class="literal">nil</span> &#123; <span class="comment">// e is *appError, not os.Error.</span></span><br><span class="line">        c := appengine.NewContext(r)</span><br><span class="line">        c.Errorf(<span class="string">&quot;%v&quot;</span>, e.Error)</span><br><span class="line">        http.Error(w, e.Message, e.Code)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样修改完自定义错误之后，逻辑处理可以改成如下方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> *appError &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Record not found&quot;</span>, <span class="number">404</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Can&#x27;t display record&quot;</span>, <span class="number">500</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，在访问view的时候可以根据不同的情况获取不同的错误码和错误信息，虽然这个和第一个版本的代码量差不多，但是这个显示的错误更加明显，提示的错误信息更加友好，扩展性也比第一个更好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在程序设计中，容错是相当重要的一部分工作，在Go中它是通过错误处理来实现的，error虽然只是一个接口，但是其变化却可以有很多，可以根据自己的需求来实现不同的处理。</p>
<ul>
<li>err初始化的时候永远都是非nil，自定义的时候一定要注意返回值，不然上层函数调用判断<code>err!=nil</code>的时候永远为true</li>
<li>处理错误的时候，可以通过自定义的方式，减小代码冗余度，类似于Java的抽象出来公共方法，采用AOP的思想，对某一切面进行错误处理。</li>
</ul>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-Index</title>
    <url>/2023/06/19/MySQL-Index/</url>
    <content><![CDATA[<h3 id="索引篇"><a href="#索引篇" class="headerlink" title="索引篇"></a>索引篇</h3><h4 id="为什么Mysql-InnoDB选择B-树作为索引数据结构？"><a href="#为什么Mysql-InnoDB选择B-树作为索引数据结构？" class="headerlink" title="为什么Mysql InnoDB选择B+树作为索引数据结构？"></a>为什么Mysql InnoDB选择B+树作为索引数据结构？</h4><p>1、B+ Tree VS B Tree</p>
<ul>
<li>B+树只有在叶子节点才存储数据，非叶子节点只存储索引，B树的非叶子节点也要存储数据，所以B+树的单个节点的数据量更小，在相同I/O次数下，能查询更多的节点。</li>
<li>B+树是双链表连接，适合MySQL中基于范围的顺序查找，但是B树不行。</li>
</ul>
<p>2、B+ Tree VS 二叉树</p>
<ul>
<li>B+Tree的搜索复杂度是O(logdN)，d表示节点的最大子节点个数，一般大于100，这样可以保证在千万级别的数据量下，B+Tree高度依然保持在3<del>4层左右，即一次数据查询操作一般只需要3</del>4次I/O操作即可查询到目标。</li>
<li>二叉树节点的子节点最多两个，所以搜索复杂度是O(logN)，因此搜索一条数据在二叉树里面的I/O操作次数远高于B+Tree。</li>
</ul>
<p>3、B+Tree vs Hash</p>
<ul>
<li>Hash在进行等值查询的时候效率是O(1)，但是Hash不适合做范围查询。</li>
</ul>
<h4 id="主键索引，唯一索引，普通索引，前缀索引，联合索引"><a href="#主键索引，唯一索引，普通索引，前缀索引，联合索引" class="headerlink" title="主键索引，唯一索引，普通索引，前缀索引，联合索引"></a>主键索引，唯一索引，普通索引，前缀索引，联合索引</h4><ul>
<li><p>主键索引</p>
<ul>
<li>一张表只有一个主键索引</li>
<li>不能为空，NOT NULL</li>
</ul>
</li>
<li><p>唯一索引</p>
<ul>
<li>一张表可以有多个唯一索引，但是索引值必须唯一，允许有空值</li>
</ul>
</li>
<li><p>普通索引</p>
<ul>
<li>不要求是主键，也不要求unique</li>
</ul>
</li>
<li><p>前缀索引</p>
<ul>
<li>针对字符型字段的前几个字符创建索引，可以建立在char、varchar、binary、varbinary的列上。</li>
<li>为了减少索引占用的存储空间，提升查询效率</li>
</ul>
</li>
<li><p>联合索引</p>
<ul>
<li><p> 举例如下：创建商品表的product_no 和 name 字段组成联合索引(product_no,name)，创建联合索引的方式如下:</p>
</li>
<li><p>```Java<br>CREATE INDEX index_product_no_name ON product(product_no,name);</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">B+Tree的示意图如下：</span><br><span class="line"></span><br><span class="line">![<span class="number">1692498640322</span>](https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/<span class="number">1692498640322.</span>jpg)</span><br><span class="line"></span><br><span class="line">联合索引查询数据时，先按照product_no字段比较，在product_no相同的情况下再按<span class="type">name</span>字段比较，也就是说联合索引查询的时候，先将product_no进行排序，再按照product_no相同的情况下将<span class="type">name</span>字段进行排序。</span><br><span class="line"></span><br><span class="line">此时联合索引存在**最左匹配原则，**也就是按照最左优先的方式进行索引匹配，使用联合索引的时候如果不遵循“最左匹配原则”索引此时就会失效。</span><br><span class="line"></span><br><span class="line">上述创建了product_no，<span class="type">name</span>的联合索引即`(product_no,<span class="type">name</span>)`如果是以下的情况即可匹配联合索引:</span><br><span class="line"></span><br><span class="line">- <span class="keyword">where</span> product_no = <span class="number">1</span> <span class="keyword">and</span> <span class="type">name</span> = <span class="string">&#x27;ali&#x27;</span>;</span><br><span class="line">- <span class="keyword">where</span> <span class="type">name</span> = <span class="string">&#x27;bytedance&#x27;</span> <span class="keyword">and</span> product_no = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">因为查询优化器的存在，product_no和<span class="type">name</span>字段在<span class="keyword">where</span>子句中并不重要。</span><br><span class="line"></span><br><span class="line">但是下列例子中，因为不符合最左匹配原则，所以无法匹配以上联合索引，联合索引会失效：</span><br><span class="line"></span><br><span class="line">-  <span class="keyword">where</span> <span class="type">name</span> = <span class="string">&#x27;ali&#x27;</span>;</span><br><span class="line"></span><br><span class="line">以上语句会导致索引失效，因为`(product_no,<span class="type">name</span>)`索引是按照product_no先进行排序，在product_no相同的情况下再按<span class="type">name</span>排序，因此<span class="type">name</span>是**全局无序的，局部相对有序的**，这样在没有遵循最左匹配原则的情况下，无法利用索引。</span><br><span class="line"></span><br><span class="line">  **联合索引****范围查询**</span><br><span class="line"></span><br><span class="line">**查询过程中不一定使用了****联合索引****查询，就代表联合索引中得所有字段都用到了联合索引进行索引查询。**可能是部分索引用到了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>select * from t_table where a &gt; 1 and b = 2</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">因为a &gt; <span class="number">1</span> <span class="keyword">and </span><span class="keyword">b </span>= <span class="number">2</span>无法通过范围查询定位到从哪个具体的索引开始查询（可能会有a = <span class="number">2</span> <span class="keyword">and </span><span class="keyword">b </span>= <span class="number">2</span>，a = <span class="number">3</span> <span class="keyword">and </span><span class="keyword">b </span>= <span class="number">2</span>的情况），此时意味着<span class="keyword">b=2的条件并不能通过索引进一步减少扫描的记录数量，即b字段无法利用联合索引进行查询。</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure>
<p>select * from t_table where a &gt;= 1 and b = 2</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">此时因为a &gt;= <span class="number">1</span> <span class="keyword">and </span><span class="keyword">b </span>= <span class="number">2</span>可以直接定位到具体从哪个索引开始扫描查询（即a = <span class="number">1</span> <span class="keyword">and </span><span class="keyword">b </span>= <span class="number">2</span>），此时<span class="keyword">b </span>= <span class="number">2</span>是相对有序全局无序的（即先按照a字段进行排序，再在a字段相等的情况下按照<span class="keyword">b字段进行排序）。</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure>
<p>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">因为a &gt;= <span class="number">2</span> <span class="keyword">and</span> a &lt;= <span class="number">8</span> <span class="keyword">and</span> b = <span class="number">2</span>可以直接定位到具体从哪个索引开始扫描（即 a = <span class="number">2</span> <span class="keyword">and</span> b = <span class="number">2</span>），此时b = <span class="number">2</span>是在a = <span class="number">2</span>开始排序的前提下，在a相等的情况下再对b进行排序，即b字段是局部有序，全局无序的状态。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">&#x27;j%&#x27;</span> <span class="keyword">and</span> age = <span class="number">22</span></span><br><span class="line"></span><br><span class="line">二级索引先根据<span class="type">name</span>字段进行排序，在<span class="type">name</span>字段相等的前提下，再对age进行排序，此时<span class="type">name</span>前缀为‘j’的二级索引是相邻的</span><br><span class="line"></span><br><span class="line">#### 什么时候需要创建索引？</span><br><span class="line"></span><br><span class="line">- 字段有唯一性限制</span><br><span class="line">- 经常用于`<span class="keyword">WHERE</span>`查询的字段</span><br><span class="line">- 经常用于`<span class="keyword">GROUP</span> <span class="keyword">BY</span>`和`<span class="keyword">ORDER</span> <span class="keyword">BY</span>`字段</span><br><span class="line"></span><br><span class="line">#### 什么时候不需要索引？</span><br><span class="line"></span><br><span class="line">- `<span class="keyword">where</span>` 条件、`<span class="keyword">GROUP</span> <span class="keyword">BY</span>` 、`<span class="keyword">ORDER</span> <span class="keyword">BY</span>` 里面用不到的字段。</span><br><span class="line">- 字段中存在大量重复数据，不需要创建索引，如性别字段，查询优化器发现某个值出现在表的数据行中得百分比很高的时候，就会忽略索引，进行全表扫描。</span><br><span class="line">- 表的数据太少的时候，就不需要创建索引。</span><br><span class="line">- 经常更新的字段不需要创建索引。比如电商的余额</span><br><span class="line"></span><br><span class="line">#### 索引优化的办法？</span><br><span class="line"></span><br><span class="line">- 前缀索引优化</span><br><span class="line"> - <span class="keyword">ORDER</span> <span class="keyword">BY</span>无法使用前缀索引</span><br><span class="line"> - 无法把前缀索引用作覆盖索引</span><br><span class="line">- 覆盖索引优化</span><br><span class="line">- 主键索引最好自增</span><br><span class="line"> - 如果不是自增化，就可能会导致插入的数据，插入到现有数据页中得某个位置，这将不得不移动其他数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，这时候就会产生页分裂，页分裂可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</span><br><span class="line">- 防止索引失效</span><br><span class="line">- 索引最好设置成<span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"> - 会占用物理空间</span><br><span class="line"> - 会导致优化器在做索引选择的时候更加复杂</span><br><span class="line"></span><br><span class="line">#### 索引失效有哪些？</span><br><span class="line"></span><br><span class="line">- 对索引使用左或左右模糊匹配</span><br><span class="line"></span><br><span class="line">因为索引查询的根本目的是为了通过索引能够缩小查询范围，从而提高查询的速率，但是左模糊或左右模糊查询无法直接通过索引直接定位到符合要求的字段而减小查询范围，所以会导致索引失效。</span><br><span class="line"></span><br><span class="line">- 对索引使用函数</span><br><span class="line"> - 因为索引保存的是索引字段的原始值，而不是经过函数计算之后的值，索引无法走索引了。</span><br><span class="line"> - 不过在MySQL8<span class="number">.0</span>之后可以针对函数计算之后的值建立索引，即该索引的值是函数计算后的值，可以通过扫描该索引进行查询数据了。</span><br><span class="line"></span><br><span class="line">- 对索引进行表达式计算</span><br><span class="line"> 因为索引保存的是索引字段的原始值，而不是id+<span class="number">1</span>表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</span><br><span class="line"></span><br><span class="line">- 对索引隐式类型转换</span><br><span class="line"> </span><br><span class="line"> id定义的是<span class="type">int</span>，phone定义的是<span class="type">varchar</span></span><br><span class="line"> </span><br><span class="line"> ```<span class="keyword">sql</span></span><br><span class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id = &quot;1&quot;;//字符串转整数类型</span><br><span class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id = CAST(&quot;1&quot; <span class="keyword">AS</span> signed <span class="type">int</span>);//此时id字段并没有用到<span class="keyword">CAST</span>函数，索引能够走到索引字段。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> phone = <span class="number">1300000001</span>;//整数转字符串</span><br><span class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> CAST(phone <span class="keyword">AS</span> signed <span class="type">int</span>) = <span class="number">1300000001</span>;//此时phone索引字段使用了<span class="keyword">CAST</span>函数，而对索引使用函数会导致索引失效。</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>联合索引非最左匹配</p>
<ul>
<li><p> <code>SELECT * FROM y_table where a = 1 and b = 1 and c = 1;</code></p>
</li>
<li><p> 联合索引查询的时候B+树是先按a的顺序进行排序，然后在a相同的情况下对b进行排序，在b相同的情况下，最后对c进行排序。</p>
</li>
</ul>
</li>
<li><p>WHERE子句中得OR查询</p>
<ul>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-Transaction</title>
    <url>/2023/06/01/MySQL-Transaction/</url>
    <content><![CDATA[<h3 id="事务篇："><a href="#事务篇：" class="headerlink" title="事务篇："></a>事务篇：</h3><h4 id="事务的四大特性："><a href="#事务的四大特性：" class="headerlink" title="事务的四大特性："></a>事务的四大特性：</h4><p>1、原子性：一个事务要么全部完成要么全部不完成，不会结束在中间的某个环节而且事务再执行过程中发生错误，会被回滚到事务开始前的状态。</p>
<p>2、一致性：事务操作前后，数据满足完整性约束，数据库保持一致性状态。</p>
<p>比如：用户A和用户B在银行分别有800和600，总共1400元，用户A给用户B转账200元，分为两步，从A账户扣除200变成600，B账户增加200变成800，而不会出现A账户扣除，B账户没有增加的情况。</p>
<p>3、隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据的时候不会相互干扰，每个事务都有一个数据空间，对其他并发事务是隔离的。</p>
<p>比如：消费者之间的消费不会互相影响。</p>
<p>4、持久性：数据处理结束之后，对数据的修改永久化存储，即便系统故障也不会丢失</p>
<h4 id="并行事务引起的问题"><a href="#并行事务引起的问题" class="headerlink" title="并行事务引起的问题"></a>并行事务引起的问题</h4><ul>
<li><p>脏读</p>
<ul>
<li><p> 如果一个事务读到了另外一个事务未提交的修改过的数据，就是脏读。</p>
</li>
<li><p> 比如：事务A和事务B同时在处理，事务A对余额进行修改但是还没有提交，事务B此时读取数据，读到了事务A还没有提交的修改后的余额数据，此时就是出现了脏读，<strong>如果事务A此时因为某种原因触发回滚，导致余额回滚成初始值，那么事务B实际上获取到的就是过期的数据。</strong></p>
</li>
</ul>
</li>
<li><p>不可重复读</p>
<ul>
<li><p> 在一个事务中，多次读取同一个数据，结果出现前后两次数据不一样的情况，就是发生了不可重复读。</p>
</li>
<li><p> 比如：事务A和事务B在同时处理同一个数据，事务A先读取了一次这个数据，然后事务B修改了这个数据并提交，事务A再读取此数据，发现两次读取的数据不一样，就出现了不可重复度的情况。</p>
</li>
</ul>
</li>
<li><p>幻读</p>
<ul>
<li><p> 在一个事务中，多次查询符合某个条件的记录数量，出现前后两次记录数量不一致的情况就意味着发生了幻读。</p>
</li>
<li><p> 比如：事务A和事务B同时在处理，事务A先查询了大于100w的记录，然后事务B插入了一条200w的记录，并提交，此时事务A再次查询大于100w的记录，发现记录数量多了一条就发生了幻读。</p>
</li>
</ul>
</li>
</ul>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul>
<li>读未提交：一个事务还没有提交，他所做的变更就能被其他事务看到</li>
<li>读并提交：一个事务所做的变更在提交之后才能被其他事务看到</li>
<li>可重复读：一个事务执行过程中所看到的数据，一直跟这个事务启动时看到的数据一致</li>
<li>串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作的时候，如果发生了读写冲突，后访问的事务必须等前一个事务执行完成才会继续执行。</li>
</ul>
<h4 id="四种隔离级别具体是如何实现的呢？"><a href="#四种隔离级别具体是如何实现的呢？" class="headerlink" title="四种隔离级别具体是如何实现的呢？"></a>四种隔离级别具体是如何实现的呢？</h4><ul>
<li>读未提交：直接读取最新的数据即可。</li>
<li>串行化：添加读写锁避免并行访问</li>
<li>读提交：每次执行语句前都会重新生成一个ReadView。</li>
<li>可重复读：启动事务的时候创建一个ReadView，在这个事务内的多个语句操作都只会使用刚开始事务创建的那个Read View</li>
</ul>
<h4 id="Read-View在MVCC如何工作的？"><a href="#Read-View在MVCC如何工作的？" class="headerlink" title="Read View在MVCC如何工作的？"></a>Read View在MVCC如何工作的？</h4><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/8bf869f9f469ae4cccf625e3b6149a7.png" alt="8bf869f9f469ae4cccf625e3b6149a7"></p>
<p>聚簇索引记录中还有两个隐藏列，如下：</p>
<ul>
<li>trx_id，当一个事务对某条聚簇索引记录<strong>进行改动</strong>时，就会把<strong>该事务的事务 id 记录在 trx_id 隐藏列</strong>里。s</li>
<li>roll_pointer，每次对某条聚簇索引记录<strong>进行改动</strong>时，都会把旧版本的记录写入到 undo 日志中，然后这个<strong>隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li>
</ul>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/b9c22a2e97d0cf6b03142f28edef0d0.png" alt="b9c22a2e97d0cf6b03142f28edef0d0"></p>
<p>大概流程：当你访问一条记录时，数据库会根据该记录的事务 ID（trx_id）和你的 Read View 来确定你是否能看到这个记录。</p>
<ol>
<li><p>如果记录的 trx_id 小于 Read View 的 min_trx_id 值，说明这个记录在当前 Read View 创建之前就已经被提交，因此对当前事务可见。</p>
</li>
<li><p>如果记录的 trx_id 大于等于 Read View 的 max_trx_id 值，说明这个记录在当前 Read View 创建之后才被提交，因此对当前事务不可见。</p>
</li>
<li><p>如果记录的 trx_id 在 Read View 的 min_trx_id 和 max_trx_id 之间，那么需要检查这个 trx_id 是否在 Read View 的 m_ids 列表中：</p>
<p>a. 如果在 m_ids 列表中，说明这个事务是活跃的（还未提交），因此该记录对当前事务不可见。</p>
<p>b. 如果不在 m_ids 列表中，说明这个事务已经提交，因此该记录对当前事务可见。</p>
</li>
</ol>
<h4 id="在可重复读的情况下，可能会发生幻读的场景"><a href="#在可重复读的情况下，可能会发生幻读的场景" class="headerlink" title="在可重复读的情况下，可能会发生幻读的场景"></a>在可重复读的情况下，可能会发生幻读的场景</h4><p>场景一：</p>
<p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录。</p>
<p>这里解释一下：<strong>实际上当事务A对id=5的记录进行更新操作之后再次查询id=5的记录的时候，此时已经变成了当前读，而不是快照读了，所以对于事务A的MVCC机制也失效。</strong></p>
<p>场景二：</p>
<ul>
<li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li>
<li>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</li>
<li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-summaryOne</title>
    <url>/2023/12/18/MySQL-summaryOne/</url>
    <content><![CDATA[<h2 id="一条SQL查询语句的执行流程"><a href="#一条SQL查询语句的执行流程" class="headerlink" title="一条SQL查询语句的执行流程"></a>一条SQL查询语句的执行流程</h2><p>我们先看一下，MySQL的基本示意图，并逐个解析每个部件的作用。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20231218161453022.png" alt="摘自《MySQL45》，如有侵权可以联系本文作者删除"></p>
<h3 id="Server层"><a href="#Server层" class="headerlink" title="Server层"></a>Server层</h3><p>主要包含：连接器，查询缓存，分析器，优化器，执行器</p>
<blockquote>
<p>这里提一嘴，查询缓存到MySQL8.0版本开始就被干掉了，具体原因往下看。</p>
</blockquote>
<h4 id="连接器："><a href="#连接器：" class="headerlink" title="连接器："></a>连接器：</h4><p>负责客户端和MySQL建立连接，获取权限，维持和管理连接，一般通过<code>mysql -h*  -P*  -u* -p</code>经过TCP三次握手协议之后，来连接上MySQL</p>
<ul>
<li>如果用户账号密码不对，就会收到一个<code>Access denied for user</code>的错误，然后客户端结束执行。</li>
<li>如果用户账号密码正确，连接器就会在权限表中查出登录用户的权限，之后用户的所有相关操作都将依赖于刚刚所查询到的连接对应的权限。（如果管理员此时修改了你的权限，也不会影响到你现在的操作，除非重新登录创建连接）</li>
</ul>
<p>当一个连接长时间处于<code>sleep</code>状态的时候，默认（wait_timeout参数）8小时之后就会自动断开，连接又分为短连接和长连接，如果所有连接都是长连接，可能会导致内存占用太大，从而系统自动把长连接给OOM，一般表现就是MySQL的异常重启了。</p>
<blockquote>
<p>原因分析：长连接会导致内存占用变大，MySQL在执行过程中临时使用的内存是管理在连接对象里面的，只有当这个连接断开的时候才会释放，所以都使用长连接会导致内存占用不断地变大，最终导致内存OOM，进而导致MySQL重启</p>
</blockquote>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>连接建立完成，就可以根据select语句查询缓存，之前是否执行过这条语句，之前执行过的语句以及结果都是以key-value的形式直接缓存到内存中（<strong>到这里，希望读者和我一起想想这样可能会导致什么问题？结合前面提到的MySQL后面摒弃了查询缓存。</strong>），如果执行过，直接从缓存里面返回结果即可。</p>
<p><strong>查询缓存其实往往弊大于利，原因如下：</strong></p>
<ul>
<li>查询缓存很容易失效，只要对一张表更新（比如更新某个字段属性），那么这个表上的所有缓存就会清空，所以会出现还没有二次使用就会被清空的情况。（除非你有一个很久都不会更新的静态表，比如系统配置表，那么适合查询缓存，但是平常的业务表，多少都带点经常更新的操作）。</li>
</ul>
<p>如果要通过缓存查询，可以进行显式的语句查询，比如：<code>select SQL_CACHE * from Table where user_id = 10;</code>，而且MySQL提供了参数<code>query_cache_type</code>使得用户能自主控制是否使用查询缓存的操作。</p>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>如果没有命中缓存，就意味着开始真正执行语句了。</p>
<p>首先MySQL会进行“词法分析”，也就是MySQL会根据执行语句里面的字符串、空格等符号识别出分别代表什么。比如：<code>select</code>代表这是一个查询语句，<code>where</code>代表需要根据这个关键词后面的条件去查询，字符串<code>user_id</code>代表是这张表的字段。</p>
<p>然后就是进行“语法分析”，MySQL会根据输入的语句判断这条语句是否符合语法，不符合就会返回一个“You have an error in your SQL syntax”的错误提示，比如<code>elect * from user where user_id = 1;</code>这条语句，就是经典的语法错误，因为它的<code>select</code>写错了</p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>在开始执行前，MySQL还会对你的语句进行优化，确定这条语句走什么索引，或者连表查询的时候确定表的连接顺序，简而言之就是决定选择使用哪一套方案，当优化器阶段结束之后，那么这个语句的具体执行方案也就确定下来。</p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>通过优化器的优化之后，进入执行器阶段，开始执行语句，这个时候会判断一下你有没有对目标表的执行权限，如果没有就会返回错误。</p>
<p>如果有权限就打开表执行，打开表的时候就会根据表的引擎定义，去使用这个引擎提供的接口对存储引擎进行相关操作。</p>
<p>比如一个查询语句<code>select * from user where user_id = 25;</code>user_id`没有建立索引，执行流程如下：</p>
<ol>
<li>调用InnoDB引擎（没有特指的话，MySQL默认使用InnoDB）接口取这个表的第一行，判断这行记录的<code>user_id</code>是不是25，如果不是那么就跳过，如果是就保存在结果集中</li>
<li>调用引擎接口取下一行，重复执行上述操作，直到取到这个表的最后一行</li>
<li>执行器将上述遍历过程中满足条件的结果集，写入内存并返回给客户端。</li>
</ol>
<p>到此为止，一个查询语句的流程就走完了。<strong>一般情况下</strong>在慢查询日志中的<code>rows_examined</code>字段记录的是这个执行语句扫描了多少行，当然有些场景下，引擎扫描次数跟<code>rows_examined</code>并不是完全相同的。</p>
<h3 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h3><p>主要用来存储和提取数据，但是其架构模式是插件式，所以支持多种存储引擎，比如InnoDB、MyISAM等</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>查询缓存在MySQL8.0被干掉了</li>
<li>一条查询语句执行流程分为两种<ul>
<li>客户端 - 连接器 - 查询缓存（缓存命中） - 返回结果</li>
<li>客户端 - 连接器 - 查询缓存（缓存未命中） - 分析器 - 优化器 - 执行器 - 返回结果</li>
</ul>
</li>
<li>连接器：客户端和MySQL连接，用户权限校验</li>
<li>查询缓存：当前的查询语句是否前面缓存过，如果缓存过，直接从缓存中拿结果返回，否则继续往下执行</li>
<li>分析器：进行词法和语法分析</li>
<li>优化器：确定执行器应该执行哪套优化后的方案</li>
<li>执行器：根据优化后的方案，调用对应引擎的接口，获取结果集并最终返回结果</li>
</ul>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ul>
<li>优化器真的会每次都选最优的方案吗？如果不是，那么具体的确定方案流程是怎么样的呢？（比如索引确定，索引错选等）</li>
<li>如果执行<code>select * from user where user_id = 20</code>报错<code>Unknown column user_id in where clause</code>在哪个阶段报出来的错误？</li>
</ul>
<blockquote>
<p>以上问题，会在后续的文章中一一解决回答，因为我也还在慢慢学习。</p>
<p>这些只是我临时思考的问题。如有侵权或文章内容错误，请各位大佬，私信或者联系邮箱<a href="mailto:&#120;&#x69;&#x61;&#x6f;&#98;&#x61;&#122;&#101;&#x6f;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;">&#120;&#x69;&#x61;&#x6f;&#98;&#x61;&#122;&#101;&#x6f;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#109;</a>帮忙纠正。</p>
</blockquote>
<hr>
<p>你好，我是小八，一个分享日常学习知识总结的在校大学生。</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-Server</title>
    <url>/2023/09/14/Netty-Server/</url>
    <content><![CDATA[<h2 id="Netty服务端初始化"><a href="#Netty服务端初始化" class="headerlink" title="Netty服务端初始化"></a>Netty服务端初始化</h2><p>一般需要两个线程组，一个是用来管理接受新线程的线程组(Boss)，一个是处理每条连接的读写数据的线程组(Worker)，可以理解成老板出去接活，员工干细活。所以服务端的创建关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();<span class="comment">//接受管理新的连接</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();<span class="comment">//处理每条连接的数据读写</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();<span class="comment">//引导类进行服务端的启动操作。</span></span><br><span class="line">        serverBootstrap</span><br><span class="line">                .group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)<span class="comment">//指定IO模型，也可以指定BIO等其他IO模型（OioServerSocketChannel.class）</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<span class="comment">//childHandler()主要是用来处理每个新连接的数据读写的业务逻辑</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        serverBootstrap.bind(<span class="number">8000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h4 id="handler-方法和childHandler"><a href="#handler-方法和childHandler" class="headerlink" title="handler()方法和childHandler()"></a>handler()方法和childHandler()</h4><ul>
<li>handler()一般是对服务端启动过程中的一些业务逻辑处理</li>
<li>childHandler()一般是处理新连接的数据的读写逻辑处理</li>
</ul>
<h4 id="attr-方法和childAttr-方法"><a href="#attr-方法和childAttr-方法" class="headerlink" title="attr()方法和childAttr()方法"></a>attr()方法和childAttr()方法</h4><ul>
<li>attr()方法可以给服务端的channel自定义属性，实际上就是通过一个map维护不同的channel</li>
<li>childAttr()可以给每一条连接指定自定义属性，后续我们可以通过<code>channel.attr()</code>取出该属性。</li>
</ul>
<p>应用场景：</p>
<ul>
<li><strong>认证状态跟踪</strong>：您可以使用<code>childAttr()</code>来存储每个客户端连接的身份认证状态，以确保只有经过认证的客户端可以访问服务器资源。</li>
<li><strong>客户端会话信息</strong>：如果您的服务器需要跟踪每个客户端的会话信息，您可以使用<code>childAttr()</code>来存储会话数据，以便在处理客户端请求时访问它们。</li>
<li><strong>全局配置</strong>：<code>attr()</code>方法可用于存储服务器级别的全局配置，例如监听端口号或服务器的标识。</li>
<li><strong>连接统计</strong>：您可以使用<code>attr()</code>和<code>childAttr()</code>来记录连接的统计信息，例如连接的数量、连接的类型等。</li>
</ul>
<h4 id="childOption-方法和option-方法"><a href="#childOption-方法和option-方法" class="headerlink" title="childOption()方法和option()方法"></a>childOption()方法和option()方法</h4><ul>
<li><p><code>childOption()</code>可以给每条连接设置一些TCP底层相关的属性，比如上面，我们设置了两种TCP属性，其中</p>
<ul>
<li><code>ChannelOption.SO_KEEPALIVE</code>表示是否开启TCP底层心跳机制，true为开启</li>
<li><code>ChannelOption.TCP_NODELAY</code>表示是否开启Nagle算法，true表示关闭，false表示开启，通俗地说，如果要求高实时性，有数据发送时就马上发送，就关闭，如果需要减少发送次数减少网络交互，就开启。</li>
</ul>
</li>
<li><p><code>option()</code>方法可以给服务端channel设置一些属性，最常见的就是so_backlog，如下设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br></pre></td></tr></table></figure>

<p>表示系统用于临时存放已完成三次握手的请求的队列的最大长度，如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</p>
</li>
</ul>
<h4 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind()方法"></a>bind()方法</h4><ul>
<li>是一个异步方法，返回一个<code>ChannelFuture</code>可以通过给<code>ChannelFuture</code>添加一监听器<code>GenericFutureListener</code>监听端口,在这个监听器的<code>operationComplete</code>方法里面监听绑定是否成功。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.bind(<span class="number">8000</span>).addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Void&gt; future)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;端口绑定成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;端口绑定失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>先创建引导类，指定线程模型，IO模型，连接读写处理逻辑，绑定端口即可启动服务端。</li>
<li>可以给channel设置一些属性值，设置底层TCP参数</li>
</ul>
]]></content>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-Client</title>
    <url>/2023/09/14/Netty-Client/</url>
    <content><![CDATA[<h2 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h2><p>创建引导类，确认线程模型，IO模型，以及业务处理逻辑。</p>
<p><strong>客户端只需要一个线程模型即可</strong>，毕竟不是服务端不需要一个统一的线程模型去管理很多连接，客户端只需要一个线程模型主动去连接服务端就行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        bootstrap</span><br><span class="line">                <span class="comment">// 1.指定线程模型</span></span><br><span class="line">                .group(workerGroup)</span><br><span class="line">                <span class="comment">// 2.指定 IO 类型为 NIO</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">// 3.IO 处理逻辑</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 4.建立连接</span></span><br><span class="line">        bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).addListener(future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;连接失败!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>connect</code> 方法返回的是一个 <code>Future</code>，也就是说这个方是异步的，我们通过 <code>addListener</code> 方法可以监听到连接是否成功。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h4 id="attr-方法"><a href="#attr-方法" class="headerlink" title="attr()方法"></a>attr()方法</h4><ul>
<li>给客户端的Channel绑定自定义属性，通过channel.attr()取出属性，</li>
</ul>
]]></content>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-AOP</title>
    <url>/2023/08/20/Spring-AOP/</url>
    <content><![CDATA[<p>​    AOP（面向切面编程）：就是把公共逻辑抽出来，让开发者更好的专注于业务逻辑的开发，AOP是<a href>OOP</a>的补充，OOP是面向类和对象的，但是AOP是面向不同切面的，一个切面可以横跨多个类和对象去操作，极大提高开发效率。</p>
<p>​    例如一个订单的创建，可能需要下列四个步骤</p>
<p>​    1、权限校验</p>
<p>​    2、事务管理</p>
<p>​    3、创建订单</p>
<p>​    4、日志打印</p>
<p>​    如果使用AOP的思想，其实就可以把四个步骤抽象成四个切面，让开发者专注于第3个切面，其他的切面都用基础通用的逻辑（就是抽象出来的公共逻辑），统计交给AOP封装管理。</p>
<h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><p><strong>通过代理模式实现</strong>，实现方式有两种，一种事基于Java原生的动态代理，一种是基于cglib的动态代理。</p>
<p>Spring AOP默认使用JDK的原生代理，可以代理任何接口，但是不能代理没有接口的类，所以使用cglib来实现动态代理没有接口的类。</p>
<h3 id="AOP的业务场景："><a href="#AOP的业务场景：" class="headerlink" title="AOP的业务场景："></a>AOP的业务场景：</h3><p>1、参数校验</p>
<p>当使用AOP思想实现参数校验功能时，你可以创建一个AOP切面来拦截需要校验的方法，并从<code>HttpServletRequest</code>中获取JWT参数进行校验。以下是一个基本示例：</p>
<ul>
<li><strong>创建自定义注解：</strong> 创建一个自定义注解，用于标记需要进行JWT校验的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ValidateJWT &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>编写AOP切面：</strong> 创建一个AOP切面，用于拦截带有<code>@ValidateJWT</code>注解的方法，并从<code>HttpServletRequest</code>中获取JWT参数进行校验。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTValidationAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换为你的JWT密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="string">&quot;your-secret-key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;@annotation(com.example.ValidateJWT)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validateJWT</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> extractTokenFromRequest(request);</span><br><span class="line">        <span class="keyword">if</span> (jwtToken == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;JWT token is missing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwtToken).getBody();</span><br><span class="line">            <span class="comment">// 在这里可以根据需要进一步处理claims，比如判断过期时间、验证issuer等</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid JWT token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">extractTokenFromRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorizationHeader</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (authorizationHeader != <span class="literal">null</span> &amp;&amp; authorizationHeader.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> authorizationHeader.substring(<span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了<code>@Autowired</code>来注入<code>HttpServletRequest</code>，然后在AOP切面中使用<code>extractTokenFromRequest</code>方法从请求头中提取JWT token。然后，我们在校验逻辑中解析JWT token，并根据需要处理JWT的内容。这个切面会在带有<code>@ValidateJWT</code>注解的方法执行前进行JWT校验。</p>
<ul>
<li><strong>在需要校验的方法上添加注解：</strong> 在需要校验JWT的方法上添加<code>@ValidateJWT</code>注解。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YourService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ValidateJWT</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里处理请求，前置通知会在此方法执行前进行JWT校验</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>processRequest</code>方法会在执行前进行JWT校验，确保JWT的有效性。同时，你可以将类似的校验逻辑应用于其他带有JWT的方法，以提高代码的安全性和可维护性。请注意，实际项目中可能需要根据业务需求进行更复杂的校验逻辑。</p>
<p>2、缓存逻辑</p>
<p>当使用AOP思想来实现Redis的缓存逻辑时，你可以按照以下步骤来操作：</p>
<ol>
<li><p><strong>引入依赖：</strong> 在你的项目中引入Spring Data Redis依赖，确保你能够使用Redis作为缓存。</p>
</li>
<li><p><strong>创建缓存切面：</strong> 创建一个AOP切面，用于拦截带有<code>@CacheableResult</code>注解的方法，并将方法的返回值缓存到Redis。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;@annotation(com.example.CacheableResult)&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cacheMethodResult</span><span class="params">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().toShortString();</span><br><span class="line">        redisTemplate.opsForValue().set(methodName, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个切面中，我们使用了<code>@Autowired</code>注入了<code>RedisTemplate</code>，这是Spring提供的与Redis交互的工具类。<code>cacheMethodResult</code>方法会在带有<code>@CacheableResult</code>注解的方法执行后执行，将方法返回的结果存储到Redis缓存中，使用方法的名称作为缓存的键。</p>
<ol start="3">
<li><strong>创建自定义注解：</strong> 创建一个自定义注解，用于标记需要进行缓存的方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheableResult &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>在需要缓存的方法上添加注解：</strong> 在需要进行缓存的方法上添加<code>@CacheableResult</code>注解。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YourService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheableResult</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFromDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以模拟从数据库中获取数据的操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Data from database&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>getFromDatabase</code>方法被<code>@CacheableResult</code>注解标记，当这个方法被调用并返回结果时，切面会拦截这个方法的执行，将返回的数据存储到Redis缓存中。</p>
<ol start="5">
<li><strong>启用AOP和组件扫描：</strong> 在Spring Boot的配置类上添加<code>@EnableAspectJAutoProxy</code>注解，以启用AOP功能，同时确保你的切面和服务类被正确地扫描到。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 配置其他内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，你就可以使用AOP思想实现基本的Redis缓存逻辑。当使用带有<code>@CacheableResult</code>注解的方法时，切面会自动将方法的结果存储到Redis缓存中。在实际项目中，你可能还需要考虑缓存的失效策略、数据更新时的缓存更新等细节。同时，Spring框架也提供了更丰富的缓存管理功能，你可以根据具体的需求进行选择和配置。</p>
<p>3、日志打印</p>
<p>实际上在日志打印的场景中，不一定需要创建自定义注解。通常情况下，日志打印是一种通用的操作，因此你可以直接在切面中定义切点，而不必引入自定义注解。</p>
<p>以下是一个更准确的示例，展示如何使用AOP来实现日志打印功能：</p>
<ol>
<li><strong>创建日志切面：</strong> 创建一个AOP切面，用于拦截方法的执行并记录日志。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(LoggingAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* com.example.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logMethodExecution</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().toShortString();</span><br><span class="line">        logger.info(<span class="string">&quot;Method &#123;&#125; executed&quot;</span>, methodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个切面中，<code>LoggingAspect</code>会拦截<code>com.example</code>包下所有方法的执行，在方法执行后使用<code>logger</code>记录方法的名称。</p>
<ol start="2">
<li><strong>启用AOP和组件扫描：</strong> 在Spring Boot的配置类上添加<code>@EnableAspectJAutoProxy</code>注解，以启用AOP功能，同时确保你的切面被正确地扫描到。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 配置其他内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保<code>basePackages</code>中的包路径是你的切面和服务类所在的包。</p>
<ol start="3">
<li><strong>调用方法：</strong> 在业务逻辑中调用方法，切面会在方法执行后记录日志。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YourService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Processed result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，当调用<code>process</code>方法时，切面会在方法执行后使用日志记录相关信息。</p>
<ol start="4">
<li><strong>配置日志输出：</strong> 在<code>src/main/resources</code>目录下创建<code>logback.xml</code>文件，根据你的需求配置日志的输出格式、级别等。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过以上步骤，你就可以使用AOP思想实现基本的日志打印功能。当执行方法时，切面会在方法执行后记录相关的日志信息。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-DesignPattern</title>
    <url>/2023/08/20/Spring-DesignPattern/</url>
    <content><![CDATA[<h2 id="控制反转和依赖注入"><a href="#控制反转和依赖注入" class="headerlink" title="控制反转和依赖注入"></a>控制反转和依赖注入</h2><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a>模版方法</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2>]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC-部分源码解读</title>
    <url>/2023/08/26/Spring-IOC-SourceCodeAnalysis/</url>
    <content><![CDATA[<h2 id="Spring容器启动"><a href="#Spring容器启动" class="headerlink" title="Spring容器启动"></a>Spring容器启动</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationfile.xml&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code>就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1.png" alt="1"></p>
<p>简单介绍一下<strong>FileSystemXmlApplicationContext</strong> 和 <strong>AnnotationConfigApplicationContext</strong> 这两个类</p>
<p><strong>1、FileSystemXmlApplicationContext</strong> 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p>
<p><strong>2、AnnotationConfigApplicationContext</strong> 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式。</p>
<p>利用ClassPathXmlApplicationContext类创建一个实例：</p>
<p>首先，定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    String <span class="title function_">getMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义接口实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span> <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，我们就可以跑起来了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:application.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;context 启动成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class="line">        <span class="type">MessageService</span> <span class="variable">messageService</span> <span class="operator">=</span> context.getBean(MessageService.class);</span><br><span class="line">        <span class="comment">// 这句将输出: hello world</span></span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>顾名思义，就是一个生产Bean的工厂，负责生产和管理各个Bean实例，刚刚所说的ApplicationContext 实际上就是一个BeanFactory，BeanFactory接口继承结构如下：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2.png" alt="2"></p>
<ul>
<li><p>ListableBeanFactory：根据句Listable可知通过这个接口我们可以获取多个Bean，但是顶层BeanFactory只能每次获取单个Bean实例</p>
</li>
<li><p>HierarchicalBeanFactory：通过Hierarchical这个单词可知，我们可以通过这个接口创建多个BeanFactory（<strong>不是多个Bean实例</strong>），然后将多个BeanFactory设置为父子关系。</p>
</li>
<li><p>AutowireCapableBeanFactory 用于自动装配Bean的，虽然ApplicationContext 没有继承它，但是可以使用组合，ApplicationContext 的最后一个方法getAutowireCapableBeanFactory()就是组合使用。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;</span><br><span class="line">    String <span class="title function_">getId</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getApplicationName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getDisplayName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getStartupDate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    ApplicationContext <span class="title function_">getParent</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    AutowireCapableBeanFactory <span class="title function_">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ConfigurableListableBeanFactory 这个接口比较特殊，继承了第二层的所有三个接口，但是ApplicationContext 没有</li>
</ul>
<h2 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h2><h3 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractXmlApplicationContext</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="type">boolean</span> refresh, ApplicationContext parent)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh(); <span class="comment">// 核心方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh()方法"></a>refresh()方法</h3><p>介绍一下refresh方法，因为他是ClassPathXmlApplicationContext类构造方法的核心方法，它主要的作用就是用于重建，refresh方法会将原来的ApplicationContext销毁然后重新执行一次初始化操作。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 这里创建一个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛，类似于MySQL“当前读”防止幻读的时候的间隙锁。</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource。</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器。</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建-Bean-容器前的准备工作"><a href="#创建-Bean-容器前的准备工作" class="headerlink" title="创建 Bean 容器前的准备工作"></a>创建 Bean 容器前的准备工作</h4><p>prepareRefresh()就是用来创建Bean容器之前的准备工作，在讲refresh方法中讲到过，主要是记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 记录启动时间，</span></span><br><span class="line">   <span class="comment">// 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span></span><br><span class="line">   <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">   <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment，初始化上下文环境中的任何占位符属性源</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验 xml 配置文件</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建Bean容器，加载并注册Bean"><a href="#创建Bean容器，加载并注册Bean" class="headerlink" title="创建Bean容器，加载并注册Bean"></a>创建Bean容器，加载并注册Bean</h4><p>obtainFreshBeanFactory() 方法就是用于初始化BeanFactory、加载Bean、注册Bean等这个方法是refresh中最重要的一个部分，<strong>但是这个方法执行结束之后Bean实例并没有生成，也就是说Bean没有完成初始化。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回刚刚创建的 BeanFactory</span></span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">// 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span></span><br><span class="line">   <span class="comment">// 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前ApplicationContext 是否有 BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化一个 DefaultListableBeanFactory，至于为什么要用这个类是因为前面说的继承图，具体为什么见下方注解</span></span><br><span class="line">      <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">      <span class="comment">// 用于 BeanFactory 的序列化</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载 Bean 到 BeanFactory 中</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？</p>
<p>前面的BeanFactory中有一个接口叫做ConfigurableListableBeanFactory，它实现了BeanFactory下面一层的所有三个接口，而这个接口只有一个实现类DefaultListableBeanFactory，而实现类DefaultListableBeanFactory实际上间接实现了BeanFactory下的三个接口，所以结论就是，DefaultListableBeanFactory是最牛的BeanFactory。例图如下</p>
</blockquote>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2.png" alt="2"></p>
<p>customizeBeanFactory(beanFactory)方法就是配置是否允许BeanDefinition覆盖、是否允许循环引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.allowBeanDefinitionOverriding != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 定义覆盖</span></span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.allowCircularReferences != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 间的循环依赖</span></span><br><span class="line">      beanFactory.setAllowCircularReferences(<span class="built_in">this</span>.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadBeanDefinitions(beanFactory)就是根据配置，加载各个Bean，然后放到BeanFactory中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">   <span class="comment">// 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader来读取加载配置、解析</span></span><br><span class="line">   <span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">   <span class="comment">// resource loading environment.</span></span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="built_in">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="built_in">this</span>);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> <span class="title class_">ResourceEntityResolver</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span></span><br><span class="line"></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 重点来了，继续往下，实际上就是loadBeanDefinitions()方法的重载，这两个方法还是在一个类中</span></span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">   Resource[] configResources = getConfigResources();</span><br><span class="line">   <span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 往下看</span></span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   &#125;</span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   <span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line">   <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 注意这里是个 for 循环，也就是每个文件是一个 resource</span></span><br><span class="line">   <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">      <span class="comment">// 继续往下看</span></span><br><span class="line">      counter += loadBeanDefinitions(resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 最后返回 counter，表示总共加载了多少的 BeanDefinition</span></span><br><span class="line">   <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource.getResource());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 用一个 ThreadLocal 来存放配置文件资源</span></span><br><span class="line">   Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">      currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">         <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 核心部分是这里，往下面看</span></span><br><span class="line">         <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里就不看了，将 xml 文件转换为 Document 对象</span></span><br><span class="line">      <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">      <span class="comment">// 继续</span></span><br><span class="line">      <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (...</span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line"><span class="comment">// 返回值：返回从当前配置文件加载了多少数量的 Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">   <span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 这里才使用另外一个类(DefaultBeanDefinitionDocumentReader)的方法</span></span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line"><span class="comment">//创建DOM树结构，其中的doRegisterBeanDefinitions()函数主要用于解析xml文件</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">   logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line">   <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">   <span class="comment">// 从 xml 根节点开始解析文件</span></span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC</title>
    <url>/2023/08/20/Spring-IOC/</url>
    <content><![CDATA[<h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><p>所谓的IOC就是Inversion Of Control，也就是控制反转，其实就是对于某个对象A，原来的控制权在B手上，B想用就能用，想不用就不用，但是现在把控制权交还给了A，只有A给了别人权限才能用，这就是控制反转。</p>
<p>没有IOC的时候，举例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//此时就是我们所说的控制权在B手上，也就是控制(不是控制反转)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(a);<span class="comment">//此时B对A控制使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了IOC时使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//此时控制权在A自己手上，可以直接使用，当然如果对象A没有注入到容器之中的话，B就不能使用。</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(a);<span class="comment">//此时B对A控制使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下来就是：IOC（不是指的Spring IOC容器，Spring IOC容器是实现IOC思想的一个载体）实际上就是一种设计思想，可以通过Spring框架对一些原本本来需要手动创建的对象，交由Spring框架统一管理。</p>
<p>​    如果没有Spring的IOC容器的话，我们要使用某个对象的时候只能通过创建对象的方式解决，但是有了SpringIOC容器之后，对象就会交由IOC容器创建并管理，当我们想使用的时候就直接从容器中获取即可。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot开发规范（一）</title>
    <url>/2022/11/21/SpringBoot-levelFunction/</url>
    <content><![CDATA[<h2 id="model（entity）"><a href="#model（entity）" class="headerlink" title="model（entity）"></a>model（entity）</h2><p>​        model是模型的意思，与entity、domain、pojo类似，是存放实体的类，类中定义了多个类属性，并与数据库表的字段保持一致，一张表对应一个model类。 主要用于定义与数据库对象应的属性，提供get/set方法,tostring方法,有参无参构造函数。</p>
<h2 id="dao（mapper）"><a href="#dao（mapper）" class="headerlink" title="dao（mapper）"></a>dao（mapper）</h2><p>​        又被成为mapper层，叫数据持久层，先设计接口，然后在配置文件中进行配置其实现的关联。 dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。 数据持久化操作就是指，把数据放到持久化的介质中，同时提供增删改查操作，比如数据通过hibernate插入到数据库中</p>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>​        业务逻辑层，完成功能的设计 和dao层一样都是先设计接口，再创建要实现的类，然后在配置文件中进行配置其实现的关联。接下来就可以在service层调用dao层的接口进行业务逻辑应用的处理。 service的impl是把mapper和service进行整合的文件 封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。</p>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>​        控制层，控制业务逻辑service，控制请求和响应，负责前后端交互 controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/2052481-20210417164128180-1418412203.png" alt="img"></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-summaryTwo</title>
    <url>/2023/12/19/MySQL-summaryTwo/</url>
    <content><![CDATA[<h2 id="一条SQL更新语句是如何执行的？"><a href="#一条SQL更新语句是如何执行的？" class="headerlink" title="一条SQL更新语句是如何执行的？"></a>一条SQL更新语句是如何执行的？</h2><p>上篇说到一条SQL查询语句如何执行，这下说一下一条SQL更新语句如何执行的，其实跟一条查询语句执行过程大差不差，只不过更新流程会涉及两个重要的日志模块：redolog和binlog。</p>
<p>先简单说一下大致流程：客户端连接-连接器权限认证-分析器分析词法和语法-优化器决定执行方案-执行器执行优化后的方案-更新成功。（这里不会走到查询缓存的原因很简单：我们执行的语句是更新，而不是查询，<strong>缓存的目的就是能减少磁盘I/O的次数，直接在缓存中找到结果然后返回给客户端。</strong>）</p>
<p>下面介绍一下我们的主角：<code>redo log(重做日志)</code>和<code>bin log(归档日志)</code></p>
<h3 id="redo-log：InnoDB引擎特有的日志"><a href="#redo-log：InnoDB引擎特有的日志" class="headerlink" title="redo log：InnoDB引擎特有的日志"></a>redo log：InnoDB引擎特有的日志</h3><p>先讲个故事，如果你是一个小卖部的老板（这时候还没有什么互联网、记账app、备忘录等），假如有人会赊账或者还账，如果人少的话，用**铅笔(注意一下，是用铅笔，后面会说明原因)**写一张便利贴就能搞定，但是人多的话，肯定就需要一个记录赊账/还账的总账本，那么别人来还账/赊账的时候，老板你无疑是两种做法：</p>
<ul>
<li>直接拿出总账本，找到相关记录进行修改。</li>
<li>先记在便利贴上，等晚上打烊空闲的时候再通过便利贴来一一对总账本里面进行相关修改。</li>
</ul>
<p>那么，当某些时刻赊账/还账人很多的时候，就不得不使用第二种方案了，毕竟总账本里面记录的人太多了，找到一个人的时间肯定很长，毕竟密密麻麻的字堆一起，找到了再进行计算、修改会很麻烦。</p>
<p>MySQL也是这样，如果每次修改一条记录，都需要从磁盘(总账本)里面找到对应的记录，然后进行计算，回写磁盘，想想光IO查询成本都不低，为了优化，MySQL的设计者就采用了先写便利贴，再抽空根据便利贴里面的记录在总账本找到对应的记录进行修改。</p>
<p>实际这种想法就是MySQL中的WAL技术（Write-Ahead-Logging），顾名思义就是先写日志，再写磁盘，也就是先写便利贴，再写总账本。</p>
<p>大致流程就是：</p>
<p>当一条记录要更新的时候，待事务提交之后，InnoDB引擎会先把操作记录写入日志缓冲区，再将缓冲区中的日志异步写到磁盘中，并更新内存中对应的记录，这个时候更新流程就算完成了，而具体什么时候将修改后的数据更新到磁盘中进行持久化，往往是在系统空闲的时候做，比如中午/晚上，你的店休息/打烊了。</p>
<p>介绍完redo log工作的大致流程，再解释一下上面<strong>为啥说的是用铅笔写便利贴</strong>，这是因为InnoDB的redo log是固定大小的，它实际上可以虚拟化成一个圆圈，分成四块，每一块可以存储1GB的内容，当写完一圈之后，就会覆盖以前的log日志开始下一轮覆写。如下图所示：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20231219145330819.png" alt="image-20231219145330819"></p>
<ul>
<li><p>write_pos：当前记录的位置，会一边写一边往后移</p>
</li>
<li><p>write_pos—check_point区间：表示接下来可写的部分记录新的操作log。</p>
</li>
<li><p>check_point：用于擦除以前的log日志，但是在擦除前需要把被擦除部分的数据更新到数据文件中。</p>
</li>
</ul>
<blockquote>
<p>提问：如果是redo log是先写入日志缓冲区再写入磁盘，如果在写入缓冲区之后，还没来得及写入磁盘，MySQL服务被kill了，redo log日志不会丢失吗？</p>
</blockquote>
<h3 id="bin-log：归档日志"><a href="#bin-log：归档日志" class="headerlink" title="bin log：归档日志"></a>bin log：归档日志</h3><p>先说一下binlog和redolog的区别：</p>
<ul>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使⽤。 </li>
<li>redo log是物理⽇志，记录的是“在某个数据⻚上做了什么修改”；binlog是逻辑⽇志，记录的是这个 语句的原始逻辑，⽐如“给ID=2这⼀⾏的c字段加1 ”</li>
<li>redo log是循环写的，空间固定会⽤完；binlog是可以追加写⼊的。“追加写”是指binlog⽂件写到⼀ 定⼤⼩后会切换到下⼀个，并不会覆盖以前的⽇志。</li>
</ul>
<p>两个log日志互相配合的过程大致如下：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20240310120332997.png" alt="image-20240310120332997"></p>
<ul>
<li>提问：为什么不是先提交redolog再提交binlog或者先提交redolog再提交binlog</li>
<li>回答：主要是为了保证两个日志的数据一致性问题，也是为了保证原子性，防止因为其中一个log提交了事务，但是因为系统故障导致另一个log没有写入日志从而导致的日志数据一致性问题。</li>
</ul>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP、IP、DNS</title>
    <url>/2022/01/16/TCP%E3%80%81IP%E3%80%81DNS/</url>
    <content><![CDATA[<p>你好，我是小八，最近在备考，考试总算是结束了，终于可以放假，学习更多的技术了<del>干自己想干的事情了</del></p>
<p>下面分享一些 IP、TCP、DNS 的基础知识点，大家可以看看，绝对通俗易懂！！！</p>
<h1 id="与-HTTP-关系密切的协议：IP、TCP-和-DNS"><a href="#与-HTTP-关系密切的协议：IP、TCP-和-DNS" class="headerlink" title="与 HTTP 关系密切的协议：IP、TCP 和 DNS"></a>与 HTTP 关系密切的协议：IP、TCP 和 DNS</h1><h4 id="负责传输的-IP-协议："><a href="#负责传输的-IP-协议：" class="headerlink" title="负责传输的 IP 协议："></a>负责传输的 IP 协议：</h4><p>&emsp;&emsp;按层次分，IP（Internet Protocol）网际协议属于网络层。<strong>IP 地址</strong>和<strong>IP</strong>不同，“IP”其实就是一种协议的名称，即：网际协议。</p>
<p>&emsp;&emsp;IP 协议作用：把各种<strong>数据包</strong>传送给对方，但是必须满足<strong>IP 地址</strong>和<strong>MAC 地址</strong>（Media Access Control Address）两个条件才能确实送到对方那里。</p>
<p>&emsp;&emsp;<strong>IP 地址</strong>：节点被分配到的地址，</p>
<p>&emsp;&emsp;<strong>MAC 地址</strong>：网卡所属的固定地址。</p>
<p>&emsp;&emsp;<strong>注意：</strong> IP 地址可以变换，MAC 地址基本不变。</p>
<p>&emsp;&emsp;IP 通信依赖 MAC 地址, 因为不同计算机之间通信时，通常是不在一个局域网(LAN)下，此时就需要多个中间计算机和设备（路由器等均可作为中转设备）进行中转，最后连接到你所需要连接的计算机，在中转的过程中，会利用到下一个中转设备的 MAC 地址来寻找到下一个中转目标。这下就要用到了<strong>ARP 协议</strong>(Address Resolution Protocol).</p>
<p>&emsp;&emsp;<strong>ARP 协议：</strong> 一种解析地址的协议，根据对方的 IP 地址可以反查出对应的 MAC 地址。</p>
<p>&emsp;&emsp;如果还是不懂的话，就拿快递公司的收发货方式来打一个比方吧，我们要是双十一买了东西（“东西”就是我们在网络上要传递给某个设备的信息），卖家需要把东西寄给我们（”我们“就是接收信息的设备），那么他们就会把自己的货物送到某快递的集散中心，然后集散中心通过核对收件人地址，来确定送到下一个集散中心（这里的“集散中心”就是类似于一个中转设备），最后到达离收件地址最近的集散中心之后，再送到我们手上（这时候就实现了发起设备和接收设备的信息传递）。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/IP%E3%80%81TCP%E5%92%8CDNS/ARP%E5%8D%8F%E8%AE%AE.png?versionId=CAEQGRiBgID_98q58hciIGU2NDAxY2JlNmQ5MzQ2YjViYzQyZTgyZTQ3NmI0ZDY1" alt="img"></p>
<h4 id="确保可靠性的-TCP-协议"><a href="#确保可靠性的-TCP-协议" class="headerlink" title="确保可靠性的 TCP 协议"></a>确保可靠性的 TCP 协议</h4><p>&emsp;&emsp;TCP 和 UDP 都位于传输层，这个前面说过，其中 TCP 是用来提供可靠的字节流服务。</p>
<p>&emsp;&emsp;其中 TCP 协议能够准确确定数据是否送达目标处，这样的实现的过程就是通过三次握手（three-way handshaking）策略，其中握手过程中使用了 TCP 的标志（flag）——ACK 和 SYN，原理如下：</p>
<p>&emsp;&emsp;第一次由发起端首先发送一个 SYN 标志的数据包给接收端，第二次握手就是在接收端接收这个标志之后，接收端再反馈一个 SYN 和 ACK 的数据包给发起端，来表达自己已经接收到了发起端的请求，最后一次握手就是在收到接收端的确认信息之后，发起端回传一个 ACK 的数据包给接收端，代表“握手”结束。</p>
<p>&emsp;&emsp;如果其中有某一次握手中断，那就会延续上一次握手进行重复的请求，但要是请求超时之后就会重新开始由发送端进行第一次握手。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/IP%E3%80%81TCP%E5%92%8CDNS/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png?versionId=CAEQGRiBgMDa98q58hciIGZjNTZlZWU4OWI1MzRjYjdhMDIyMzEzYWYyNWNiMGE2" alt="image-20211230200934379"></p>
<h4 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h4><p>就是当你在访问某个网站的时候，会有一个网址(比如：<code>www.baidu.com</code>也就是此网站的域名)，而在访问某个计算机的时候也可以通过赋予此计算机一个域名，最后通过 DNS 解析域名来获取其 IP 地址，最后访问到此计算机。</p>
<p>DNS 的作用便是通过域名查找对应的设备的 IP 地址，或者逆向从 IP 地址查域名的服务。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/IP%E3%80%81TCP%E5%92%8CDNS/DNS.png?versionId=CAEQGRiBgMDIlN658hciIGI1YTcxNDhjZjNlMjQxNTdiMTA1OTVkYjJjZjE5ODg5" alt="image-20211230202446976"></p>
<hr>
<p>你好，我是小八，一个分享学习经历和知识的在读大学生。</p>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot开发规范(二)</title>
    <url>/2023/02/04/SpringBoot%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="PO即persistant-Object-持久对象："><a href="#PO即persistant-Object-持久对象：" class="headerlink" title="PO即persistant Object 持久对象："></a><strong>PO即persistant Object 持久对象：</strong></h3><p>&emsp;在O/R 映射（即ORM-ObjectRelationMapping）中出现的概念，通常对应数据模型（数据库），是与数据库汇总的表想影射的java对象，最简单的PO就是对应数据库中某个表中的一条记录，多个记录则用PO的集合。PO中不应该包含任何对数据库的操作。</p>
<h3 id="DO即Domain-Object-领域对象："><a href="#DO即Domain-Object-领域对象：" class="headerlink" title="DO即Domain Object 领域对象："></a><strong>DO即Domain Object 领域对象：</strong></h3><p>&emsp;是从现实世界中抽象出来的有形或无形的业务实体。</p>
<h3 id="TO即Transfer-Object数据传输对象："><a href="#TO即Transfer-Object数据传输对象：" class="headerlink" title="TO即Transfer Object数据传输对象："></a><strong>TO即Transfer Object数据传输对象：</strong></h3><p>&emsp;不同应用程序之间传输的对象</p>
<h3 id="DTO即Data-Transfer-Object-数据传输对象："><a href="#DTO即Data-Transfer-Object-数据传输对象：" class="headerlink" title="DTO即Data Transfer Object:数据传输对象："></a><strong>DTO即Data Transfer Object:数据传输对象：</strong></h3><p>&emsp;泛指用于展示层与服务层之间的数据传输对象</p>
<h3 id="VO即value-Object："><a href="#VO即value-Object：" class="headerlink" title="VO即value Object："></a><strong>VO即value Object：</strong></h3><p>&emsp;通常用于业务层之间的数据传递，和PO一样仅包含数据，但是抽象出的业务对象，可以和表对应，用new 关键字创建，GC回收</p>
<h3 id="BO即Business-Object-业务对象"><a href="#BO即Business-Object-业务对象" class="headerlink" title="BO即Business Object 业务对象:"></a><strong>BO即Business Object 业务对象:</strong></h3><p>&emsp;主要是将业务逻辑封装为一个对象，这个对象可以包含一个或多个其他对象，如一个简历中包含教育经历、工作经历、社会关系等，可以将一个教育经历对应一个PO、工作经历对应一个PO、设计关系对应一个PO，然后简历一个对应简历的BO兑现处理简历，每个BO包含这个PO这样处理业务逻辑是，可以针对BO去处理。封装业务逻辑的java对象，通过调用DAO方法，结合PO,VO进行业务操作。</p>
<h3 id="POJO即Plain-Ordinary-Java-Object"><a href="#POJO即Plain-Ordinary-Java-Object" class="headerlink" title="POJO即Plain Ordinary Java Object:"></a><strong>POJO即Plain Ordinary Java Object:</strong></h3><p>&emsp;简单无规则的java对性，即在一些O/R 映射工具中，能做到维护数据库表记录的PO完全是一个符合Java Bean规范的纯java对象</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>URI</title>
    <url>/2022/02/04/URI/</url>
    <content><![CDATA[<blockquote>
<p>时隔一周，我终于抽空又来分享一些知识了<del>承蒙关注，希望各位小伙伴点赞加关注</del></p>
</blockquote>
<p>你好，我是小八，一个分享学习知识和经验的在读大学生。</p>
<p>前几期我们已经讲了 tcp/ip 协议族、IP，TCP，DNS 的作用，我们再来讲讲我们经常上网都会使用到的 URI 和 URL 吧~</p>
<h2 id="URL-和-URI"><a href="#URL-和-URI" class="headerlink" title="URL 和 URI"></a>URL 和 URI</h2><p><strong>URL</strong>（Uniform Resource Locator）：统一资源定位符。也就是我们口中所称的网址。</p>
<p><strong>URI</strong>（Uniform Resource Identifier）：URI 用字符串表示某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。</p>
<p>也就是说 URL 是 URI 的子集。</p>
<blockquote>
<p>所以我们下面讲一讲 URI 的格式，也就能理解什么是 URL 了~</p>
</blockquote>
<h2 id="URI-格式"><a href="#URI-格式" class="headerlink" title="URI 格式"></a>URI 格式</h2><p>URI 需要涵盖全部必要信息的绝对 URI、绝对 URL 以及相对 URL，这时候大家肯定很疑惑，什么是<strong>相对</strong>，什么是<strong>绝对</strong>？其实很好理解。</p>
<p><strong>绝对 URL</strong>（比如说一个完整的通信地址，包含国家，省，市，小区门牌号，姓名。） 包含了指向目录或文件的完整信息，包括指向目录或文件的完整信息，包括模式、主机名和路径。</p>
<p>绝对 url 本身与被引用的文件实际位置无关，无论在哪个主机上的网页中，某一文件的绝对 URL 都是完全一样的。因此，当引用别人服务器上的文件时，应该总是使用绝对 URL。</p>
<p><strong>相对 URL</strong> 指出的位置是以信息提供者的位置为参照的。（假设 A 的位置标记为在 B 的向左十米，那么这个位置就是相对地址，相对于 B 的位置而言的）相对 URL 以包含 URL 本身的文件位置为参照点，描述目标文件的位置。因此，相对 URL 可以表达像“指向本页面同一目录的那个文件”的意思。</p>
<p>下面就是绝对 URI 的格式：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220124170905495.png" alt="绝对URI格式"></p>
<p>当然上面的协议方案名也不止一种，还有 https、ftp、mailto、file 等 30 种左右</p>
<p>说了这么多，我再来解释一下上面的各个小模块的意思吧</p>
<h3 id="登录信息（认证）"><a href="#登录信息（认证）" class="headerlink" title="登录信息（认证）"></a>登录信息（认证）</h3><p>其实就是为了当你在访问服务器资源的时候，通过用户名账号和密码对你的身份信息进行认证。</p>
<h3 id="服务器地址"><a href="#服务器地址" class="headerlink" title="服务器地址"></a>服务器地址</h3><p>使用绝对 URI 必须指定待访问的服务器地址。</p>
<ul>
<li><p>可以是类似 <a href="https://pengzihao166.work/">pengzihao166.work</a> 这种 DNS 可解析的地址</p>
</li>
<li><p>也可以是 192.168.1.1 这类 IPv4 地址</p>
</li>
<li><p>再或者是类似[0:0:0:0:0:0:0:1]这种 IPv6 地址名</p>
</li>
</ul>
<h3 id="服务器端口号"><a href="#服务器端口号" class="headerlink" title="服务器端口号"></a>服务器端口号</h3><p>此项和登录信息一样是可选项，可以指定服务器连接的网络端口号，如果省略就会自动使用默认的端口号。</p>
<h3 id="带层次的文件路径"><a href="#带层次的文件路径" class="headerlink" title="带层次的文件路径"></a>带层次的文件路径</h3><p>就和电脑某个文件的<strong>路径</strong>类似，指定服务器上的文件路径来定位特指的资源。</p>
<h3 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h3><p>对已指定的文件路径内资源，可以使用查询字符串传入任意参数。</p>
<h3 id="片段标识符"><a href="#片段标识符" class="headerlink" title="片段标识符"></a>片段标识符</h3><p>使用片段标识符通常可<strong>标记</strong>出已获取资源中的子资源（文档内的某个位置）。</p>
<p><strong>注意</strong>：登录信息、查询字符号、服务器端口号、片段标识符都是可选项~</p>
<p>好了~今天的知识分享就到此结束了</p>
<hr>
<p>你好，我是小八，承蒙厚爱，能不能点赞加个关注呢~</p>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>终于熬过来了！！！</title>
    <url>/2022/01/06/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<p>大家好，我是小八，好久不见啊，我今天终于熬完了课设和汇编备考。</p>
<p>现在来分享一下我的<strong>战斗经历</strong></p>
<p>我们课设的小组成员由 5 个人组成：周**、小八、赵.**、陈**、曹**</p>
<p>因为复习汇编的时间和课设的时间挤在了一起，导致我们寝室小组最近都经常肝到凌晨两三点，<strong>划重点：不建议学弟学妹们这么做！！！</strong> 属实很累。</p>
<p>经过是这样的，我们小组确定的课设题目是 <strong>校园助手</strong> 。</p>
<p>既然是校园助手，肯定得有查成绩、查课表、查地图、聊天、修改个人信息等功能，这样的话，因为我最近在学习前端，组长也在学习服务器开发，于是我们小组就一拍即合，做一个前后端分离的 demo，并且得有一个像校园助手的样子，自然就不能继续用控制台，用黑框框来展示我们的成果了，果断选择 QT 平台。</p>
<p>毕竟要做，就要做一个牛逼的东西！！！先给你们看看登录界面的展示效果吧。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/mainwindow1.png?versionId=CAEQGRiBgID80f.28RciIGE4OWU3ZDI1OGJmNzRiNGM4ZjQ4ZjEwYzgzZGYyYWRj"></p>
<p>下面的是我们客户端的图标，有没有想到湖工大考试平台的图标呢？？</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/myico.png?versionId=CAEQGRiBgIC7.ZS48RciIGZlZDVhM2MxYzE4NTRkNzliYjk2MjE5MjJlOTlhNTZm"></p>
<p>这个界面看似简单，但实际上，后面很多的功能实现、界面跳转、跟服务器的数据请求以及初始化数据都是在这个界面的代码块进行实现，简简单单看看代码就知道了，这个 demo 好歹也是做了大半个月呢。</p>
<p>截图如下：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/code.png?versionId=CAEQGRiBgMDPis.38RciIDhkMjgyM2UyMGQwMDQ1MWE5ZDA1NzZlMDhmMzBkMjBl"></p>
<h2 id="最大瓶颈出现"><a href="#最大瓶颈出现" class="headerlink" title="最大瓶颈出现"></a>最大瓶颈出现</h2><p>而这也仅仅是主界面的一个很小的功能模块的代码块罢了，我还记得当时我们遇到的最大的一个瓶颈就是，实现两台不同设备之间的向服务器端发送请求，并且记录对方 IP，通过服务器作为中转站交互信息。我们小组一直在接触服务器开发的也就是我们的组长——周**，而我也最近才只是刚刚入门计网，我和他也只能仅仅讨论一下，解决的想法。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>遇到这个问题的时候，我和组长刚开始毫无思路，我就在一个在字节、腾讯、快手等大佬汇集的群里问一问经验和解决方案。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/chat1.png?versionId=CAEQGRiBgIDF1f238RciIGRhYWEyMTc2MmZkNDQ3MDU4ZDQ0MjY1NWZkMTA1YTg5"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/chat2.png?versionId=CAEQGRiBgMDH1f238RciIDgwODZlMWU3NmRiMzRhY2NiZTAyNzM1ZGFkMzk1NWIx"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/chat3.png?versionId=CAEQGRiBgMDN1f238RciIDM1M2RkNWNlZWNhZjQ5YjJiMWMwNjE5YWEyMzc2Yjll"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/chat4.png?versionId=CAEQGRiBgMDZ1f238RciIDVmMGZkNmMyZWU4YjQwZWU5NmZkYzg0ZTdiNDYzMjBi"></p>
<p>当时毕竟很晚了他们应该已经睡觉了，没有人回我，后来才回复了我。</p>
<p>过了一会，我和组长突然想到了一个办法，那就是通过每个人的固定学号绑定到每个用户的 IP，并固定 IP，就是说等我们连接到服务器之后，再分别在 cmd 里面 ipconfig /all 一下两台设备的 IP，最后改一下服务器端的代码块里面的 IP 地址，岂不是走了一波小捷径？毕竟不知道怎么获取 IP 地址，并实时更新对应用户的 IP，因为 IP 一直是会更新的，一般随着路由的分配形成一个局域网，重连一次网络 DHCP 就会重新分配一次新的 IP，而且咱也实力有限,能想到这个想法，个人觉得已经很不错了。</p>
<p>这虽然说是服务器端的任务，前端只需要直接从服务器获取数据就行了，但这样我对计网也有了更加深层次的了解，知道怎么在实际需求中，进行构思解决方案，并且我还发现，后端要跟着前端的需求走，前端需要什么，后端就得实时进行更新并处理数据，所以感觉后端好惨。</p>
<blockquote>
<p><strong>划重点</strong>：以后还是要转后端学习的我，先让组长替我受受苦吧，hhhhhhhh。</p>
</blockquote>
<p>当然当时这个 demo 的问题还有很多，比如，修改个人信息栏如何实现<strong>换行</strong>，而不是在一行里面显示，导致显示溢出的问题，当时不知道怎么解决，我就写了一个判断语句，来控制那个信息栏输入字符长度，让个人信息就显示在一行，但不会溢出，就类似于 QQ 个性签名文字个数限制一样。</p>
<h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><p>刚刚介绍的只是我们前后端交互当时遇到的一个最大的问题，而我们前端，当时有很多功能，比如：登录，注册，修改密码，显示课程表，班级成员成绩等，都需要从后端获取相应的数据之后，在前端进行逻辑实现，并反馈给服务器。</p>
<p>比如：你在登录的时候，需要输入账号密码之后，将用户数据发送到服务器进行用户信息的遍历，找到是否有匹配的用户，如果没有，那么服务器就会反馈 NO 的信息给前端，自然也就登录不进去，如果有，那么反馈给前端一个 YES，则就能登入客户端，进行查看课表、查成绩等功能。</p>
<p>登录失败前端反馈如下图：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/logNO.png?versionId=CAEQGRiBgMCW9MO48RciIDdmYjJkYzU4YTZlNjQ1YmU5ZDA5OGEwM2M1NjRjN2Jm"></p>
<p>登录成功便进入此界面：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/logYES.png?versionId=CAEQGRiBgMCX9MO48RciIDJlN2VmOGNjOWJkYjQ4YjU4MGI3MjA3Y2E3ZTM3NGJl"></p>
<p>服务器这边的反馈信息如下：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/houduan.png?versionId=CAEQGRiBgIC368q48RciIDQzOThjZDE3OTNiMDRkNGNhZWI0NjdjOTIwYzc2MTlk"></p>
<p>有一说一，看到这个后端是不是觉得很牛逼，我也确实佩服我的组长，一个人能完成所有的前端发来的数据处理，在下属实佩服，不知道你们怎么觉得，反正我还很菜，目前还做不出来一个服务器。</p>
<p>当然还有其他的功能，我就不一一展示了，比如：注册、修改个人信息、忘记密码、展示工大地图、查询成绩等。都是其他小组成员分别负责的几个小模块。</p>
<p>这里科普一下：只要服务器一开，我们打开客户端的时候，对服务器就会<strong>三次握手</strong>发送连接请求（有兴趣的小伙伴可以去了解一下）。</p>
<h2 id="答辩过程"><a href="#答辩过程" class="headerlink" title="答辩过程"></a>答辩过程</h2><p>昨天上午我们找到老师进行了答辩，而且我们小组因为敢于尝试 QT 平台和实现了前后端分离，小组成绩获得了所有小组中的最高分</p>
<p>还记得当时有挺多人来围观我们的课设，小组成员在答辩的时候附近声音属实嘈杂。</p>
<p>当组长答辩完他写的服务器之后，便到我进行对自己的功能模块的答辩了，首先我对老师介绍了我的功能模块，能够实现什么？能够干些什么？</p>
<p>我的解答就是，我的负责的模块可以分为三大块：</p>
<h4 id="1、窗口（mainwidow）、对话框（dialog）、按钮（button）之间的跳转-（QT-自带的信号，槽函数进行实现）"><a href="#1、窗口（mainwidow）、对话框（dialog）、按钮（button）之间的跳转-（QT-自带的信号，槽函数进行实现）" class="headerlink" title="1、窗口（mainwidow）、对话框（dialog）、按钮（button）之间的跳转 （QT 自带的信号，槽函数进行实现）"></a>1、窗口（mainwidow）、对话框（dialog）、按钮（button）之间的跳转 （QT 自带的信号，槽函数进行实现）</h4><p>比如这一块就是通过信号和槽来实现对数据传递，并跳转出成绩查询窗口。</p>
<p>代码如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">void MainWindow1::<span class="built_in">on_serch_clicked</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">connect</span>(dialog1, SIGNAL(sendNum(QString)), this, <span class="built_in">SLOT</span>(getNum(QString)));</span><br><span class="line">    <span class="comment">//查询成绩</span></span><br><span class="line">    dialog1-&gt;<span class="built_in">setModal</span>(true);</span><br><span class="line">    dialog1-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、在主窗口对服务器发送数据，接收服务器数据"><a href="#2、在主窗口对服务器发送数据，接收服务器数据" class="headerlink" title="2、在主窗口对服务器发送数据，接收服务器数据"></a>2、在主窗口对服务器发送数据，接收服务器数据</h4><p>比如下面的代码就是登录之后，将登录用户数据发送给服务器。</p>
<p>代码如下：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">this</span>-&gt;</span><span class="function"><span class="title">clint_Login</span>-&gt;</span>write(user_msg);</span><br></pre></td></tr></table></figure>

<h4 id="3、登录功能、课表的查询展示"><a href="#3、登录功能、课表的查询展示" class="headerlink" title="3、登录功能、课表的查询展示"></a>3、登录功能、课表的查询展示</h4><p>介绍完之后，老师问了我一个问题，下面的代码是什么意思：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">QJsonDocument <span class="attr">doc</span> <span class="operator">=</span> QJsonDocument::fromJson(UserInfo, <span class="variable">&amp;json_error</span>)<span class="punctuation">;</span></span><br></pre></td></tr></table></figure>

<p>我的回答无疑就是解释它的是怎么用的，通过定义一个QJsonDocument的 doc 对象，把 userinfo 里面的信息进行解析出来获取数据放到 doc 中。</p>
<p>毕竟当时是一边学 QT 一边做的，并不是很了解深层原理，也就只好这么回答了。但老师好像就是要我剖析它的深层原理，对我的答案，并不是很满意，只怪自己当初并没有花更多的时间去研究 QT 吧。</p>
<p>再就是问了一下我的课表是怎么实现的，实现代码在哪？</p>
<p>我的回答就是，其实真的很简单，就是一个插图的办法实现的，通过 new 一个课表类的对象 Class_Schedule 初始化课表，再进行窗口模糊 setModal 和窗口展示 show 进行实现。</p>
<p>跳转代码段如下：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">void</span> <span class="variable">MainWindow1</span>::<span class="function"><span class="title">on_scotmtb_clicked</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">Class_Schedule</span>-&gt;<span class="function"><span class="title">setModal</span>(<span class="variable"><span class="literal">true</span></span>);</span></span><br><span class="line"><span class="function">    <span class="variable">Class_Schedule</span>-&gt;<span class="title">show</span>();</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>不过这有很大<strong>局限性</strong>：因为只能查到自己班的课表。嘻嘻嘻~</p>
<p>我的课设答辩差不多就这样结束了。</p>
<p>不过当时有一个学生在那里跟我们的课设指指点点，我当时就在想：能不能尊重一下我？是我在答辩，不是你！你当你能像毛主席一样指点江山？</p>
<p>希望关注我的小伙伴们以后不会遇到这种人。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说了这么多，总结以下几点：</p>
<p>1、前后端分离，能改善修改代码的效率，不会因为一个小 bug，去修改一整片的代码，从而提高了功能更新的效率。</p>
<p>2、少熬夜，熬夜伤身。（在这里再立一个 flag，2022 年不仅要好好学习技术，还得少熬夜，跟以前一样 11 点之前就睡觉，没事多锻炼一下身体。）</p>
<p>3、bug 常常有，有时候一个 bug 一天都修复不了很正常，慢慢去想就行了，不要急躁，切记，敲代码务必要戒骄戒躁。</p>
<p>4、不知道某个瓶颈怎么解决，可以换一种思路或者方式去解决这个问题，多和同学讨论，或者像大佬请教，上百度找教程等等。<strong>（忌:ctrl c + ctrl v）</strong></p>
<p>5、最近计网的知识，能够在实际应用中想到相应的解决方案，并跟组员一同分享。</p>
<p>6、不足就是，组员中除了我都不会用 Git，不然能更高效率实现各功能模块代码的合并，减少很多不必要的麻烦。</p>
]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-k个一组翻转链表</title>
    <url>/2023/08/18/leetcode-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/reverse_ex1.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/reverse_ex2.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[3,2,1,4,5]</span></span><br></pre></td></tr></table></figure>



<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ul>
<li>局部翻转</li>
<li>k &gt; 剩余局部链表长度时，这部分链表无需翻转</li>
</ul>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li><p>初始化</p>
<p><code>ListNode dummy = new ListNode(0,head);</code></p>
</li>
<li><p>设置指针实现局部翻转</p>
<p><code>ListNode pre = dummy,end = dummy</code></p>
</li>
<li><p>end.next != null 则遍历链表</p>
<ol>
<li><p>根据k确定第一组局部链表的尾部指针</p>
<p><code>for(int i = 0; i &lt; k &amp;&amp; end != null; i++) end = end.next;</code></p>
<p>此时<code>end == null</code>时，说明剩余的局部链表长度小于k，直接跳出循环无需翻转链表。</p>
</li>
<li><p>确定局部链表起始位置及下一组的起始位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">start = pre.next;</span><br><span class="line">next = end.next;</span><br></pre></td></tr></table></figure></li>
<li><p>断开end的后续链表，并调用翻转函数使pre.next连接翻转后的链表。</p>
<p><code>pre.next = reverse(start);</code></p>
</li>
<li><p>重新连接被翻转和未翻转的部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">start.next = next;<span class="comment">//连接后面未翻转的链表</span></span><br><span class="line">pre = next;<span class="comment">//重置pre和end指针开始新的一轮链表组的翻转</span></span><br><span class="line">end = pre;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>返回dummy后面所有已经翻转的链表</p>
</li>
</ol>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy, end = dummy;</span><br><span class="line">        <span class="keyword">while</span>(end.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="literal">null</span>; i++)&#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> end.next;</span><br><span class="line">            end.next = <span class="literal">null</span>; </span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line">            end = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-两数之和</title>
    <url>/2022/10/26/leetcode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<blockquote>
<p>Problem: <a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h1><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20221026204201974.png" alt="两数之和"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>看到这一题我首先想到的就是通过类似于冒泡排序的思想，通过两个for循环对数组里面的值进行一一相加并跟target进行比较，如果值等于target那么就返回，否则就进行下一次循环，也就是所谓的暴力解法，不过这样真的非常损耗时间复杂度</p>
</blockquote>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote>
<p>这里面要注意的是，同一个数x不能进行重复相加，那么就需要我们进行一一枚举，即在数组nums中寻找中有没有一个数是target - x，且当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。如果找到了这个target - x则返回x和target - x的下标index即可</p>
</blockquote>
<p>代码</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li><p>时间复杂度: </p>
<blockquote>
<p> $O(N2)$</p>
</blockquote>
</li>
<li><p>空间复杂度: </p>
<blockquote>
<p> $O(1)$</p>
</blockquote>
</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-回文数</title>
    <url>/2022/10/27/leetcode-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>Problem: <a href="https://leetcode.cn/problems/palindrome-number/description/">9. 回文数</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>看到这题的第一想法就是把数字x进行反转得到数字reverse，然后与x进行比较是否相等即可，刚开始我想的是把数字转成字符串然后使用反转函数直接反转，最后使用eqauls方法进行比较即可，但是我忘记了怎么将数字转换成String类型的字符串。后来遍知道一个数一个数字进行翻转</p>
</blockquote>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote>
<p>由题可知x&lt;0的时候因为含有负号，故所有小于0的数都不是回文数，直接return false即可，x&gt;0的时候，我用一个temp表示x翻转后的数字，num用于x逐一翻转，直到num/10==0的时候说明翻转完成，得到的结果return num == x的结果即可。</p>
</blockquote>
<p>但是，看了题解之后我发现其实翻转一半就行了，就算是奇数个位数，最后return reverse/10 == x即可</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li><p>时间复杂度: </p>
<blockquote>
<p>O(logn)</p>
</blockquote>
</li>
<li><p>空间复杂度: </p>
<blockquote>
<p>O(1)</p>
</blockquote>
</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> x;</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">                temp = temp*<span class="number">10</span>+num%<span class="number">10</span>;</span><br><span class="line">                num = num/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x == temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">revertedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/palindrome-number/solutions/281686/hui-wen-shu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-两数相加</title>
    <url>/2023/03/19/leetcode-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[2,4,3]</span>, l2 = <span class="comment">[5,6,4]</span></span><br><span class="line">输出：<span class="comment">[7,0,8]</span></span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[0]</span>, l2 = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：l1 = [<span class="number">9,9,9,9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>], l2 = [<span class="number">9,9,9,9</span>]</span><br><span class="line">输出：[<span class="number">8,9,9,9</span>,<span class="number">0,0,0,1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<h2 id="题解如下："><a href="#题解如下：" class="headerlink" title="题解如下："></a>题解如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//进位数字</span></span><br><span class="line">        <span class="comment">//定义一个可移动的指针，用来指向存储两个数之和的位置</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">         <span class="comment">//定义一个新联表伪指针，用来指向头指针，返回结果</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="comment">//当l1 不等于null或l2 不等于空时，就进入循环</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果l1 不等于null时，就取他的值，等于null时，就赋值0，保持两个链表具有相同的位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="comment">//将两个链表的值，进行相加，并加上进位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + carry;</span><br><span class="line">            <span class="comment">//计算进位数</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//计算两个数的和，此时排除超过10的请况（大于10，取余数）</span></span><br><span class="line">            sum %= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//将求和数赋值给新链表的节点，</span></span><br><span class="line">            <span class="comment">//注意这个时候不能直接将sum赋值给cur.next = sum。这时候会报，类型不匹配。</span></span><br><span class="line">            <span class="comment">//所以这个时候要创一个新的节点，将值赋予节点</span></span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line">             <span class="comment">//将新链表的节点后移</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="comment">//当链表l1不等于null的时候，将l1 的节点后移</span></span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">null</span>)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果最后两个数，相加的时候有进位数的时候，就将进位数，赋予链表的新节点。</span></span><br><span class="line">        	<span class="comment">//两数相加最多小于20，所以的的值最大只能时1</span></span><br><span class="line">            <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-寻找两个正序数组的中位数</title>
    <url>/2023/03/21/leetcode-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,3]</span>, nums2 = <span class="comment">[2]</span></span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = <span class="comment">[1,2,3]</span> ，中位数 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,2]</span>, nums2 = <span class="comment">[3,4]</span></span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = <span class="comment">[1,2,3,4]</span> ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m &lt;= 1000</code></li>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= m + n &lt;= 2000</code></li>
<li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li>
</ul>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[m+n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            nums[i] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n; j++)&#123;</span><br><span class="line">            nums[nums1.length + j] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span>(nums.length % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[(m + n) / <span class="number">2</span> - <span class="number">1</span>] + nums[(m + n) / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[(m + n) / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他方法还在研究ing。。。。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-无重复字符的最长子串</title>
    <url>/2023/03/19/leetcode-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下"></a>题目如下</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<h2 id="题解如下："><a href="#题解如下：" class="headerlink" title="题解如下："></a>题解如下：</h2><p>主要用到的思想就是滑动窗口，通过HashMap集合的key值不可重复原理来判断是否遇到重复的字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//考虑孔字符串的情况</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//统计最大的子串长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左指针指向子串的第一个字符index</span></span><br><span class="line">        <span class="comment">//以字符串的一个字符作为key,其对应的index作为value</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;<span class="comment">//判断是否i位置下的字符是否有对应的value，如果有那么就说明重复了，此时将左指针定位到对应的value下，因为对应的value保存的就是此时此字符的index</span></span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            <span class="comment">//此时最大的子串不重复长度就是i - left + 1(即此时正在扫描的子串长度) 和 maxLength(上一串扫描的子串长度) 二者最大值之一。</span></span><br><span class="line">            maxLength = Math.max(maxLength,i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-最长回文子串</title>
    <url>/2023/03/21/leetcode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
<h2 id="题解如下"><a href="#题解如下" class="headerlink" title="题解如下"></a>题解如下</h2><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230321164819370.png" alt="image-20230321164819370"></p>
<h5 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">boolean</span> [][]dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">//所有的一个字符的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">//记录回文子串的初始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录回文子串长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">childLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span>; l &lt;= len;l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">                <span class="comment">//j代表子串的尾字符的index，即确定右边界</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果尾字符超出字符串最大长度、跳出循环</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= len)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(charArray[i]!=charArray[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//可能是一个或者两个或者三个字符的子串</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则就依次递归</span></span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若 dp[i][l] == true 成立，就表示s[i....l]是回文，记录此时回文的长度以及起始位置</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; childLen)&#123;</span><br><span class="line">                    childLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin + childLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-连续子数组的最大和</title>
    <url>/2023/02/02/leetcode-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=cug7nw1"><em>剑指 Offer 42. 连续子数组的最大和</em></a></p>
<p>[TOC]</p>
<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230202220726900.png"></p>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h3 id="1、动态规划"><a href="#1、动态规划" class="headerlink" title="1、动态规划"></a>1、动态规划</h3><h4 id="推想："><a href="#推想：" class="headerlink" title="推想："></a>推想：</h4><p>​    若nums数组的长度为n，下标则为0~n-1，用f(i)表示以第i个数结尾的<strong>连续子数组的最大和</strong>，故有：</p>
<p>​<br>$$<br>max{f(i)},0≤i≤n-1<br>$$</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>​    求出每段以第i个数结尾的子数组的f(i)，返回最大的f(i)即可</p>
<h4 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h4><p>​    考虑nums[i]单独成一段还是加入f(i-1)这一段子数组，则可以通过判断nums[i] + f(i-1)和nums[i]的大小实现</p>
<p>$$<br>f(i) = max{nums[i]+f(i-1),nums[i]}<br>$$</p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//存储f(i - 1)的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">           pre = Math.max(x + pre, x);</span><br><span class="line">           maxSum = Math.max(pre , maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、分治法："><a href="#2、分治法：" class="headerlink" title="2、分治法："></a>2、分治法：</h3><p>见<a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solutions/876881/lian-xu-zi-shu-zu-de-zui-da-he-by-leetco-tiui/">leetcode题解</a>(点击即可查看)</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>mhy-test01</title>
    <url>/2024/03/10/mhy-test01/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">地图上有<span class="built_in">n</span>个格子排成一排，最左边的格子为<span class="number">1</span>，最右边的格子为<span class="built_in">n</span>。</span><br><span class="line">第<span class="number">0</span>秒时，每个格子都有一只史莱姆。</span><br><span class="line"></span><br><span class="line">第i只史莱姆的跳跃方向用数组a表示。a[i]=<span class="number">0</span>表示史莱姆跳跃的方向是往左。若第 i 秒史莱姆位于格子 x，那么第 i+<span class="number">1</span> 秒史莱姆会跳到格子 x-<span class="number">1</span> 。如果当前史莱姆在格子 ，则下一秒史莱姆将跳出地图。a[i]=<span class="number">1</span>表示史莱姆跳跃的方向是往右。若第 i 秒史莱姆位于格子 x，那么第 i+<span class="number">1</span> 秒史莱姆会跳到格子 x+<span class="number">1</span> 。如果当前史莱姆在格子<span class="built_in">n</span>，则下一秒史莱姆将跳出地图。</span><br><span class="line"></span><br><span class="line">米小游想知道第<span class="number">1</span>~<span class="built_in">n</span>秒，地图上有多少个格子没有史莱姆。</span><br><span class="line"></span><br><span class="line">输入描述：</span><br><span class="line">第一行包含一个整数 <span class="built_in">n</span>(<span class="comment">1 &lt;= n &lt;= 3 * 10^3</span>)，表示地图上的格子数量。</span><br><span class="line"></span><br><span class="line">第二行包含<span class="built_in">n</span>个整数 a[i](<span class="number">0</span> &lt;= a[i] &lt;= <span class="number">1</span>)，表示每只史莱姆的跳跃方向</span><br><span class="line"></span><br><span class="line">输出描述</span><br><span class="line">输出包含一行<span class="built_in">n</span>个整数，用空格隔开，第i个数表示第i秒没有史莱姆的格子数量。</span><br><span class="line">输入：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">//包含一个整数 n(1 &lt;= n &lt;= 3 * 10^3)，表示地图上的格子数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//包含n个整数 a[i](0 &lt;= a[i] &lt;= 1)，表示每只史莱姆的跳跃方向</span></span><br><span class="line">        a[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//输出包含一行n个整数，用空格隔开，第i个数表示第i秒没有史莱姆的格子数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt; <span class="number">0</span>) &#123;<span class="comment">//史莱姆从左边跳出地图</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + i &gt;= n) &#123;<span class="comment">//史莱姆从右边跳出地图</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = count;</span><br><span class="line">    &#125;		</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        System.out.print(res[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>微布开发-服务器排查</title>
    <url>/2023/10/09/web-check-out-server-broken-down/</url>
    <content><![CDATA[<h1 id="服务器排查"><a href="#服务器排查" class="headerlink" title="服务器排查"></a>服务器排查</h1><h3 id="服务器版本"><a href="#服务器版本" class="headerlink" title="服务器版本"></a>服务器版本</h3><p>4核8g，CentOS 7.6</p>
<h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><p>每次上课前20min，服务器响应超时，服务器几乎处于宕机状态</p>
<h3 id="排查流程："><a href="#排查流程：" class="headerlink" title="排查流程："></a>排查流程：</h3><h4 id="1、查看服务器CPU状态、以及MySQL慢查询记录"><a href="#1、查看服务器CPU状态、以及MySQL慢查询记录" class="headerlink" title="1、查看服务器CPU状态、以及MySQL慢查询记录"></a>1、查看服务器CPU状态、以及MySQL慢查询记录</h4><p>使用<code>top</code>命令，发现占用最多的MySQL一般CPU120%左右，初步判断可能是慢查询导致的，定位到对应的MySQL的慢查询文件路径，并查看其日志，发现慢查询的触发都是在半夜的时候（后续去排查为什么半夜出现此问题），排除是MySQL慢查询导致。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20231009162007045.png" alt="CPU使用情况"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20231009161859821.png" alt="MySQL慢查询记录"></p>
<h4 id="2、查看服务器宕机记录："><a href="#2、查看服务器宕机记录：" class="headerlink" title="2、查看服务器宕机记录："></a>2、查看服务器宕机记录：</h4><p>使用命令<code>last reboot</code>和<code>last -F |grep crash</code>发现没有宕机导致的重启的情况</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20231009143704640.png" alt="查询历史重启记录"></p>
<h4 id="3、查看系统日志："><a href="#3、查看系统日志：" class="headerlink" title="3、查看系统日志："></a>3、查看系统日志：</h4><p>定位到/var/log文件夹下，查看messages，sa记录等，我查看了sa记录(<code>sar -u -f sa09 | more</code>、<code>sar -s -f sa09 | more</code>)，发现memory在用户使用的高峰期，就会几乎爆满了，但是问题不大，只要没有100%就还好，毕竟他这个<code>%memused</code>是算上了<code>buff/cached</code>的。通过top命令发现实际上使用的大概是50%（不含buff/cache）左右。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20231009161827366.png" alt="系统统计的资源使用情况"></p>
<h4 id="4、查看磁盘读写情况"><a href="#4、查看磁盘读写情况" class="headerlink" title="4、查看磁盘读写情况"></a>4、查看磁盘读写情况</h4><p>毋庸置疑使用<code>df -h</code>命令看看是不是磁盘满了，导致大量请求的时候，写太慢了所以宕机了？一看果然还真是。。。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20231009160853041.png" alt="磁盘占用率"></p>
<p>问题找到！然后通过<code>du -sh *</code>去定位到到底是什么文件导致的占用磁盘空间过大，然后发现是Java的log和MySQL的一个表磁盘占用比较大，所以我删除了最近的几天的日志以及停用了MySQL的<code>exception</code>记录表</p>
<p>删除Java多少天之前的.log日志的命令：</p>
<p><code>find 文件夹路径 -mtime +5 -name &quot;*.log&quot; -exec rm -rf &#123;&#125; \;</code></p>
]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>微布开发-清理服务器日志(*.log结尾的文件)及MySQL存储的日志</title>
    <url>/2023/10/10/web-clearServerStorage/</url>
    <content><![CDATA[<p>接上篇，上次提到了排查是因为服务器的磁盘不够导致服务器没有写入的空间，进一步导致服务器宕机，下面是我清理磁盘日志的操作。</p>
<h3 id="清理日志文件-log文件"><a href="#清理日志文件-log文件" class="headerlink" title="清理日志文件(*.log文件)"></a>清理日志文件(*.log文件)</h3><p>我们的Java的日志文件是根据日期分开成不同的log，所以我写了一个shell脚本用来每天定时清理三天之前的所有日志文件。</p>
<p>清理的Linux命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find log文件的文件路径 -mtime +3 -name &quot;*.log&quot; -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>shell脚本命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定日志目录路径</span></span><br><span class="line">log_dir=&quot;*******/***/***&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算三天前的日期</span></span><br><span class="line">three_days_ago=$(date -d &quot;3 days ago&quot; +%Y%m%d)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除三天前的日志文件</span></span><br><span class="line">find &quot;$log_dir&quot; -mtime +3 -name &quot;*.log&quot; -exec rm -rf &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">echo &quot;已删除 $log_dir 目录下 $three_days_ago 之前的日志文件。&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>保存为一个shell脚本文件之后，赋予此文件执行权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x cleanup_logs.sh</span><br></pre></td></tr></table></figure>

<p>然后写一个定时任务，让这个shell脚本文件每天早上八点执行一次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开cron编辑器</span></span><br><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>然后在编辑器中添加以下行，以在每天的固定时间执行脚本（假设你希望在每天的凌晨8点执行）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 8 * * * /path/to/cleanup_logs.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件路径：/path/to/cleanup_logs.sh</span></span><br></pre></td></tr></table></figure>

<h3 id="清理MySQL中request-log表的文件："><a href="#清理MySQL中request-log表的文件：" class="headerlink" title="清理MySQL中request_log表的文件："></a>清理MySQL中request_log表的文件：</h3><p>由于这个表已经非常大了、估计多少有个几千万条记录了、通过<code>delete from tableName</code>肯定是不现实了，那么因为需要MySQL会先查数据然后删相关数据，所以我想到了分段删除的思想，也就是分批次来删除半年前的数据，那么这时候就有一个问题了，难不成手动删？显然不现实，于是我想到了MySQL中的定时器<code>PROCEDURE</code>，先定义个<code>PROCEDURE</code>函数，具体函数实现如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> DeleteOldRecords()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> batch_size <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">10000</span>;  <span class="comment">-- 每批次删除的记录数</span></span><br><span class="line">  <span class="keyword">DECLARE</span> total_records <span class="type">INT</span>;</span><br><span class="line">  <span class="keyword">DECLARE</span> deleted_records <span class="type">INT</span>;</span><br><span class="line">  <span class="keyword">SET</span> total_records <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> tableName <span class="keyword">WHERE</span> create_time <span class="operator">&lt;=</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">6</span> <span class="keyword">MONTH</span>));</span><br><span class="line">  </span><br><span class="line">  WHILE total_records <span class="operator">&gt;</span> <span class="number">0</span> DO</span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> tableName </span><br><span class="line">    <span class="keyword">WHERE</span> create_time <span class="operator">&lt;=</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">6</span> <span class="keyword">MONTH</span>) </span><br><span class="line">    LIMIT batch_size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">SET</span> deleted_records <span class="operator">=</span> ROW_COUNT();</span><br><span class="line">    <span class="keyword">SET</span> total_records <span class="operator">=</span> total_records <span class="operator">-</span> deleted_records;</span><br><span class="line">  <span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#create_time代表某条记录的创建时间字段</span><br><span class="line">#tableName代表你要执行函数的表名</span><br></pre></td></tr></table></figure>

<p>最后执行<code>CALL DeleteOldRecords();</code>的sql语句使以上函数开始删除相关记录</p>
<p>当然还需要等执行完此函数之后，删除此函数，sql命令如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> DeleteOldRecords;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>web-coursePushErrorSolution</title>
    <url>/2023/12/12/web-coursePushErrorSolution/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>重启python服务之后，课表推送服务莫名失效</p>
<h3 id="可能性"><a href="#可能性" class="headerlink" title="可能性"></a>可能性</h3><ul>
<li>调用微信推送接口逻辑有问题</li>
<li>重写推送服务之后，服务部署失败</li>
<li>由于服务器内存资源有限导致推送的时候，处理课表数据的时候，OOM导致进程被干掉了。</li>
</ul>
<h3 id="解决方案及思路"><a href="#解决方案及思路" class="headerlink" title="解决方案及思路"></a>解决方案及思路</h3><ol>
<li><p>本地测试了一遍，推送课表服务，发现推送成功，排除第一种可能性</p>
</li>
<li><p>重写推送服务之后，服务部署失败，发现在启动celery服务的时候确实启动失败了，因为通过微信后台的接口调用数据，发现到时间点的时候，即使调用失败也应该有调用接口次数统计，于是重新部署服务并打好了日志，防止后续出错，以便快速找到问题。</p>
</li>
<li><p>排查服务器资源</p>
<ol>
<li><p>上python的服务器之后，发现当时部署定时推送服务的时候没有打log（<strong>这是一个重大失误，以后一定要打不然很难找到问题的</strong>），后面重新部署了一遍，中途遇到了如下问题：</p>
<ol>
<li>多次nohup同一任务的时候，应该查看此任务进程是否还存在，如果存在就需要kill，否则会服务器后台会挂起多个相同的进程，导致服务器资源浪费，甚至可能导致宕机。。。比如昨天就是nohup多次同一个任务进程，导致资源浪费甚至被干宕机了</li>
</ol>
</li>
<li><p>等到推送的时候，查看celery打出来的日志，发现，返回的是40001，然后根据微信公众号的官方文档，发现是因为目前的accession_token失效导致的。</p>
</li>
<li><p>分析原因如下：</p>
<p>python服务器和主服务器都可能会请求公众号的token，如果python先请求token并保存在了本地redis里面，然后在7200s内，主服务器又请求了一次公众号的token，那么这时候python服务器的redis里面存的token就会失效（即使没有超时也会失效），然后推送课表的时候又是从python服务器的redis里面拿的失效的token，所以一直没有推送成功</p>
</li>
</ol>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>部署python服务流程：</p>
<ol>
<li>进入activate虚拟环境</li>
<li>如果python代码更新，需要重新部署，需要重新启动guincorn，命令如下：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gunicorn --config config/gunicorn.conf.py gateway.app:app</span><br></pre></td></tr></table></figure>

<ol>
<li>如果使用的是本地的redis，需先打开docker，再启动redis</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">docker start redis_name //在docker容器里面给某个redis取的别名</span><br></pre></td></tr></table></figure>

<ol>
<li>重启celery beat，好像是类似于im一样的心跳机制，worker需要通过beat的心跳来保证正常运行。</li>
<li>重启cerlery worker来守护进程，使得定时任务后台挂起。</li>
</ol>
]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>web-slowSQLSearchOptimize</title>
    <url>/2023/10/26/web-slowSQLSearchOptimize/</url>
    <content><![CDATA[<h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h3><p>在查询我参与过的说说的时候，拉取速度会直接超时，从而导致根本拉取不出来用户参与过的说说。</p>
<h3 id="查询逻辑"><a href="#查询逻辑" class="headerlink" title="查询逻辑"></a>查询逻辑</h3><p>优化前的查询逻辑：</p>
<p>&emsp;如果用户发布了某条说说的二级评论、那么也代表他参与过、此时就会先查到他评论的二级评论的bid、然后通过这个bid查到他评论的一级或对二级评论的评论的bid、最后通过while循环直到查到二级评论所对应的一级评论的<code>targetbid</code>字段，此时的<code>targetbid</code>就是存的那条贴子的唯一id，然后到talk表中拿这个<code>targetbid</code>作为主键查询到对应的说说记录即可。</p>
<p>优化后的查询逻辑：</p>
<p>&emsp;在评论表中的创建一个<code>masterbid</code>字段代表这条评论对应的贴子的唯一id，然后直接拿着这个<code>masterbid</code>（实际上就是talk表中某条记录的主键）作为条件去talk表里面查询即可</p>
<h3 id="排查过程："><a href="#排查过程：" class="headerlink" title="排查过程："></a>排查过程：</h3><p>优化1：</p>
<p>1、通过对测试数据库，使用<code>explain</code>语句查看我使用的查询的语句是否走的是<code>ALL</code>查询，发现真是的话、确定是没有走或创建索引查询的，</p>
<p>2、去看这个评论表有没有创建索引，发现是没有创建索引的，由于查询语句中<code>where</code>的条件只有一个，所以只需要对<code>target_bid</code>创建一个索引，就会让他走到索引。</p>
<p>优化2：</p>
<p>1、发现创建一个<code>master_bid</code>字段代表是这个二级评论或者一级评论对应的贴子id，前端完全可以传过来这条二级评论对应的贴子的id，后续查询的时候只需要查到这个用户是否有过评论记录即可直接从记录中的<code>master_bid</code>字段找到贴子唯一id</p>
<p>2、然后拿着这个唯一id直接去talk表里面查询即可。</p>
<h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><p><code>bid</code>：一级评论和二级评论的主键</p>
<p><code>master_bid</code>：一级评论或二级评论对应的贴子的唯一id</p>
<p><code>target_bid</code>：一级评论的对应贴子的唯一id，二级评论对应的回复的一级评论或二级评论的唯一id</p>
<p><code>user_bid</code>：评论者的主键id</p>
]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>微布开发-数据库备份</title>
    <url>/2023/10/11/web-sqlBackup/</url>
    <content><![CDATA[<p>要定时每天固定时间将MySQL数据库备份成.sql.gz格式的文件，可以使用Linux上的cron作业和<code>mysqldump</code>命令结合使用。</p>
<h3 id="步骤如下："><a href="#步骤如下：" class="headerlink" title="步骤如下："></a>步骤如下：</h3><ol>
<li><h4 id="创建备份脚本："><a href="#创建备份脚本：" class="headerlink" title="创建备份脚本："></a><strong>创建备份脚本</strong>：</h4><p>创建一个Shell脚本，例如<code>backup_mysql.sh</code>，并确保该脚本可执行。使用文本编辑器创建并编辑脚本文件，然后添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL数据库连接信息</span></span><br><span class="line">DB_USER=<span class="string">&quot;your_username&quot;</span></span><br><span class="line">DB_PASS=<span class="string">&quot;your_password&quot;</span></span><br><span class="line">DB_NAME=<span class="string">&quot;your_database_name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份文件的保存路径</span></span><br><span class="line">BACKUP_DIR=<span class="string">&quot;/path/to/backup/directory&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成备份文件名（带有时间戳）</span></span><br><span class="line">BACKUP_FILE=<span class="string">&quot;<span class="variable">$BACKUP_DIR</span>/backup_<span class="subst">$(date +\%Y\%m\%d\%H\%M\%S)</span>.sql.gz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用mysqldump命令备份数据库</span></span><br><span class="line">mysqldump -u<span class="variable">$DB_USER</span> -p<span class="variable">$DB_PASS</span> <span class="variable">$DB_NAME</span> | gzip &gt; <span class="variable">$BACKUP_FILE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除旧的备份文件（可选）</span></span><br><span class="line"><span class="comment"># find $BACKUP_DIR -type f -name &quot;backup_*.sql.gz&quot; -mtime +7 -exec rm &#123;&#125; \;</span></span><br></pre></td></tr></table></figure>

<p>请替换<code>your_username</code>，<code>your_password</code>，<code>your_database_name</code>和<code>/path/to/backup/directory</code>为您的MySQL数据库凭据和备份文件目录。</p>
</li>
<li><h4 id="设置执行权限："><a href="#设置执行权限：" class="headerlink" title="设置执行权限："></a><strong>设置执行权限</strong>：</h4><p>通过运行以下命令来为脚本文件赋予执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x backup_mysql.sh</span><br></pre></td></tr></table></figure></li>
<li><h4 id="设置定时任务："><a href="#设置定时任务：" class="headerlink" title="设置定时任务："></a><strong>设置定时任务</strong>：</h4><p>使用cron作业来定时运行备份脚本。运行以下命令编辑cron作业：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>在打开的编辑器中，添加以下行来定时运行备份脚本（将时间和脚本路径替换为您的偏好）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 2 * * * /path/to/backup_mysql.sh</span><br></pre></td></tr></table></figure>

<p>上述示例表示每天凌晨2点运行备份脚本。您可以根据需要调整时间。</p>
</li>
<li><h4 id="保存并退出编辑器。"><a href="#保存并退出编辑器。" class="headerlink" title="保存并退出编辑器。"></a><strong>保存并退出编辑器</strong>。</h4></li>
</ol>
<p>现在，cron将在指定的时间每天运行备份脚本，并将MySQL数据库备份成.sql.gz文件保存在指定的目录中。可以根据需要自定义备份的保留策略（如上面脚本中的删除旧备份文件的示例）。请确保脚本中的敏感信息（如用户名和密码）得到妥善保护，以免泄露。</p>
]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>web-timetableServerDown</title>
    <url>/2023/10/26/web-timetableServerDown/</url>
    <content><![CDATA[<h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><p>接上次说的服务器宕机排查，最近又出现了一次宕机，发现每次到上课前20min的时候服务器就会直接宕机处理不了</p>
<h3 id="排查原因"><a href="#排查原因" class="headerlink" title="排查原因:"></a>排查原因:</h3><p>第一感觉是服务器磁盘又爆了，但是当时也才清理几天，后面去看top，发现CPU被干爆了、然后赶紧去查一下Java的日志、发现主要都是在调用python的爬虫服务占用了大量的线程，于是再去另一台服务器上面查询python的日志发现因为请求数远远大于python服务器能够承受的压力，所以很多请求一直积压或者处理错误，进一步导致Java调用的时候也会抛出一些异常以及请求超时。</p>
<h3 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a>解决思路：</h3><p>每次打开小程序都会默认请求一次拉去最新课表，这样会因为课表请求太大导致的服务器宕机，于是我考虑了课表的以下几个特点来进行了一些优化：</p>
<ul>
<li>老师调课可能性比较低，完全可以不需要每次都调用py去获取课表</li>
<li>服务器资源有限</li>
<li>小程序可以本地缓存</li>
</ul>
<p>看到以上三点，毋庸置疑，我采取了小程序本地缓存策略、看看类似于天天课程表、wakeup等相关app都是采取的本地爬虫，爬取课表并存储到本地，并没有实现实时性更新，课表可变性也很低，所以完全可以本地缓存课表。</p>
<p>当用户每次打开小程序本地拉取三次缓存课表之后，再自动请求服务器更新课表并更新本地缓存，这样就可以很大程度上使得用户不会在同一时间段疯狂请求进一步降低服务器压力、在一定程度上也给用户提高了体验。</p>
<p>而用户需要强制刷新的话可以下拉刷新的方式，请求服务并更新本地缓存即可。</p>
]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>初识TCP/IP协议族</title>
    <url>/2021/12/30/%E5%88%9D%E8%AF%86TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/</url>
    <content><![CDATA[<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E5%88%9D%E5%A7%8BTCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/%E5%88%9D%E8%AF%86TCP%20IP%E5%8D%8F%E8%AE%AE%E6%97%8F.png?versionId=CAEQGRiBgMDG4eKp8BciIDc4YjRlNWZiOTUwNzRlNGY5OTFiNmQzYjBlZWZkODRk"></p>
<p>&emsp;  你好，我是小八。今天我们来讲一下TCP/IP协议族。</p>
<h2 id="初识TCP-IP协议族"><a href="#初识TCP-IP协议族" class="headerlink" title="初识TCP/IP协议族"></a>初识TCP/IP协议族</h2><p>&emsp; HTTP属于TCP/IP的一个子类，通常使用的网络（包括互联网）都是在TCP/IP协议族的基础上运作。</p>
<h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p>&emsp;计算机网络设备之间进行信息交互就需要基于相同的方法或者说是同一种协议才能进行通信。就比如：我们需要进行通信的时候，就需要知道如何探测到通信的目标、从哪一边开始发起通信请求、使用什么语言通信、怎么结束通信请求等所制定的规则，便被成为协议（protocol）。</p>
<p>&emsp;<strong>而TCP/IP协议族就是互联网相关的各类协议族的总称。</strong>对于TCP/IP协议族，通常有两种说法，一是指TCP和IP这两种协议，二是指TCP/IP在IP协议的通信中，使用到的协议族的统称。</p>
<p>TCP/IP协议族如下图：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E5%88%9D%E5%A7%8BTCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/%E6%97%8F%E7%BE%A4%E5%9B%BE.png?versionId=CAEQGRiBgIDE4eKp8BciIDdkZjU1ZTAzOTEzYTQ3ZWFhY2IxMzIyMTU5OTNlMjBi" alt="image-20211230151831761"></p>
<h3 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h3><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E5%88%9D%E5%A7%8BTCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/TCP%20IP%E5%88%86%E5%B1%82%E7%AE%A1%E7%90%86.png?versionId=CAEQGRiBgICU4eKp8BciIGU0OTczOWY0YmE5YjRjYmRhMjRiNTdhOGUwOTAzOTEz" alt="image-20211230151253140"></p>
<p>&emsp;协议族通过分层化，可以高效管理改变不同层次设计的任务，把每个层次之间的不同接口规划好之后，每个层次的内部设计也可以自由改动，而不需要替换所有部分整体。</p>
<p>&emsp;<strong>应用层：</strong></p>
<p>&emsp;&emsp;预存各类通用的应用服务，决定了向用户提供应用服务时通信的活动。其中HTTP（超文本传输协议）、FTP（文件传输协议）、DNS（域名协议）等服务在此层</p>
<p>&emsp;<strong>传输层：</strong></p>
<p>&emsp;&emsp;对应用层提供处于<strong>网络连接中</strong>的两台计算机的<strong>数据传输</strong>。在此层中有两种不同性质的协议：TCP（传输控制协议）和UDP（用户数据报协议）</p>
<p>&emsp;<strong>网络层：</strong></p>
<p>&emsp;&emsp;用来处理在网络上流动的数据包，该层规定与对方计算机进行传输时，通过选择某一种路径（或者说是某一条传输路线）到达对方计算机，并且把数据包传给对方。因此此层又被称为<strong>网络互连层</strong>。</p>
<p>&emsp;&emsp;<strong>数据包</strong>是网络传输的最小数据单位。</p>
<p>&emsp;<strong>链路层：</strong></p>
<p>&emsp;&emsp;用来处理连接网络的硬件部分的层次，包括控制操作系统，硬件设备驱动，NIC（网络适配器，即网卡）等一系列可见的物理传输硬件设备（媒介）。</p>
<h3 id="TCP-IP通信传输流"><a href="#TCP-IP通信传输流" class="headerlink" title="TCP/IP通信传输流"></a>TCP/IP通信传输流</h3><p>&emsp;发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。 这种把数据信息包装起来的做法称为<strong>封装（encapsulate）</strong>（就类似于C++类的使用，将类中的成员和数据进行封装）。下图为例：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E5%88%9D%E5%A7%8BTCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/%E6%B5%81%E7%A8%8B%E5%9B%BE2.png?versionId=CAEQGRiBgICx4eKp8BciIDIzNDlkYjhjYWM1YjQyYTRiNTVjOTk4NmVhYmE0YWEz" alt="image-20211230160020206"></p>
<p>&emsp;</p>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>备份hexo-U盘篇</title>
    <url>/2023/05/16/%E5%A4%87%E4%BB%BDhexo-U%E7%9B%98%E7%AF%87/</url>
    <content><![CDATA[<h2 id="新机环境搭建"><a href="#新机环境搭建" class="headerlink" title="新机环境搭建"></a>新机环境搭建</h2><p>​    1、安装Node.js</p>
<p>​    2、安装Git</p>
<p>​    3、新建存放Blog的文件夹</p>
<h2 id="拷贝旧机器中得文件-文件夹"><a href="#拷贝旧机器中得文件-文件夹" class="headerlink" title="拷贝旧机器中得文件/文件夹"></a>拷贝旧机器中得文件/文件夹</h2><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds<span class="symbol">/</span></span><br><span class="line">source<span class="symbol">/</span></span><br><span class="line">themes<span class="symbol">/</span></span><br><span class="line">其中<span class="operator">/</span>代表拷贝的是文件夹</span><br></pre></td></tr></table></figure>

<h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>右键打开Git bash，依次输入下列命令之后，安装相关依赖</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>安装hexo</span><br><span class="line">   <span class="built_in">npm</span> install -g hexo</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>本地测试的时候需要用hexo server</span><br><span class="line">   <span class="built_in">npm</span> i hexo-server</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>将文章部署到github上的模块</span><br><span class="line">   <span class="built_in">npm</span> install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>安装RSS插件</span><br><span class="line">   <span class="built_in">npm</span> install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>添加Sitemap,加速网页收录速度</span><br><span class="line">   <span class="built_in">npm</span> install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>

<h2 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s -g == hexo g + hexo s</span><br></pre></td></tr></table></figure>

<p>在浏览器打开<a href="http://localhost:4000/">http://localhost:4000</a>查看效果</p>
]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>自学如何使用Git+Hexo搭建个人博客</title>
    <url>/2021/11/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Git%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>&ensp; &ensp;Hello,我们又见面了，不好意思，各位小伙伴，今天身边出了点状况，本来上午就想着更新的，但是下午发生了一件很让人不爽的事情，就耽误了分享学习心得的方法与步骤，好了，言归正传，不知道你们看了上一篇关于“Git从0到基本运用”的文章，有没有学会Git的使用呢？</p>
<p>&ensp; &ensp;要是还没有学会呢，那还得加油啊，学会了的话，那我们现在就进入正题吧，我们既然学会了这个Git，那我们就来学习一下如何通过Git和Hexo搭建一个属于自己的个人博客吧</p>
<span id="more"></span>
<h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><blockquote>
<ul>
<li>准备一个Github账号（在前面学习Git的时候应该就准备好了）</li>
<li>安装node.js，npm，并了解相关知识</li>
<li>安装Git for Windows（不同系统安装对应不同的版本）</li>
</ul>
</blockquote>
<h2 id="三、应用简介："><a href="#三、应用简介：" class="headerlink" title="三、应用简介："></a>三、应用简介：</h2><h3 id="3-1Node-js"><a href="#3-1Node-js" class="headerlink" title="3.1Node.js:"></a>3.1Node.js:</h3><h4 id="ensp-ensp-3-1-1-由来及优势："><a href="#ensp-ensp-3-1-1-由来及优势：" class="headerlink" title="&ensp; &ensp;3.1.1 由来及优势："></a>&ensp; &ensp;3.1.1 由来及优势：</h4><p>&ensp; &ensp; Node.js发布于2009年5月，由Ryan Dahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I/O模型，让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。</p>
<p>&ensp; &ensp; Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好，V8引擎执行Javascript的速度非常快，性能非常好，基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。</p>
<h4 id="ensp-ensp-3-1-2-主要功能："><a href="#ensp-ensp-3-1-2-主要功能：" class="headerlink" title="&ensp; &ensp;3.1.2 主要功能："></a>&ensp; &ensp;3.1.2 主要功能：</h4><p>&ensp; &ensp; V8引擎本身使用了一些最新的编译技术。这使得用Javascript这类脚本语言编写出来的代码运行速度获得了极大提升，又节省了开发成本。对性能的苛求是Node的一个关键因素。 Javascript是一个事件驱动语言，Node利用了这个优点，编写出可扩展性高的服务器。Node采用了一个称为“事件循环(event loop）”的架构，使得编写可扩展性高的服务器变得既容易又安全。提高服务器性能的技巧有多种多样。Node选择了一种既能提高性能，又能减低开发复杂度的架构。这是一个非常重要的特性。并发编程通常很复杂且布满地雷。Node绕过了这些，但仍提供很好的性能。</p>
<p>&ensp; &ensp; Node采用一系列“非阻塞”库来支持事件循环的方式。本质上就是为文件系统、数据库之类的资源提供接口。向文件系统发送一个请求时，无需等待硬盘（寻址并检索文件），硬盘准备好的时候非阻塞接口会通知Node。该模型以可扩展的方式简化了对慢资源的访问， 直观，易懂。尤其是对于熟悉onmouseover、onclick等DOM事件的用户，更有一种似曾相识的感觉。</p>
<p>&ensp; &ensp; 虽然让Javascript运行于服务器端不是Node的独特之处，但却是其一强大功能。不得不承认，浏览器环境限制了我们选择编程语言的自由。任何服务器与日益复杂的浏览器客户端应用程序间共享代码的愿望只能通过Javascript来实现。虽然还存在其他一些支持Javascript在服务器端 运行的平台，但因为上述特性，Node发展迅猛，成为事实上的平台。</p>
<p>&ensp; &ensp; 在Node启动的很短时间内，社区就已经贡献了大量的扩展库（模块）。其中很多是连接数据库或是其他软件的驱动，但还有很多是凭他们的实力制作出来的非常有用的软件。</p>
<p>&ensp; &ensp; 最后，不得不提到的是Node社区。虽然Node项目还非常年轻，但很少看到对一个项目如此狂热的社区。不管是新手，还是专家，大家都围绕着项目，使用并贡献自己的能力，致力于打造一个探索、支持、分享、听取建议的乐土。</p>
<h3 id="ensp-ensp-3-2-NPM："><a href="#ensp-ensp-3-2-NPM：" class="headerlink" title="&ensp; &ensp;3.2 NPM："></a>&ensp; &ensp;3.2 NPM：</h3><p>&ensp; &ensp;&ensp; &ensp; NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<blockquote>
<p>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</p>
</blockquote>
<blockquote>
<p>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</p>
</blockquote>
<blockquote>
<p>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p>
</blockquote>
<h3 id="ensp-ensp-3-3-其他应用："><a href="#ensp-ensp-3-3-其他应用：" class="headerlink" title="&ensp; &ensp;3.3 其他应用："></a>&ensp; &ensp;3.3 其他应用：</h3><p>&ensp; &ensp;&ensp; &ensp;Git的功能在前面的学习之后，大家也有所了解了，这里也就不多说了。</p>
<h2 id="四、搭建github博客"><a href="#四、搭建github博客" class="headerlink" title="四、搭建github博客"></a>四、搭建github博客</h2><h3 id="4-1-创建仓库"><a href="#4-1-创建仓库" class="headerlink" title="4.1 创建仓库"></a>4.1 创建仓库</h3><p>&ensp; &ensp;登录Github网站新建一个名为<code>你的用户名.github.io</code>比如说，如果你的github用户名是pengzihao166，那么你就新建pengzihao166.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <code>http://pengzihao166.github.io</code> 了。</p>
<p>&ensp; &ensp;由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p>
<p>注意：</p>
<p>&ensp; &ensp;1、注册的邮箱一定要验证，否则不会成功；</p>
<p>&ensp; &ensp;2、仓库名字必须是：<code>username.github.io</code>，其中<code>username</code>是你的github用户名。</p>
<p>&ensp; &ensp;3、仓库创建成功一般不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我等了十几分钟才生效。</p>
<p>&ensp; &ensp;当时还以为我操作失败了，然后疯狂重新删库，建库，就这个步骤我活活弄了一小时左右，后来把那个挂后台，去打了一把LOL大乱斗，回来之后发现好了，就继续战斗搭建博客了。</p>
<h3 id="4-2-绑定域名"><a href="#4-2-绑定域名" class="headerlink" title="4.2 绑定域名"></a>4.2 绑定域名</h3><p>&ensp; &ensp;这个有钱的，可以去买一个域名再去绑定，什么腾讯云，阿里云，godaddy都可以。</p>
<p>&ensp; &ensp;当然，你不绑定域名肯定也是可以的，就用默认的 <code>xxx.github.io</code> 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那就去买一个域名吧。</p>
<h2 id="五、配置SSH-Key"><a href="#五、配置SSH-Key" class="headerlink" title="五、配置SSH Key"></a>五、配置SSH Key</h2><p>&ensp; &ensp;其实在你们学习git的时候就已经有了SSH Key的配置，这里我就再稍微讲一下怎么进行配置吧。</p>
<blockquote>
<p>$ cd ~/. ssh #检查本机已存在的ssh密钥</p>
</blockquote>
<p>如果提示：No such file or directory 说明你是第一次使用git。</p>
<blockquote>
<p>ssh-keygen -t rsa -C “邮件地址”</p>
</blockquote>
<p>&ensp; &ensp;然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key,粘贴上去。</p>
<p>注意：这里是个人设置界面，不是你的远程库的那个settings！！！截图如下：</p>
<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/git和hexo搭建个人博客/QQ%E5%9B%BE%E7%89%8720211205165600.png?versionId=CAEQFxiBgICVrqGn7BciIDQwNjM5ODE0YTJjNDQ1ODg4OGYxODc3YjgzMGYyNGE1">

<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/git和hexo搭建个人博客/QQ%E5%9B%BE%E7%89%8720211205170337.jpg?versionId=CAEQFxiBgICr4Kun7BciIDNiNTA4OTFkZmNiZjQwN2FiZWNhMzNiNTQ0MzJkNDQw">

<h3 id="5-1-测试是否成功"><a href="#5-1-测试是否成功" class="headerlink" title="5.1 测试是否成功"></a>5.1 测试是否成功</h3><p>&ensp; &ensp;<code>$ ssh -T git@github.com </code># 注意邮箱地址不用改</p>
<p>&ensp; &ensp;如果提示Are you sure you want to continue connecting (yes/no)?，输入yes</p>
<p>&ensp; &ensp;然后会看到：</p>
<p>&ensp; &ensp;&gt; Hi xxxxx! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
<p>&ensp; &ensp;看到这个信息说明SSH已配置成功！</p>
<p>&ensp; &ensp;此时你还需要配置：</p>
<p>&ensp; &ensp;<code>$ git config --global user.name &quot;xxxx&quot;</code></p>
<p>&ensp; &ensp;// xxx是指你的github用户名，非昵称</p>
<p>&ensp; &ensp;<code>$ git config --global user.email  &quot;xxx@qq.com&quot;</code></p>
<p>&ensp; &ensp;// xxx是指填写你的github注册邮箱</p>
<p>注意：这里验证结果展示图如下：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/QQ%E5%9B%BE%E7%89%8720211204135329.png?versionId=CAEQFxiBgICPxYSQ7BciIGU4NjQzYWNkMzY3NTQxYjc5OTU0MTU3MzVjZDU1ZGUw"></p>
<p>&ensp; &ensp;你没有看错，没错就是啥都不会显示，然后你就可以进行下面的操作了</p>
<h2 id="六、使用hexo写博客"><a href="#六、使用hexo写博客" class="headerlink" title="六、使用hexo写博客"></a>六、使用hexo写博客</h2><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>下面的注意事项，需要各位小伙伴认真看好了，并且记住了，不然对你以后写博客的改动有很大影响。</p>
<ul>
<li><p>前面的配置环境只要搭好了，其实后面也就不难了，但是！！！也是非常重要的一个内容，不然前面的全白搭了</p>
</li>
<li><p>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行。</p>
</li>
<li><p>hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的<code>_config.yml</code>；</p>
</li>
</ul>
<h3 id="6-1-npm的安装"><a href="#6-1-npm的安装" class="headerlink" title="6.1 npm的安装"></a>6.1 npm的安装</h3><blockquote>
<p>$ npm install -g hexo</p>
</blockquote>
<h3 id="6-2-初始化"><a href="#6-2-初始化" class="headerlink" title="6.2 初始化"></a>6.2 初始化</h3><p>&ensp; &ensp;在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取,建议就取名hexo，方便以后代码管理），比如我的是E:/hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p>
<p>初始化的方法有两种：</p>
<p>1、可以随便找个地方右键打开 git bash here，然后输入cd /e/hexo/</p>
<blockquote>
<p>$ cd /e/hexo/</p>
</blockquote>
<blockquote>
<p>$ hexo init</p>
</blockquote>
<p>2、或者进入你前面创建的E:/hexo的文件夹之后，右键打开 git bash here，直接输入</p>
<blockquote>
<p>$ hexo init</p>
</blockquote>
<p>&ensp; &ensp;hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下：</p>
<blockquote>
<p>$ hexo g # 生成文件</p>
</blockquote>
<blockquote>
<p>$ hexo s # 启动服务</p>
</blockquote>
<p>&ensp; &ensp;执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的</p>
<p>hexo s是开启本地预览服务，打开浏览器访问 <code>http://localhost:4000</code> 即可看到内容</p>
<h3 id="6-3-主题修改-这一步可以不用做，等学会后面的操作之后，再去寻找自己喜欢的主题Theme"><a href="#6-3-主题修改-这一步可以不用做，等学会后面的操作之后，再去寻找自己喜欢的主题Theme" class="headerlink" title="6.3 主题修改(这一步可以不用做，等学会后面的操作之后，再去寻找自己喜欢的主题Theme)"></a>6.3 主题修改(这一步可以不用做，等学会后面的操作之后，再去寻找自己喜欢的主题Theme)</h3><p>&ensp; &ensp;既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。</p>
<p>&ensp; &ensp;个人比较喜欢的主题是：hexo-theme-yilia。</p>
<p>&ensp; &ensp;1、首先下载这个主题：</p>
<blockquote>
<p><code>$ cd /e/hexo/（或者进入你前面创建的E:/hexo的文件夹之后，右键打开 git bash here）</code></p>
</blockquote>
<blockquote>
<p><code>$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></p>
</blockquote>
<p>&ensp; &ensp;2、下载后的主题都在你的hexo的theme里面：</p>
<p>&ensp; &ensp;3、修改hexo文件夹根目录下的<code>_config.yml</code>（并不是theme里面的某个主题文件夹下的<code>_config.yml</code>）中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。</p>
<p>&ensp; &ensp;4、如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。（建议每次hexo s -g之前都clean一下，养成一个小习惯）</p>
<h3 id="6-4-上传操作"><a href="#6-4-上传操作" class="headerlink" title="6.4 上传操作"></a>6.4 上传操作</h3><p>&ensp; &ensp;1、首先安装一个插件：</p>
<p>&ensp; &ensp;<code>$npm install hexo-deployer-git --save</code></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/npm.png?versionId=CAEQFxiBgMDA6KCQ7BciIDBlNTM5NmIzMGI3NTRiMDRhMzFhNGUyZGJlYTEzMTE5"></p>
<p>&ensp; &ensp;因为没有这个插件，你在hexo d的时候会出现错误，其它命令不确定，部署这个命令一定要用git bash。</p>
<p>&ensp; &ensp;打开你的git bash，cd到你前面创建的hexo文件夹，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会：</p>
<p>&ensp; &ensp;如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。</p>
<p>&ensp; &ensp;首先，ssh key肯定要配置好。</p>
<p>&ensp; &ensp;其次，配置hexo根目录中的_config.yml中有关deploy的部分：</p>
<p>&ensp; &ensp;正确写法：</p>
<p>&ensp; &ensp;<code>deploy:</code></p>
<p>&ensp; &ensp;<code>type: git</code></p>
<p>&ensp; &ensp;<code>repository: git@github.com:pengzihao166/pengzihao166.github.io.git</code></p>
<p>&ensp; &ensp;<code>branch: master</code></p>
<p>&ensp; &ensp;错误写法：</p>
<p>&ensp; &ensp;<code>deploy:</code></p>
<p>&ensp; &ensp;<code>type: github</code></p>
<p>&ensp; &ensp;<code>repository: https://github.com/pengzihao166/pengzihao166.github.io.git</code></p>
<p>&ensp; &ensp;<code>branch: master</code></p>
<h3 id="6-5-常见hexo命令："><a href="#6-5-常见hexo命令：" class="headerlink" title="6.5 常见hexo命令："></a>6.5 常见hexo命令：</h3><blockquote>
<p>1、hexo new “postName” #新建文章</p>
</blockquote>
<blockquote>
<p>2、hexo new page “pageName” #新建页面</p>
</blockquote>
<blockquote>
<p>3、hexo generate #生成静态页面至public目录=hexo g</p>
</blockquote>
<blockquote>
<p>4、hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）=hexo s</p>
</blockquote>
<blockquote>
<p>5、hexo deploy #部署到GitHub  =  hexo d</p>
</blockquote>
<blockquote>
<p>6、hexo help  # 查看帮助</p>
</blockquote>
<blockquote>
<p>7、hexo version  #查看Hexo的版本   =    hexo -v</p>
</blockquote>
<blockquote>
<p>8、hexo s -g #生成并本地预览</p>
</blockquote>
<blockquote>
<p>9、hexo d -g #生成并上传</p>
</blockquote>
<p>&ensp; &ensp;注意：如果hexo s 失败，可能是你的hexo根目录下的node_modules文件出问题或者你的端口被占用了，可以试试hexo s -p 5000(这个5000可以改成任何你想的端口数字不唯一)，还是不行那就删掉node_modules，然后在hexo的根目录下git bash here，再输入npm install，会自动重新配置node_modules，这样应该就能解决了。</p>
<p>&emsp;小编就因为遇到过这种情况，所以在这里分享一下在写完博客之后，运行命令的时候遇到的问题的解决方案。</p>
<h3 id="6-6-写博客"><a href="#6-6-写博客" class="headerlink" title="6.6 写博客"></a>6.6 写博客</h3><p>&ensp; &ensp;定位到我们的hexo根目录，执行命令：</p>
<blockquote>
<p>hexo new  ‘xxx’ (xxx就是你的博客名字)</p>
</blockquote>
<blockquote>
<p>hexo会帮我们在e:/hexo/source/_posts下生成相关md文件：</p>
</blockquote>
<p>&ensp; &ensp;我们只需要打开这个文件就可以开始写博客了,具体用什么打开md格式的文件进行编写博客，小编这里使用的是Typora（或者vscode也行）兼容md格式，这个大家可以自己使用喜欢的编辑器就行了，没有什么特殊要求，只要能兼容Markdown格式的就行了。</p>
<p>&ensp; &ensp;记住奥，每次写完博客记得，在你的hexo根目录下 git bash here，再进行</p>
<blockquote>
<p>hexo clean</p>
</blockquote>
<blockquote>
<p>hexo s -g</p>
</blockquote>
<p>&ensp; &ensp;进行本地预览要是符合自己想要的样子之后,再进行 </p>
<blockquote>
<p>hexo d</p>
</blockquote>
<p>&ensp; &ensp;最后打开你的<code>http://pengzihao166.github.io</code>(记得把pengzihao166改成你自己的github的用户名)，如果你绑定了域名你也可以直接输入你自己的域名进入一个属于自己的blog。</p>
<h2 id="结束语："><a href="#结束语：" class="headerlink" title="结束语："></a>结束语：</h2><p>&ensp; &ensp;这次运用hexo+git搭建博客，不知道你们是否学会了呢，要是内容含任何的错误知识点，请及时联系小编，或者在下方进行评论提出，方便小编及时修改错误，免得对其他小伙伴的学习造成勿扰，当然有什么观点也可以在评论中表达出来，希望大家可以参与到其中来。</p>
<p>&ensp; &ensp;部分内容转载自<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">小茗同学博客园</a>,如有侵权，请立刻联系小编，进行修改完善。</p>
]]></content>
      <tags>
        <tag>Git+Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>微布开发-上传多张图片控制上传顺序</title>
    <url>/2023/08/04/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%B8%8A%E4%BC%A0%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%BC%A0%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="开发思路："><a href="#开发思路：" class="headerlink" title="开发思路："></a>开发思路：</h3><p>串行上传：在前端逐个上传图片，并等待上一个图片上传成功后再上传下一个图片，以保持上传顺序。</p>
<blockquote>
<p>刚开始开发是通过一个for循环依次上传，没有考虑到可能因为图片大小、网络等原因导致后端返回的url顺序不一致，可以理解成多并发上传的时候而导致的顺序问题</p>
</blockquote>
<h3 id="代码大致实现："><a href="#代码大致实现：" class="headerlink" title="代码大致实现："></a>代码大致实现：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">uploadAllPics</span>(<span class="params">selectedImages, index</span>) &#123;</span><br><span class="line"><span class="comment">//fileListPicStorage 和fileList 都是用于展示组件的时候用的，主要就是存储上传之后的图片url</span></span><br><span class="line">  <span class="keyword">const</span> &#123; fileListPicStorage = [] &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="keyword">const</span> &#123; fileList = [] &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= selectedImages.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 所有图片上传完成</span></span><br><span class="line">      <span class="title function_">resolve</span>()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(selectedImages)</span><br><span class="line">    <span class="keyword">const</span> image = selectedImages[index]</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(image)</span><br><span class="line">    wx.<span class="title function_">uploadFile</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: app.<span class="property">globalData</span>.<span class="property">url</span> + app.<span class="property">globalData</span>.<span class="property">apiVersion</span> + <span class="string">&#x27;/upload&#x27;</span>, <span class="comment">// 替换成后端上传接口的URL</span></span><br><span class="line">      <span class="attr">filePath</span>: image.<span class="property">url</span>, <span class="comment">// 图片文件的本地路径</span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;file&#x27;</span>, <span class="comment">// 后端接收图片的字段名</span></span><br><span class="line">      <span class="attr">header</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span>,</span><br><span class="line">        <span class="attr">token</span>: wx.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;token&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 图片上传成功后的处理</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;图片上传成功&#x27;</span>, res)</span><br><span class="line">        <span class="keyword">let</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(res.<span class="property">data</span>)</span><br><span class="line">        fileList.<span class="title function_">push</span>(data.<span class="property">data</span>.<span class="property">result</span>)</span><br><span class="line">        fileListPicStorage.<span class="title function_">push</span>(&#123;</span><br><span class="line">          <span class="attr">url</span>:</span><br><span class="line">            <span class="string">&#x27;******&#x27;</span> +<span class="comment">//****代表图片url的前半部分，因为后端返回的都是后半部分url，需要前端自己补上前半部分的url</span></span><br><span class="line">            data.<span class="property">data</span>.<span class="property">result</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; fileList, fileListPicStorage &#125;)</span><br><span class="line">        <span class="comment">// 继续上传下一张图片</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">uploadAllPics</span>(selectedImages, index + <span class="number">1</span>)</span><br><span class="line">          .<span class="title function_">then</span>(resolve)</span><br><span class="line">          .<span class="title function_">catch</span>(reject)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">fail</span>: <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理上传失败情况</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;图片上传失败&#x27;</span>, error)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续上传下一张图片</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">uploadAllPics</span>(selectedImages, index + <span class="number">1</span>)</span><br><span class="line">          .<span class="title function_">then</span>(resolve)</span><br><span class="line">          .<span class="title function_">catch</span>(reject)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//选择照片就上传9张照片</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">afterRead</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  app.<span class="title function_">showLoading</span>(<span class="string">&#x27;图片上传中&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">//获取照片本地位置的文件数组</span></span><br><span class="line">  <span class="comment">//console.log(event)</span></span><br><span class="line">  <span class="keyword">const</span> &#123; file &#125; = event.<span class="property">detail</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(file)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//选择完并点击确认之后开始上传图片</span></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadAllPics</span>(file, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有图片上传完成&#x27;</span>)</span><br><span class="line">    wx.<span class="title function_">hideLoading</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;图片上传失败&#x27;</span>, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>微布开发-二手市场开发思路(小程序+Java后端)</title>
    <url>/2023/07/23/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="小程序端："><a href="#小程序端：" class="headerlink" title="小程序端："></a>小程序端：</h3><h4 id="相关参数："><a href="#相关参数：" class="headerlink" title="相关参数："></a>相关参数：</h4><ul>
<li>allList：全部商品列表</li>
<li>askBuyList：求购商品列表</li>
<li>sellLis：出售商品列表</li>
</ul>
<h4 id="开发思路如下："><a href="#开发思路如下：" class="headerlink" title="开发思路如下："></a>开发思路如下：</h4><h5 id="物品列表拉取："><a href="#物品列表拉取：" class="headerlink" title="物品列表拉取："></a>物品列表拉取：</h5><ol>
<li>默认获取全部所有的商品list用于初始化加载页面</li>
<li>滑动一级分类，确认一级分类type类型<ol>
<li>Type = 转卖<ol>
<li>初始化<ol>
<li>默认转卖一级分类的所有商品列表</li>
<li>滑动到二级分类，根据二级分类类型对应的categoryBid拉取列表</li>
</ol>
</li>
<li>下拉刷新<ol>
<li>若为一级分类的所有商品列表，categoryBid = null</li>
<li>若具体到二级分类的具体类型，categoryBid = 对应的二级分类bid</li>
</ol>
</li>
<li>上滑加载<ol>
<li>根据一级分类和二级分类(categoryBid )的类别确定获取什么类型的list并且赋值到allList/sellList/askBuyList</li>
</ol>
</li>
</ol>
</li>
<li>Type = 求购<ol>
<li>初始化<ol>
<li>默认求购一级分类的所有商品列表</li>
<li>滑动到二级分类，根据二级分类类型对应的categoryBid拉取列表</li>
</ol>
</li>
<li>下拉刷新<ol>
<li>若为一级分类的所有商品列表，categoryBid = null</li>
<li>若具体到二级分类的具体类型，categoryBid = 对应的二级分类bid</li>
</ol>
</li>
<li>上滑加载<ol>
<li>根据一级分类和二级分类的类别确定获取什么类型的list并且赋值到allList/sellList/askBuyList</li>
</ol>
</li>
</ol>
</li>
<li>一级分类切换的时候由于默认的是一级分类的所有商品列表拉取，所以一级分类切换的时候，修改对应的二级分类bid为空，不然切换的时候就相当于执行了<code>select * from hand where type = &#39;***&#39; and categoryBid = &#39;***&#39; order by id desc</code>;</li>
</ol>
</li>
</ol>
<p>发布、删除、编辑操作，根据接口以及业务场景传递对应的参数即可。其中可能需要对部分参数进行参数校验、长度限制等，前后端都会做限制。</p>
<h4 id="物品详情："><a href="#物品详情：" class="headerlink" title="物品详情："></a>物品详情：</h4><p>物品名、物品介绍、物品照片、物品价格、交易地址、物品数量、物品类型、其他联系方式：QQ/微信</p>
<h3 id="Java后端："><a href="#Java后端：" class="headerlink" title="Java后端："></a>Java后端：</h3><h4 id="表结构设计：（仅展示部分必要字段，可根据自己的需求自定义设计其他字段）"><a href="#表结构设计：（仅展示部分必要字段，可根据自己的需求自定义设计其他字段）" class="headerlink" title="表结构设计：（仅展示部分必要字段，可根据自己的需求自定义设计其他字段）"></a>表结构设计：（仅展示部分必要字段，可根据自己的需求自定义设计其他字段）</h4><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/512ac4e3ee94e9c20c6b7733cfdc8e9.png" alt="512ac4e3ee94e9c20c6b7733cfdc8e9"></p>
<h4 id="开发思路："><a href="#开发思路：" class="headerlink" title="开发思路："></a>开发思路：</h4><h5 id="获取商品列表-详情（都是封装在一个接口，根据根据不同场景，前端传的参数不一样，获取不同的查询结果）："><a href="#获取商品列表-详情（都是封装在一个接口，根据根据不同场景，前端传的参数不一样，获取不同的查询结果）：" class="headerlink" title="获取商品列表/详情（都是封装在一个接口，根据根据不同场景，前端传的参数不一样，获取不同的查询结果）："></a><strong>获取商品列表/详情</strong>（都是封装在一个接口，根据根据不同场景，前端传的参数不一样，获取不同的查询结果）：</h5><ol>
<li>校验用户身份，主要是从userBid、schoolBid以及token是否被篡改方向进行校验。</li>
<li>根据条件筛选结果。<ol>
<li>全部商品：根据id进行倒序分页查询，主要参数：商品主键id</li>
<li>根据type类型（确定是转卖/求购）<ol>
<li>二级分类查询：使用andCategoryBidsEqualTo方法实现匹配，分页返回list，主要参数：type（求购/转卖）+categorybid（二级分类类别id）</li>
</ol>
</li>
<li>查询某物品的详情：根据targetBid字段，进行where子句查询，获取返回结果，参数：targetBid(需要查询的物品的主键id)</li>
<li>关键字模糊查询：根据传过来的关键字进行左右模糊查询，<strong>但是因为索引遇到左右模糊查询的时候会出现索引失效，所以后面可能需要通过<strong><strong>es</strong></strong>组件优化模糊查询速率。</strong></li>
<li>查询自己发布过的商品：根据用户id进行where子句查询，获取返回结果，主要参数：tagetUserBid</li>
</ol>
</li>
<li>返回操作码以及结果</li>
</ol>
<h5 id="添加商品"><a href="#添加商品" class="headerlink" title="添加商品"></a><strong>添加商品</strong></h5><ol>
<li>校验用户身份。</li>
<li>身份校验成功，进行添加操作：<ol>
<li>判断必传参数：type、地址、联系方式、物品的名字、二级分类类别id、出售/求购价格、物品描述、是否同步到说说（<strong>后续可以改成异步操作防止主线程阻塞</strong>）、物品数量</li>
<li>可选择性传递参数：物品照片url</li>
</ol>
</li>
<li>存入数据库</li>
<li>返回操作码以及状态</li>
</ol>
<h5 id="删除商品"><a href="#删除商品" class="headerlink" title="删除商品"></a>删除商品</h5><ol>
<li>校验用户身份。</li>
<li>判断传递参数是否有效：<ol>
<li>判断商品id是否为空</li>
<li>判断商品是否存在</li>
<li>判断是不是本人操作</li>
</ol>
</li>
<li>进行软删操作，即设置isdelete=1并更新数据库</li>
<li>返回操作码及结果</li>
</ol>
<h5 id="更新商品信息："><a href="#更新商品信息：" class="headerlink" title="更新商品信息："></a>更新商品信息：</h5><ol>
<li>校验用户信息</li>
<li>判断参数是否有效<ol>
<li>判断请求参数是否为空</li>
<li>判断是否有此商品信息</li>
<li>判断是不是本人操作</li>
</ol>
</li>
<li>进行相关参数更新操作</li>
<li>返回操作码及结果</li>
</ol>
<h5 id="联系他人："><a href="#联系他人：" class="headerlink" title="联系他人："></a>联系他人：</h5><p>联系他人涉及：扣除发起者能量值、</p>
]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>微布开发-优化UGC消息拉取响应速度</title>
    <url>/2023/08/09/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%BC%98%E5%8C%96UGC%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a><strong>业务场景：</strong></h3><p>小程序端消息通知tab页中点赞通知列表、新粉丝通知列表、评论通知列表等UGC消息接口响应速度高达7s左右，经排查问题优化之后响应时间从7s优化至200ms以内，效果展示图如下：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/21e92934251b02be0db37da32b9fb0d.png" alt="21e92934251b02be0db37da32b9fb0d"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/04311382a71018148382f9092cfdc5f.png" alt="04311382a71018148382f9092cfdc5f"></p>
<h3 id="问题分析及排查："><a href="#问题分析及排查：" class="headerlink" title="问题分析及排查："></a><strong>问题分析及排查：</strong></h3><ol>
<li>索引问题？</li>
</ol>
<p>刚开始以为是数据量太大且没有添加索引导致查询速度很慢从而导致接口反映速度很慢，但是一看数据量也不是很大，而且也有通过添加索引（是通过receiverBid（接受者的主键id）创建）的手段，并且通过<code>explain</code>语句分析我所写的语句走了索引，因此排除索引问题。</p>
<ol start="2">
<li>业务逻辑代码问题？</li>
</ol>
<p>后面去查看业务代码、发现业务代码中除了分页查询UGC消息列表、还有一个同步的修改UGC消息读取状态的操作，也就是当用户拉取了UGC消息之后，将未读的记录转变成已读状态，一看到这里发现是两个同步操作，就赶紧通过<strong>打日志的方式</strong>判断查询操作和修改操作所耗时间，来进一步确定究竟是哪里出了问题，查看日志发现真的是因为修改操作耗时太多（为什么MySQL写操作比读操作慢？）导致的，我当时就想到了两个思路：</p>
<p>​    1、通过一个事务来进行批量的修改操作，不过还是采取同步，但是我感觉这样如果批量同步修改的话，如果修改的数据太多，可能效率没太大提升</p>
<p>​    2、就是在批量操作的基础上采用异步的方式，让这个修改操作打入kafka中异步，进一步提高接口响应速率。</p>
<ol start="3">
<li>如果异步修改操作失败怎么办？根据什么判断失败？</li>
</ol>
<p>可以根据Mybatis的Example类update方法返回的int值进行判断，如果大于0说明操作成功如果小于0则采取重试机制，重新打入kafka进行重新消费，至于重试次数的控制由redis来记录控制重试次数</p>
<h3 id="开发思路："><a href="#开发思路：" class="headerlink" title="开发思路："></a>开发思路：</h3><p>1、根据前端穿过来的参数进行查询UGC消息列表操作，并筛选出status字段是UNREAD状态的记录传给kafka生产者的业务逻辑方法。</p>
<p>2、编写kafka生产者将修改操作的消息写入kafka，并编写消费者对这个消息进行消费。</p>
]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>微布开发-实现说说审核发布机制(暂未完成)</title>
    <url>/2023/08/09/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%AE%9E%E7%8E%B0%E8%AF%B4%E8%AF%B4%E5%AE%A1%E6%A0%B8%E5%8F%91%E5%B8%83%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h3><p>调用微信三方接口进行图片/视频安全校验，由于微信的视频/图片校验结果是异步返回到服务端的接口，所以需要将附有照片或者视频的说说审核通过之后再将说说发布到论坛中。</p>
<h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><p>1、如何标识所有图片/视频审核完成之后再发布呢？</p>
<p>因为每次向微信的接口发送请求的时候，会对每张照片的审核都会有一个任务id(trace_id)，根据这个traceid映射对应的is_valid（标识是否校验通过）和talkbid（说说的主键id）字段来标识</p>
<ol>
<li>单独拉一张表出来存储图片url和trace_id的关系，然后用一个is_valid字段根据微信接口异步返回的结果标识判断是否校验通过，如果校验通过is_valid就变成1，还在校验过程中或者校验未通过就标识0。</li>
<li>使用Redis通过设置超时时间来使标识自动淘汰，释放内存空间</li>
<li>在说说表添加一个trace_id字段，存储每张照片的trace_id，并用逗号分隔开，每次微信异步返回结果之后如果审核通过就把trace_id和返回过来的trace_id部分删除，否则就不删除，同时判断此时trace_id字段是否为空，如果等于空值了，那么就说明全部校验通过了、然后将说说详情中的is_delete(说说软删标识)字段设为0，展示到社区论坛中。</li>
</ol>
<p>3、以上标识方法会有什么问题呢？为什么最终选用对说说详情表添加字段的方式进行标识呢？</p>
<p>第一种方法，需要单独创建一个表，会占用一定的磁盘空间，以及MySQL需要花费更大的空间进行维护造成一定的资源浪费。</p>
<p>第二种方法，Redis是基于内存的一种缓存数据库，如果当有大量的io操作的时候，就会占用内存空间，这个时候很可能会出现Redis崩盘的情况，甚至说Redis宕机，因为微布校园现在是单体架构，暂时无解，只能放弃这个想法了。</p>
<p>第三种方法，毕竟只是添加一个字段，MySQL的维护成本相对第一种就比较低了，对于第二种方案，数据的读取，MySQL 通常会使用缓冲池（Buffer Pool）来管理数据在内存中的存储。数据会根据需要从磁盘加载到缓冲池中，并且在查询时尽量从缓冲池中读取数据，从而避免频繁的磁盘 I/O 操作。如果数据在缓冲池中已经存在，查询时可以直接从内存中读取，这比从磁盘读取要快得多。反正在读取的时候，要用缓冲池的机制将数据放到内存中，再从缓冲池中读取数据，这样相对单独用Redis去维护标识会好很多。</p>
]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>微布开发-将说说记录的图片url单独提出来用一个表存储的设计</title>
    <url>/2023/08/07/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%B0%86%E8%AF%B4%E8%AF%B4%E8%AE%B0%E5%BD%95%E7%9A%84%E5%9B%BE%E7%89%87url%E5%8D%95%E7%8B%AC%E6%8F%90%E5%87%BA%E6%9D%A5%E7%94%A8%E4%B8%80%E4%B8%AA%E8%A1%A8%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p>这样的目的是为了后续方便说说附带的图片进行修改以及调用三方接口校验图片是否违规。</p>
<p><strong>大概表设计如下：</strong></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/622ed5483de15a276879cab129b21cb.png" alt="622ed5483de15a276879cab129b21cb"></p>
<p><strong>怎么转移说说表的pics字段的****url</strong> <strong>到新的y_talk_images字段呢？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> y_talk_images (talk_bid, images_url, user_bid, trace_id, is_valid, is_delete, create_time)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    bid,</span><br><span class="line">    SUBSTRING_INDEX(SUBSTRING_INDEX(pics, <span class="string">&#x27;,&#x27;</span>, numbers.n), <span class="string">&#x27;,&#x27;</span>, <span class="number">-1</span>) <span class="keyword">AS</span> images_url,</span><br><span class="line">    y_talk.user_bid,</span><br><span class="line">    <span class="keyword">NULL</span> <span class="keyword">AS</span> trace_id,</span><br><span class="line">    <span class="number">1</span> <span class="keyword">AS</span> is_valid,</span><br><span class="line">    <span class="number">0</span> <span class="keyword">AS</span> is_delete,</span><br><span class="line">    y_talk.create_time <span class="comment">-- 使用此图片对应的说说创建时间作为创建时间</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="number">1</span> n <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">2</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">3</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">4</span></span><br><span class="line">     <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">5</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">6</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">7</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">8</span></span><br><span class="line">     <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">9</span>) numbers</span><br><span class="line"><span class="keyword">JOIN</span> y_talk <span class="keyword">ON</span> <span class="keyword">CHAR_LENGTH</span>(pics) <span class="operator">-</span> <span class="keyword">CHAR_LENGTH</span>(REPLACE(pics, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) <span class="operator">&gt;=</span> numbers.n <span class="operator">-</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    pics <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">AND</span> pics <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> y_talk_images (</span><br><span class="line">	id <span class="type">INT</span> ( <span class="number">11</span> ) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">	image_bid <span class="type">VARCHAR</span> ( <span class="number">255</span> ) COMMENT <span class="string">&#x27;图片的主键id&#x27;</span>,</span><br><span class="line">	talk_bid <span class="type">VARCHAR</span> ( <span class="number">255</span> ) COMMENT <span class="string">&#x27;此图片对应的说说的主键id&#x27;</span>,</span><br><span class="line">	images_url <span class="type">VARCHAR</span> ( <span class="number">1024</span> ) COMMENT <span class="string">&#x27;图片的url&#x27;</span>,</span><br><span class="line">	user_bid <span class="type">VARCHAR</span> ( <span class="number">255</span> ) COMMENT <span class="string">&#x27;发布者的主键id&#x27;</span>,</span><br><span class="line">	open_id <span class="type">VARCHAR</span> ( <span class="number">255</span> ) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;微信id&#x27;</span>,</span><br><span class="line">	trace_id <span class="type">VARCHAR</span> ( <span class="number">50</span> ) COMMENT <span class="string">&#x27;每张照片微信接口校验时返回的任务id&#x27;</span>,</span><br><span class="line">	is_valid <span class="type">INT</span> ( <span class="number">1</span> ) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;是否通过校验，0待审核，1审核通过，2审核不通过&#x27;</span>,</span><br><span class="line">	is_delete <span class="type">INT</span> ( <span class="number">1</span> ) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;图片url是否被软删除&#x27;</span>,</span><br><span class="line">	create_time datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">PRIMARY KEY</span> ( `id` ) <span class="keyword">USING</span> BTREE </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>微布开发-微信三方接口文本校验校验开发思路</title>
    <url>/2023/05/27/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%BE%AE%E4%BF%A1%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E6%96%87%E6%9C%AC%E6%A0%A1%E9%AA%8C%E6%A0%A1%E9%AA%8C%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="根据文档要求总结分为以下的情况："><a href="#根据文档要求总结分为以下的情况：" class="headerlink" title="根据文档要求总结分为以下的情况："></a>根据文档要求总结分为以下的情况：</h3><ol>
<li>文本内容正常 (suggest: “pass”, label: 100)：<ol>
<li>情况处理：如果文本内容被判定为正常，可以允许发布该文本内容。</li>
</ol>
</li>
<li>文本内容命中关键词，但不违规 (suggest: “pass”, label: 20006)：<ol>
<li>情况处理：如果文本内容命中自定义关键词但不违规，可以允许发布该文本内容，同时可能根据需要记录命中的关键词和概率信息。</li>
</ol>
</li>
<li>文本内容建议审核 (suggest: “review”)：<ol>
<li>情况处理：如果文本内容被建议进行审核，您可以将该内容设置为待审核状态，让人工审核来决定是否发布该内容。</li>
</ol>
</li>
<li>文本内容命中违规标签 (suggest: “risky”)：<ol>
<li>情况处理：如果文本内容被判定为违规，应禁止发布该内容，并通知用户违规原因。</li>
</ol>
</li>
<li>文本内容属于广告 (label: 10001)：<ol>
<li>情况处理：如果文本内容被判定为广告，应禁止发布该内容，并通知用户不允许发布广告内容。</li>
</ol>
</li>
<li>文本内容属于色情、辱骂、违法犯罪等 (label: 20002, 20003, 20006等)：<ol>
<li>情况处理：如果文本内容被判定为色情、辱骂、违法犯罪等，应禁止发布该内容，并根据需要采取进一步的处理措施，比如记录日志或进行用户封禁等。</li>
</ol>
</li>
</ol>
<h3 id="开发思路如下："><a href="#开发思路如下：" class="headerlink" title="开发思路如下："></a>开发思路如下：</h3><ol>
<li>从Redis中获取到AccessToken</li>
<li>查库获取发布者微信的openid</li>
<li>调用<a href="https://api.weixin.qq.com/wxa/msg_sec_check?access_token=%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%A0%A1%E9%AA%8C%E8%BF%94%E5%9B%9E%E5%8F%82%E6%95%B0">https://api.weixin.qq.com/wxa/msg_sec_check?access_token=接口，校验返回参数</a><ol>
<li>errocode == 0<ol>
<li>获取result对象的suggest参数值并进行比较<ol>
<li>如果文本内容建议审核，则根据实际需求执行人工审核流程，”review”.equals(suggest)</li>
<li>如果文本内容正常或命中关键词但不违规，允许发布，”pass”.equals(suggest)</li>
<li>如果文本内容被判定为违规，禁止发布，并输出违规信息，”risky”.equals(suggest)<ol>
<li>此时可以遍历detail数组，并获取对应的prob如果其中有敏感词汇prob&gt;50就不准发布。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="大致代码逻辑如下："><a href="#大致代码逻辑如下：" class="headerlink" title="大致代码逻辑如下："></a>大致代码逻辑如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(String result)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">JSONObject</span> <span class="variable">responseJson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(result);</span><br><span class="line">          <span class="type">int</span> <span class="variable">errcode</span> <span class="operator">=</span> responseJson.getInt(<span class="string">&quot;errcode&quot;</span>);</span><br><span class="line">          <span class="type">String</span> <span class="variable">errmsg</span> <span class="operator">=</span> responseJson.getString(<span class="string">&quot;errmsg&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (errcode == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 获取综合结果信息</span></span><br><span class="line">              <span class="type">JSONObject</span> <span class="variable">resultObject</span> <span class="operator">=</span> responseJson.getJSONObject(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">              <span class="type">String</span> <span class="variable">suggest</span> <span class="operator">=</span> resultObject.getString(<span class="string">&quot;suggest&quot;</span>);</span><br><span class="line">              <span class="type">int</span> <span class="variable">label</span> <span class="operator">=</span> resultObject.getInt(<span class="string">&quot;label&quot;</span>);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 输出综合结果信息</span></span><br><span class="line">              System.out.println(<span class="string">&quot;综合结果：&quot;</span>);</span><br><span class="line">              System.out.println(<span class="string">&quot;建议：&quot;</span> + suggest);</span><br><span class="line">              System.out.println(<span class="string">&quot;标签：&quot;</span> + label);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果文本内容建议审核，则根据实际需求执行人工审核流程</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="string">&quot;review&quot;</span>.equals(suggest)) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;该文本内容建议进行人工审核！&quot;</span>);</span><br><span class="line">                  <span class="comment">// 可以将内容设置为待审核状态，由人工审核决定是否发布</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;pass&quot;</span>.equals(suggest)) &#123;</span><br><span class="line">                  <span class="comment">// 如果文本内容正常或命中关键词但不违规，允许发布</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;文本内容合规，可以发布！&quot;</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;risky&quot;</span>.equals(suggest)) &#123;</span><br><span class="line">                  <span class="comment">// 如果文本内容被判定为违规，禁止发布，并输出违规信息</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;文本内容违规，请修改后重新提交！&quot;</span>);</span><br><span class="line">                  <span class="type">JSONArray</span> <span class="variable">detailArray</span> <span class="operator">=</span> responseJson.getJSONArray(<span class="string">&quot;detail&quot;</span>);</span><br><span class="line">                  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; detailArray.length(); i++) &#123;</span><br><span class="line">                      <span class="type">JSONObject</span> <span class="variable">detailObject</span> <span class="operator">=</span> detailArray.getJSONObject(i);</span><br><span class="line">                      <span class="type">String</span> <span class="variable">strategy</span> <span class="operator">=</span> detailObject.getString(<span class="string">&quot;strategy&quot;</span>);</span><br><span class="line">                      <span class="keyword">if</span> (<span class="string">&quot;keyword&quot;</span>.equals(strategy)) &#123;</span><br><span class="line">                          <span class="type">String</span> <span class="variable">keyword</span> <span class="operator">=</span> detailObject.getString(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">                          <span class="type">int</span> <span class="variable">prob</span> <span class="operator">=</span> detailObject.getInt(<span class="string">&quot;prob&quot;</span>);</span><br><span class="line">                          System.out.println(<span class="string">&quot;命中关键词：&quot;</span> + keyword + <span class="string">&quot;，概率：&quot;</span> + prob);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;未知建议类型：&quot;</span> + suggest);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 输出错误信息</span></span><br><span class="line">              System.out.println(<span class="string">&quot;接口调用失败，错误码：&quot;</span> + errcode + <span class="string">&quot;，错误信息：&quot;</span> + errmsg);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;接口调用失败！&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>微布开发-热点动态缓存击穿</title>
    <url>/2023/08/20/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E7%83%AD%E7%82%B9%E5%8A%A8%E6%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</url>
    <content><![CDATA[<h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h3><p>热点动态中的某一条说说因为过期且当时大量用户请求查看动态详情，出现数据库查询压力骤增的情况，从而导致某一热点动态的缓存击穿的情况。</p>
<h3 id="想法："><a href="#想法：" class="headerlink" title="想法："></a>想法：</h3><p>1、 互斥锁：在热点数据的缓存失效时，可以尝试使用分布式锁来避免多个请求同时访问数据库。在获取锁的情况下，只有一个请求去加载数据并更新缓存，其他请求等待，从而减轻数据库的压力。</p>
<ol>
<li><strong>获取互斥锁：</strong> 当缓存失效时，多个请求会尝试获取一个互斥锁。如果只有一个请求能够成功获取锁，那么它将负责加载数据并更新缓存。</li>
<li><strong>获取锁成功：</strong> 如果某个请求成功获取了互斥锁，它可以开始加载数据。在加载数据时，需要判断缓存是否已经被其他请求加载（可能在当前请求获取锁的过程中被其他请求加载了），避免重复加载数据。</li>
<li><strong>更新缓存：</strong> 获取锁成功的请求负责加载数据并更新缓存。在更新缓存之后，释放互斥锁，让其他等待锁的请求有机会获取锁并使用更新后的缓存。</li>
<li><strong>获取锁失败：</strong> 如果请求获取锁失败，意味着其他请求已经在加载数据和更新缓存了。这些失败的请求可以等待一段时间后再次尝试，或者直接返回默认值，以避免多次同时访问数据库。</li>
</ol>
<h3 id="伪代码如下："><a href="#伪代码如下：" class="headerlink" title="伪代码如下："></a>伪代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheWithMutexLock</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, T&gt; redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheWithMutexLock</span><span class="params">(RedisTemplate&lt;String, T&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getOrLoadFromCache</span><span class="params">(String key, Supplier&lt;T&gt; dataLoader, T defaultValue, <span class="type">long</span> lockTimeout)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_PREFIX + key;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取互斥锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">gotLock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(lockKey, <span class="string">&quot;locked&quot;</span>, lockTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (gotLock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 检查缓存是否已经加载</span></span><br><span class="line">                    <span class="type">T</span> <span class="variable">cachedValue</span> <span class="operator">=</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">                    <span class="keyword">if</span> (cachedValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> cachedValue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 加载数据并更新缓存</span></span><br><span class="line">                    <span class="type">T</span> <span class="variable">loadedValue</span> <span class="operator">=</span> dataLoader.get();</span><br><span class="line">                    redisTemplate.opsForValue().set(key, loadedValue);</span><br><span class="line">                    <span class="keyword">return</span> loadedValue;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    redisTemplate.delete(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取锁失败，返回默认值</span></span><br><span class="line">                <span class="keyword">return</span> defaultValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> defaultValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>getOrLoadFromCache</code> 方法尝试获取互斥锁，如果获取成功，它会检查缓存是否已经加载数据，如果没有则加载数据并更新缓存。如果获取锁失败，就直接返回默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RedisTemplate&lt;String, String&gt; redisTemplate = ...; <span class="comment">// 初始化 RedisTemplate</span></span><br><span class="line">CacheWithMutexLock&lt;String&gt; cache = <span class="keyword">new</span> <span class="title class_">CacheWithMutexLock</span>&lt;&gt;(redisTemplate);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;my_key&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> cache.getOrLoadFromCache(key, </span><br><span class="line">    () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 从数据库或其他数据源加载数据的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Loaded data&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;Default value&quot;</span>,</span><br><span class="line">    <span class="number">5000</span> <span class="comment">// 互斥锁的超时时间，单位为毫秒</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>RedisTemplate</code> 的一个简化实现。使用互斥锁来协调多个请求的数据加载和缓存更新，可以避免缓存击穿问题。</p>
]]></content>
      <tags>
        <tag>微布开发总结</tag>
      </tags>
  </entry>
  <entry>
    <title>最近的成长</title>
    <url>/2022/07/10/%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%90%E9%95%BF/</url>
    <content><![CDATA[<p>&emsp;&emsp;你好，我是小八，好久不见，不知不觉停更我的<a href="https://xiaobazeo.com/">blog</a>已经将近半年了，不知道的，可能是觉得大二下的我开始颓废了，我可以在这里说NO，你猜错了，我只是最近在闲暇之余花更多的时间在我前面<a href="https://xiaobazeo.com/2022/01/01/2021-backing/">一篇博客</a>提到的项目中——“微布校园”，我们团队开发了一款基于微信生态环境的微信小程序和APP——微布校园，目前也有很多我校大学生在使用我们的产品，而我负责的主要是小程序端开发和Java后端开发，算得上是个前后端啥都干的小菜鸡吧。</p>
<p>&emsp;&emsp;不知不觉，微布校园的诞生已经半年之久了，用户量也达到了我们的预期估计。在这段参与开发的过程中，通过向几个在大厂工作的学长请教，交流，我发现了很多开发过程中需要注意的小问题，而这些也丰富积累了我的开发经验。比如 刚开始学习使用mina框架开发小程序的我过于小白，其实有些icon只需要写一个class改变其样式即可，而我当时却给每个icon单独写了一个class样式，现在想起来都觉得自己真的好蠢啊，hhhhhhh~</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220710223856616.png" alt="小白受教ing"></p>
<p>&emsp;&emsp;还有这样的：当时还记得是因为我们开发的时候，提到了tcp协议，而我又看到过一篇博客说http3.0的TCP被弃用了，就开始了这个话题。。。当时还从计网知识转到了计组的相关探讨，hhhhhhh，而且我才知道一个安卓手机小知识，这里也分享给大家：安卓大多数手机用WiFi给电脑传数据，比用数据线快，因为很多手机接口用的USB2.0协议，虽然协议写的是60M，但一般2.0不超过30M</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220710223300695.png" alt="请教计网相关问题"></p>
<p>&emsp;&emsp;好在我们的不断努力下，微布校园APP和小程序都成功诞生啦~</p>
]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>小八学习git从0到基本运用</title>
    <url>/2021/11/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p style="text-indent:20px;">有一说一，刚刚步入计算机大二的我，这个Github在我的认知里面一直只是一个大牛从中copy代码的网站，我对其的了解也仅仅在于抖音的“黑马程序员”里面的人说的这个网站很多大牛，才会使用。</p>

<p>&emsp;&emsp;就在前几天，我收到了我的学长ConeZhang（名字都不透露了，后面简写：驰哥）给我发的几条信息。</p>
<span id="more"></span>
<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/我的第一篇博客/QQ%E5%9B%BE%E7%89%8720211204214135.jpg?versionId=CAEQFxiBgICF.t.W7BciIDEyZDZhNTYwMDY4YzRmYTliOWE3NDgyOGZkYzBhMWI3">

<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/我的第一篇博客/QQ%E5%9B%BE%E7%89%8720211204214217.jpg?versionId=CAEQFxiBgMCYhuCW7BciIDY5OWFiMDE2NGRiYzRkM2Q4MGNiYjg3M2MzMTI4YTY0">

<p>&emsp;&emsp;看到这些消息，我直接开心的起飞，不知道怎么用语言来形容了，当时内心OS：woc！！这可是同时拿到百度，腾讯，快手sp甚至ssp的offer，最后去了字节的大佬啊，能带上我做项目，什么概念！！我上辈子肯定积了不少德，哈哈哈哈，说到驰哥，真就是机缘巧合，我还记得我第一次跟驰哥有了联系方式居然就在我预科刚入校的时候，因为学校教务系统的密码，忘记了，然后通过多方路径找到了驰哥的联系方式，然后帮我修改了密码，正巧我打算大一选择的就是计算机专业。</p>
<p>&emsp;&emsp;好了好了，言归正传，就在2021-11-26 18：33 驰哥给我发来了消息，要我赶紧这个周末学习完成，收到这个任务，我立刻马上关闭了LOL，开始了Git煎熬之旅。</p>
<h3 id="Git的起源及比较："><a href="#Git的起源及比较：" class="headerlink" title="Git的起源及比较："></a>Git的起源及比较：</h3><p>&emsp;&emsp;我打开了驰哥发给我的学习网站，开始对Git的初步了解，发现原来Linux开发了Git及github网站，而Git与类似网站有不同之处就是，CVS以及SVN都是集中式的版本控制系统，但是Git是分布式的版本系统，但是集中式的系统最大毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要几十分钟，这还不得把人给憋死啊？</p>
<h3 id="Git的安装以及创建远程仓库："><a href="#Git的安装以及创建远程仓库：" class="headerlink" title="Git的安装以及创建远程仓库："></a>Git的安装以及创建远程仓库：</h3><p>&emsp;&emsp;个人觉得真没什么好说的，用大一老师lq老师说的，不会就给我多安装几次就会了，要是电脑出问题了，就重装系统，一举多得，还能自学安装系统，要是看到这个博客的小伙伴，不知道怎么去安装，可以上我b大，或者在<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰老师的网站</a>进行学习，实在还是不会，可以加我的QQ奥。</p>
<h2 id="Git的用法简介："><a href="#Git的用法简介：" class="headerlink" title="Git的用法简介："></a>Git的用法简介：</h2><h3 id="一、创建新的版本库"><a href="#一、创建新的版本库" class="headerlink" title="一、创建新的版本库"></a>一、创建新的版本库</h3><p>&emsp;&emsp;1.打开git bash找到一个非c盘的合适位置，来做创建一个空目录（我以d盘为例，创建一个文件夹learngit）<br>(输入语句里面含$)</p>
<blockquote>
<p>$mkdir /d/learngit</p>
</blockquote>
<blockquote>
<p>$cd /d/learngit</p>
</blockquote>
<blockquote>
<p>$pwd /d/learngit</p>
</blockquote>
<p>2.通过git init命令进行git仓库初始化</p>
<blockquote>
<p>$git init</p>
</blockquote>
<p>Initialized empty Git repository in D:/learngit/.git/</p>
<p>3.通过vi readme.txt创建一个新的文本框</p>
<blockquote>
<p>$vi readme.txt</p>
</blockquote>
<p>4.跳转到编辑界面，按下insert（ins）进行编辑，编辑完成之后按一下esc，再输入:wq进行退出(听我一个正在学Linux系统的室友告诉我，如果文档是只读的话，进行修改了的，就按:wq!进行强制退出)</p>
<p>5.用命令git commit告诉Git，把文件提交到仓库，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<blockquote>
<p>$git commit -m”wrote a readme file “</p>
</blockquote>
<p>[master (root-commit) df7ffd5] wrote a readme file</p>
<p> 1 file changed, 1 insertion(+)</p>
<p> create mode 100644 readme.txt</p>
<h3 id="二、其他基本命令的使用"><a href="#二、其他基本命令的使用" class="headerlink" title="二、其他基本命令的使用"></a>二、其他基本命令的使用</h3><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>&emsp;&emsp;1、git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：</p>
<blockquote>
<p>$ git log –pretty=oneline</p>
</blockquote>
<p>&emsp;&emsp;2、现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：</p>
<blockquote>
<p>$ git reset –hard HEAD^</p>
</blockquote>
<p>&emsp;&emsp;在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>
<p>&emsp;&emsp;3、最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>&emsp;&emsp;办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb…，于是就可以指定回到未来的某个版本：</p>
<blockquote>
<p>$ git reset –hard 1094a</p>
</blockquote>
<p>HEAD is now at 83b0afe append GPL</p>
<p>&emsp;&emsp;现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>&emsp;&emsp;在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</p>
<p>&emsp;&emsp;4、$ git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>
<h4 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h4><p>&emsp;&emsp;1、每次修改，如果不用git add到暂存区，那就不会加入到commit中。</p>
<p>&emsp;&emsp;2、git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：</p>
<p>diff –git a/readme.txt b/readme.txt<br>index 76d770f..a9c5755 100644<br>— a/readme.txt<br>+++ b/readme.txt<br>@@ -1,4 +1,4 @@<br> Git is a distributed version control system.<br> Git is free software distributed under the GPL.<br> Git has a mutable index called stage.<br>-Git tracks changes.<br>+Git tracks changes of files.</p>
<h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><blockquote>
<p>$ git status</p>
</blockquote>
<p>On branch master</p>
<p>Changes not staged for commit:</p>
<p>  (use “git add <file>…” to update what will be committed)</file></p>
<p>  (use “git checkout – <file>…” to discard changes in working directory)</file></p>
<pre><code>modified:   readme.txt
</code></pre>
<p>no changes added to commit (use “git add” and/or “git commit -a”)</p>
<p>你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改：</p>
<blockquote>
<p>$ git checkout – readme.txt</p>
</blockquote>
<p>2、现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：</p>
<p>庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：</p>
<p>Git同样告诉我们，用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</file></p>
<blockquote>
<p>$ git reset HEAD readme.txt</p>
</blockquote>
<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p>
<p>再用git status查看一下，现在暂存区是干净的，工作区有修改：</p>
<p>还记得如何丢弃工作区的修改吗？</p>
<blockquote>
<p>$ git checkout – readme.txt</p>
</blockquote>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>1、一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p>
<blockquote>
<p>$ rm test.txt</p>
</blockquote>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p>
<p>rm之后你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</p>
<blockquote>
<p>$ git rm test.txt</p>
</blockquote>
<p>rm ‘test.txt’</p>
<p>2、切记，在git rm 之后还需要提交commit才能从版本库中被删除</p>
<blockquote>
<p>$ git commit -m “remove test.txt”</p>
</blockquote>
<p>[master d46f35e] remove test.txt</p>
<p> 1 file changed, 1 deletion(-)</p>
<p> delete mode 100644 test.txt<br>现在，文件就从版本库中被删除了。</p>
<p>3、另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：（经实验，如果版本库里面也被rm了就无法恢复了）</p>
<blockquote>
<p>$ git checkout – test.txt</p>
</blockquote>
<h4 id="远程库的使用"><a href="#远程库的使用" class="headerlink" title="远程库的使用"></a>远程库的使用</h4><p>一、添加远程库</p>
<p>具体怎么添加，请小伙伴们，自行百度学习，具体实现就不说了，小编只在这里讲一下添加时候的一些命令：</p>
<p>1、在本次仓里面运行命令：</p>
<blockquote>
<p>$ git remote add origin <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;">&#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;</a>:pengzihao166/learngit.git</p>
</blockquote>
<p>注意：把上面的pengzihao166替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>2、下一步，就可以把本地库的所有内容推送到远程库上：</p>
<blockquote>
<p>$ git push -u origin master</p>
</blockquote>
<p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p>
<p>注意：由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>3、从现在起，只要本地作了提交，就可以通过命令：</p>
<blockquote>
<p>$ git push origin master</p>
</blockquote>
<p>二、删除远程库</p>
<p>1、如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm <name>命令。使用前，建议先用git remote -v查看远程库信息：</name></p>
<blockquote>
<p>$ git remote -v<br>origin  <a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;">&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;</a>:pengzihao166/learn-git.git (fetch)</p>
</blockquote>
<p>origin  <a href="mailto:&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;">&#x67;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#111;&#x6d;</a>:pengzihao166/learn-git.git (push)</p>
<p>然后，根据名字删除，比如删除origin：</p>
<blockquote>
<p>$ git remote rm origin</p>
</blockquote>
<p>三、从远程库克隆</p>
<p>1、准备好远程库</p>
<p>2、现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：</p>
<blockquote>
<p>$ git clone <a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#x69;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#109;</a>:pengzihao166/gitskills.git</p>
</blockquote>
<p>注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。</p>
<p>Git支持多种协议，包括https，但ssh协议速度最快。</p>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>一、创建并合并分支</p>
<p>创建命令：</p>
<blockquote>
<p>git switch -c ***</p>
</blockquote>
<p>合并命令：</p>
<blockquote>
<p>git merge ***</p>
</blockquote>
<p>注意：***是你想取的名字</p>
<p>二、分支管理策略</p>
<p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<p>例：</p>
<blockquote>
<p>$ git merge –no-ff -m “merge with no-ff” dev</p>
</blockquote>
<p>合并后，我们用git log看看分支历史：</p>
<blockquote>
<p>$ git log –graph –pretty=oneline –abbrev-commit</p>
</blockquote>
<p>二、bug和feature分支：</p>
<p>这两个分支总体来说用法都一样，就是在不同工作环境下使用的时间不一样，就拿bug来举例好了：</p>
<p>1、当你接到一个修复一个代号101的bug的任务时,当前正在dev上进行的工作还没有提交。</p>
<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<blockquote>
<p>$ git stash<br>Saved working directory and index state WIP on dev: f52c633 add merge</p>
</blockquote>
<p>2、返回到主分支master之后，再建立一个新的分支issue-101，在此分支上面进行readme.txt文档的修改已知bug（经自己的实验发现一个问题，原来如果vi文件完成之后你使用前面提到的:wq或者wq!或者ZZ命令会发现，你的文件直接被git add了，只需要直接commit）</p>
<blockquote>
<p>$ git add readme.txt </p>
</blockquote>
<blockquote>
<p>$ git commit -m “fix bug 101”</p>
</blockquote>
<p>[issue-101 a1d6694] fix bug 101</p>
<p>1 file changed, 1 insertion(+), 1 deletion(-)</p>
<p>3、再修改bug完成之后，返回到master分支，然后，再进行git merge –no-ff -m “merged bug fix 101” issue-101合并刚刚的issue-101分支修改的bug内容</p>
<p>4、然后就是跳转到先前的Dev分支上面，继续以前的工作，通过git stash list 查找到刚刚git stash存好的工作区的文件，恢复方法如下：<br>     输入git stash list</p>
<pre><code>  $ git stash list

      stash@&#123;0&#125;: WIP on dev:ecd2437add merge

   ①一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；

    另一种方式是用git stash pop，恢复的同时把stash内容也删了：
    
   ②$ git stash apply stash@&#123;0&#125;

      stash@&#123;0&#125;就是list显示的前缀名
</code></pre>
<p>5、同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。</p>
<p>为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支：</p>
<blockquote>
<p>$ git branch</p>
</blockquote>
<ul>
<li><p>dev（此时在dev分支上面）</p>
<p>master</p>
</li>
</ul>
<blockquote>
<p>$ git cherry-pick a1d6694</p>
</blockquote>
<p>[master 1d4b803] fix bug 101</p>
<p> 1 file changed, 1 insertion(+), 1 deletion(-)</p>
<h4 id="标签管理："><a href="#标签管理：" class="headerlink" title="标签管理："></a>标签管理：</h4><p>一、创建标签：</p>
<p>1、直接法：</p>
<blockquote>
<p>$ git branch</p>
</blockquote>
<ul>
<li>dev<br>master<blockquote>
<p>$ git checkout master</p>
</blockquote>
</li>
</ul>
<p>Switched to branch ‘master’</p>
<p>然后，敲命令git tag <name>就可以打一个新标签：</name></p>
<blockquote>
<p>$ git tag v1.0</p>
</blockquote>
<p>可以用命令git tag查看所有标签：</p>
<blockquote>
<p>$ git tag</p>
</blockquote>
<p>v1.0</p>
<p>2、默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：</p>
<blockquote>
<p>$ git log –pretty=oneline –abbrev-commit</p>
</blockquote>
<p>12a631b (HEAD -&gt; master, tag: v1.0, origin/master) </p>
<p>merged bug fix 101</p>
<p>4c805e2 fix bug 101</p>
<p>e1e9c68 merge with no-ff</p>
<p>f52c633 add merge</p>
<p>比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：</p>
<blockquote>
<p>$ git tag v0.9 f52c633</p>
</blockquote>
<p>再用命令git tag查看标签：</p>
<blockquote>
<p>$ git tag</p>
</blockquote>
<p>v0.9</p>
<p>v1.0</p>
<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show <tagname>查看标签信息：</tagname></p>
<blockquote>
<p>$ git show v0.9</p>
</blockquote>
<p>可以看到，v0.9确实打在add merge这次提交上。</p>
<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p>
<blockquote>
<p>$ git tag -a v0.1 -m “version 0.1 released” 1094adb</p>
</blockquote>
<p>用命令git show <tagname>可以看到说明文字：</tagname></p>
<blockquote>
<p>$ git show v0.1\</p>
</blockquote>
<p>二、操作标签</p>
<p>命令git push origin <tagname>可以推送一个本地标签；</tagname></p>
<p>命令git push origin –tags可以推送全部未推送过的本地标签；</p>
<p>命令git tag -d <tagname>可以删除一个本地标签；</tagname></p>
<p>命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</tagname></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&ensp; &ensp;今天的Git命令的使用，就到此结束了，要是有啥疑惑的小伙伴可以去自行百度或者加上我的联系方式，联系我奥。</p>
<p>&ensp; &ensp;部分内容转自<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰老师的网站</a>，如有侵权，请立刻联系小编进行修改完善。</p>
<pre><code>                                                              ---来自一个小白的真实学习笔记
</code></pre>
]]></content>
      <tags>
        <tag>Git+Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础篇</title>
    <url>/2023/05/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="TCP-IP网络模型有哪几层？"><a href="#TCP-IP网络模型有哪几层？" class="headerlink" title="TCP/IP网络模型有哪几层？"></a>TCP/IP网络模型有哪几层？</h2><h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><p>&emsp;&emsp;用户直接接触到的就是<strong>应用层</strong>，应用层专注于用户提供应用功能，例如：HTTP、FTP、DNS、Telnet、SMTP等。</p>
<p>&emsp;&emsp;应用层工作在操作系统中得<strong>用户态</strong>，<strong>传输层及以下</strong>则工作在<strong>内核态</strong>。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>&emsp;&emsp;应用层的数据包会传给传输层，传输层是为应用层提供网络支持。传输层的两个协议：<strong>TCP</strong>和<strong>UDP</strong>。</p>
<p>​    TCP（传输控制协议），TCP相较于UDP的特性，比如：<strong>流量控制，超时重传，拥塞控制</strong>等，为了保证数据包能可靠的传输给对方。</p>
<p>&emsp;&emsp;UDP只负责发送数据包，<strong>不保证</strong>数据包是否能抵达对方，但是<strong>实时性</strong>相对较好，<strong>传输效率</strong>也较高。如果要实现UDP的可靠传输，可以把TCP的特性在应用层实现。</p>
<p>&emsp;&emsp;应用传输数据过大，传输层的数据包大小超过MSS(TCP最大报文段长度)，需要将数据包分块，如果中途有一个分块丢失或损坏，只需重新发送此分块即可，而不需要发送整个数据包。在TCP协议中，<strong>每个分块称为一个TCP段</strong>（TCP Segment）。</p>
<p>&emsp;&emsp;传输层负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，此时需要用一个编号将应用区分开，这个编号就是端口。例如：Web服务器通常使用80端口，22端口通常是远程登录服务器的端口。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>&emsp;&emsp;实现传输功能的是<strong>网络层</strong>，传输层只是作为数据传输的媒介，帮助应用到应用的通信。</p>
<p>&emsp;&emsp;常见协议是IP协议（Internet Protocol），IP协议会将传输层的报文作为数据部分，再加上IP包头部组装成IP报文，如果IP报文大小超过MTU（一般默认1500Bytes）会<strong>再次进行分片</strong>，得到一个即将发送的到网络的IP报文。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/12.jpg" alt="选自小林coding"></p>
<h4 id="IP协议寻址功能："><a href="#IP协议寻址功能：" class="headerlink" title="IP协议寻址功能："></a>IP协议寻址功能：</h4><p>&emsp;&emsp;由于网络层需要有区分设备的编号，一般使用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分为四段（比如：192.168.100.1），每段8位。由于IPv4地址有设备上限，无法做到一个设备一个IP地址，所以会将IP地址分成两种意义：</p>
<ul>
<li>一个是<strong>网络号</strong>，负责标识该IP地址是属于哪个<strong>子网</strong>的</li>
<li>一个是<strong>主机号</strong>，负责标识<strong>同一子网</strong>下的<strong>不同主机</strong></li>
</ul>
<p>此时需要<strong>子网掩码</strong>才能计算出IP地址的网络号和主机号，比如：10.100.122.0/24，后面的/24表示就是255.255.255.0子网掩码，255.255.255.0二进制就是11111111-11111111-11111111-00000000，24个1，为了简化子网掩码的表示，就会用/24代替255.255.255.0</p>
<p><strong>网络号</strong>将 10.100.122.2 和 255.255.255.0 <strong>按位与运算</strong>。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/16.jpg" alt="取自小林coding"></p>
<p><strong>主机号：</strong>将 255.255.255.0 <strong>取反</strong>后与IP地址进行进行<strong>按位与运算</strong>。</p>
<p>在寻址过程中，先匹配相同的网络号（表示要找到同一个子网），才会去找对应的主机号。</p>
<h4 id="IP协议路由功能"><a href="#IP协议路由功能" class="headerlink" title="IP协议路由功能"></a>IP协议路由功能</h4><p>当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p>
<p>IP协议的寻址是告诉我们去往下一个目的地朝哪个方向走，路由是根据下一个目的地选择路径。</p>
<h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>网络接口层会在IP头部的前面加上MAC头部，并封装成数据帧发送到网络上。网络接口层主要是为网络层提供链路级别传输的服务，负责以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来表示网络上的设备。</p>
<p>MAC头部是以以太网的头部，包含了接收方和发送方的MAC地址等信息，可以通过ARP协议获取对方的MAC地址。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络接口层的传输单位是帧，IP的传输单位是包，TCP层传输单位是段，HTTP传输单位是消息或报文，每一层的封装格式如下：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="取自小林coding"></p>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈wx和wss</title>
    <url>/2023/02/02/%E8%B0%88%E8%B0%88wx%E5%92%8Cwss/</url>
    <content><![CDATA[<h2 id="了解WS和WSS"><a href="#了解WS和WSS" class="headerlink" title="了解WS和WSS"></a>了解WS和WSS</h2><p>&emsp;WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。</p>
<p>&emsp;WebSocket建立在TCP之上，同HTTP一样通过TCP来传输数据，但是它和HTTP最大不同是：WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/Client Agent都能主动的向对方发送或接收数据，就像Socket一样；WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。</p>
<p>&emsp;WSS（Web Socket Secure）是WebSocket的加密版本。WS一般默认是80端口，而WSS默认是443端口，大多数网站用的就是80和433端口。（在高防防护过程中，80和433端口的网站是需要备案才可以接入国内的。）</p>
<p>&emsp;WS体现形式：<strong>TCP+WS AS WS 。</strong></p>
<p>&emsp;WSS体现形式：<strong>TCP+TLS+WS AS WS。</strong></p>
<p>&emsp;服务器网址就是 URL。</p>
<h2 id="WS-WSS出现的原因"><a href="#WS-WSS出现的原因" class="headerlink" title="WS/WSS出现的原因"></a>WS/WSS出现的原因</h2><p>&emsp;目前很多应用要求服务端有能力进行实时推送能力（例如直播间聊天室），以往很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。</p>
<p>​    这种传统的模式带来很明显的缺点，即浏览器需要不断地向服务器发出请求，但是HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽资源。</p>
<p>​    此时，WebSocket协议的出现，能更好地节省服务器资源和带宽，并且能够更实时地进行通讯。WebSocket实现了浏览器与服务器全双工（full-duplex）通信，允许服务器主动发送信息给客户端。</p>
<h2 id="WS特点"><a href="#WS特点" class="headerlink" title="WS特点"></a>WS特点</h2><ul>
<li>建立在 TCP 协议之上，服务端实现容易；</li>
<li>与 HTTP 协议有良好的兼容性，握手时不容易被屏蔽，可以通过各种 HTTP 代理服务器；</li>
<li>数据轻量，实时通讯；</li>
<li>可以发送文本和二进制数据；</li>
<li>不限制同源，客户端可以与任意服务器端进行通讯。</li>
</ul>
<h2 id="和http-https的关系"><a href="#和http-https的关系" class="headerlink" title="和http/https的关系"></a>和http/https的关系</h2><p>按照标准来是有如下对应关系的：</p>
<ul>
<li>http -&gt; new WebSocket(‘ws://xxx’)</li>
<li>https -&gt; new WebSocket(‘wss://xxx’)</li>
</ul>
<p>在https下应该使用wss协议做安全链接，且wss下不支持ip地址的写法，写成域名形式。</p>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-七牛云测试开发实习一二面</title>
    <url>/2023/08/02/%E9%9D%A2%E7%BB%8F-%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%BA%8C%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="微布校园的分工如何？"><a href="#微布校园的分工如何？" class="headerlink" title="微布校园的分工如何？"></a>微布校园的分工如何？</h3><h3 id="在开发过程中学到了什么？遇到了什么难的问题？"><a href="#在开发过程中学到了什么？遇到了什么难的问题？" class="headerlink" title="在开发过程中学到了什么？遇到了什么难的问题？"></a>在开发过程中学到了什么？遇到了什么难的问题？</h3><h3 id="如何解决缓存雪崩、缓存与数据库一致性问题？"><a href="#如何解决缓存雪崩、缓存与数据库一致性问题？" class="headerlink" title="如何解决缓存雪崩、缓存与数据库一致性问题？"></a>如何解决缓存雪崩、缓存与数据库一致性问题？</h3><h3 id="查询响应速度从超时响应加快到900ms-1s是如何实现的？"><a href="#查询响应速度从超时响应加快到900ms-1s是如何实现的？" class="headerlink" title="查询响应速度从超时响应加快到900ms~1s是如何实现的？"></a>查询响应速度从超时响应加快到900ms~1s是如何实现的？</h3><h3 id="讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）"><a href="#讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）" class="headerlink" title="讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）"></a>讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）</h3><h3 id="使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。"><a href="#使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。" class="headerlink" title="使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。"></a>使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。</h3><h3 id="Redis在哪一部分用的比较多？"><a href="#Redis在哪一部分用的比较多？" class="headerlink" title="Redis在哪一部分用的比较多？"></a>Redis在哪一部分用的比较多？</h3><h3 id="讲一下http的三次握手、四次挥手？"><a href="#讲一下http的三次握手、四次挥手？" class="headerlink" title="讲一下http的三次握手、四次挥手？"></a>讲一下http的三次握手、四次挥手？</h3><h3 id="为什么要进行四次挥手？"><a href="#为什么要进行四次挥手？" class="headerlink" title="为什么要进行四次挥手？"></a>为什么要进行四次挥手？</h3><h3 id="介绍一下udp和tcp之间的区别"><a href="#介绍一下udp和tcp之间的区别" class="headerlink" title="介绍一下udp和tcp之间的区别"></a>介绍一下udp和tcp之间的区别</h3><h3 id="什么时候用UDP？什么时候用TCP？"><a href="#什么时候用UDP？什么时候用TCP？" class="headerlink" title="什么时候用UDP？什么时候用TCP？"></a>什么时候用UDP？什么时候用TCP？</h3><h3 id="介绍一下对HTTP的理解"><a href="#介绍一下对HTTP的理解" class="headerlink" title="介绍一下对HTTP的理解"></a>介绍一下对HTTP的理解</h3><h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><h3 id="介绍一下token"><a href="#介绍一下token" class="headerlink" title="介绍一下token"></a>介绍一下token</h3><h3 id="讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？"><a href="#讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？" class="headerlink" title="讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？"></a>讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？</h3><h3 id="介绍一下Redis的数据类型和持久化"><a href="#介绍一下Redis的数据类型和持久化" class="headerlink" title="介绍一下Redis的数据类型和持久化"></a>介绍一下Redis的数据类型和持久化</h3><h3 id="如何通过Redis实现分布式锁？"><a href="#如何通过Redis实现分布式锁？" class="headerlink" title="如何通过Redis实现分布式锁？"></a>如何通过Redis实现分布式锁？</h3><h3 id="Redis的淘汰策略有哪些？"><a href="#Redis的淘汰策略有哪些？" class="headerlink" title="Redis的淘汰策略有哪些？"></a>Redis的淘汰策略有哪些？</h3><h3 id="介绍一下对多线程的理解"><a href="#介绍一下对多线程的理解" class="headerlink" title="介绍一下对多线程的理解"></a>介绍一下对多线程的理解</h3><h3 id="什么是线程池、为什么要使用线程池？"><a href="#什么是线程池、为什么要使用线程池？" class="headerlink" title="什么是线程池、为什么要使用线程池？"></a>什么是线程池、为什么要使用线程池？</h3><h3 id="Java的异常有哪些？如何捕获异常？"><a href="#Java的异常有哪些？如何捕获异常？" class="headerlink" title="Java的异常有哪些？如何捕获异常？"></a>Java的异常有哪些？如何捕获异常？</h3><h3 id="对文件的上传、下载分别有哪些测试功能点？"><a href="#对文件的上传、下载分别有哪些测试功能点？" class="headerlink" title="对文件的上传、下载分别有哪些测试功能点？"></a>对文件的上传、下载分别有哪些测试功能点？</h3><h3 id="算法题：把两个无序的数组合并成一个有序的数组"><a href="#算法题：把两个无序的数组合并成一个有序的数组" class="headerlink" title="算法题：把两个无序的数组合并成一个有序的数组"></a>算法题：把两个无序的数组合并成一个有序的数组</h3><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><h3 id="为什么要选择面试测试开发这个岗位？"><a href="#为什么要选择面试测试开发这个岗位？" class="headerlink" title="为什么要选择面试测试开发这个岗位？"></a>为什么要选择面试测试开发这个岗位？</h3><h3 id="你觉得测开需要学习些什么方面的东西？"><a href="#你觉得测开需要学习些什么方面的东西？" class="headerlink" title="你觉得测开需要学习些什么方面的东西？"></a>你觉得测开需要学习些什么方面的东西？</h3><h3 id="netty和直接裸写socket有什么区别？"><a href="#netty和直接裸写socket有什么区别？" class="headerlink" title="netty和直接裸写socket有什么区别？"></a>netty和直接裸写socket有什么区别？</h3><h3 id="什么是NIO？"><a href="#什么是NIO？" class="headerlink" title="什么是NIO？"></a>什么是NIO？</h3><h3 id="为什么IO多路复用比多线程更高效？"><a href="#为什么IO多路复用比多线程更高效？" class="headerlink" title="为什么IO多路复用比多线程更高效？"></a>为什么IO多路复用比多线程更高效？</h3><h3 id="Redis是单线程还是多线程的？为什么是单线程还能这么高效？"><a href="#Redis是单线程还是多线程的？为什么是单线程还能这么高效？" class="headerlink" title="Redis是单线程还是多线程的？为什么是单线程还能这么高效？"></a>Redis是单线程还是多线程的？为什么是单线程还能这么高效？</h3><h3 id="在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？"><a href="#在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？" class="headerlink" title="在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？"></a>在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？</h3><h3 id="使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）"><a href="#使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）" class="headerlink" title="使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）"></a>使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）</h3><h3 id="netty的广播怎么实现的？"><a href="#netty的广播怎么实现的？" class="headerlink" title="netty的广播怎么实现的？"></a>netty的广播怎么实现的？</h3><h3 id="如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？"><a href="#如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？" class="headerlink" title="如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？"></a>如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？</h3><h3 id="如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？"><a href="#如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？" class="headerlink" title="如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？"></a>如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？</h3><h3 id="介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？"><a href="#介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？" class="headerlink" title="介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？"></a>介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？</h3><h3 id="说几个Maven的常用命令"><a href="#说几个Maven的常用命令" class="headerlink" title="说几个Maven的常用命令"></a>说几个Maven的常用命令</h3><h3 id="常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）"><a href="#常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）" class="headerlink" title="常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）"></a>常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）</h3><h3 id="怎么实现多线程之间的同步操作？-主线程开启10个任务，-等这10个任务并发结束之后，再执行其他的任务应该怎么实现？"><a href="#怎么实现多线程之间的同步操作？-主线程开启10个任务，-等这10个任务并发结束之后，再执行其他的任务应该怎么实现？" class="headerlink" title="怎么实现多线程之间的同步操作？ 主线程开启10个任务， 等这10个任务并发结束之后，再执行其他的任务应该怎么实现？"></a>怎么实现多线程之间的同步操作？ 主线程开启10个任务， 等这10个任务并发结束之后，再执行其他的任务应该怎么实现？</h3><h3 id="Java的新特性（介绍的Java8的新特性）"><a href="#Java的新特性（介绍的Java8的新特性）" class="headerlink" title="Java的新特性（介绍的Java8的新特性）"></a>Java的新特性（介绍的Java8的新特性）</h3><h3 id="编码：实现a，b两个线程顺序交替执行"><a href="#编码：实现a，b两个线程顺序交替执行" class="headerlink" title="编码：实现a，b两个线程顺序交替执行"></a>编码：实现a，b两个线程顺序交替执行</h3>]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-万物心选php开发实习</title>
    <url>/2023/07/25/%E9%9D%A2%E7%BB%8F-%E4%B8%87%E7%89%A9%E5%BF%83%E9%80%89php%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="实习项目的监听字段是基于什么实现的？"><a href="#实习项目的监听字段是基于什么实现的？" class="headerlink" title="实习项目的监听字段是基于什么实现的？"></a>实习项目的监听字段是基于什么实现的？</h2><p>前端进行某个字段变更之后，后端提供接口，将修改后的数据打入消息队列，服务端作为消费者进行监听判断某个字段是否等于某个值然后进行对应的业务逻辑操作。</p>
<h2 id="通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）"><a href="#通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）" class="headerlink" title="通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）"></a>通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）</h2><p>通过业务id来保证，业务id作为锁的key，当消费信息的时候，把工单id作为key去申请锁，如果成功拿到了锁，说明此时不存在竞争关系，如果当前进程被阻塞了，说明有进程对该数据进行了消费。</p>
<p>不过后面发现如果有两个并发的线程的时候，被阻塞的业务后面拿到了还是可能会造成重复消费，于是又加了一层缓存，缓存已经消费了的业务id，用来表示是否被消费过，也就是保证业务的幂等性。</p>
<h2 id="当时为什么考虑到设置一个重试机制降低消费的失败率？"><a href="#当时为什么考虑到设置一个重试机制降低消费的失败率？" class="headerlink" title="当时为什么考虑到设置一个重试机制降低消费的失败率？"></a>当时为什么考虑到设置一个重试机制降低消费的失败率？</h2><p>当初实现合同是临时合同的时候，要删除销售合同的主从表，因为当时是两个表，涉及到了一个同步操作，即先删除主表之后再删除从表的操作，要保证事务的一致性和原子性，可能两个删除操作会有一个或者两个操作均失败的情况，就设计了这个重试机制，如果其中一个操作失败就进行事务回滚，然后将两个同步操作打入重试的队列中进行一次重试。</p>
<h2 id="有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）"><a href="#有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）" class="headerlink" title="有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）"></a>有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）</h2><p><strong>避免消费失败的措施：</strong></p>
<ol>
<li>失败重试机制</li>
<li>死信队列</li>
<li>消息超时机制：避免因为一个消息阻塞导致后续的所有消息超时</li>
<li>负载均衡：如果是集群分布式服务，可以通过负载均衡算法分配给多个消费者。</li>
<li>消息确认机制：当消费者消费成功之后，发送确认信号给消息队列，表示消息处理成功，如果消费者在一定时间内没有返回确认信号，消息队列就重新分发消息给其他的消费者进行消费。</li>
</ol>
<p><strong>避免重复消费的措施：</strong></p>
<ol>
<li>实现幂等性：即相同的多个操作所产生的影响与仅执行一次的操作所产生的影响相同。确保相同的消息被多次发送之后，只会被处理一次。</li>
<li>消息确认机制：消息队列消费者消费之后会给生产者发送一个确认信号告诉已经消费信息成功，如果在一定时间内没有发送确认消息，消息队列就会认为此消息未被成功消费，会将该消息重新发送给消费者。</li>
<li>消费者限流：在高并发的场景中，为了消费者过度消费，就会在一定时间内只允许消费者消费一定数量的消息，以避免被过度消费而导致的重复消费。</li>
</ol>
<h2 id="如何解决数据库offset超过10000时失效的问题？"><a href="#如何解决数据库offset超过10000时失效的问题？" class="headerlink" title="如何解决数据库offset超过10000时失效的问题？"></a>如何解决数据库offset超过10000时失效的问题？</h2><p>通过分页查询的方式，偏移量超过一万的情况下，我们可以通过limit的分页查询机制，一直查到第10001条数据的主键id，然后从此id开始进一步根据条件查询需要获取的数据。</p>
<h2 id="为什么offset超过10000会查询不到数据呢？"><a href="#为什么offset超过10000会查询不到数据呢？" class="headerlink" title="为什么offset超过10000会查询不到数据呢？"></a>为什么offset超过10000会查询不到数据呢？</h2><p>OFFSET工作原理是通过全表扫描，先查询所有匹配的记录，然后再跳过指定数量的记录，如果偏移量特别大，数据库可能会需要一次性加载大量数据到内存中，会导致内存不足的问题。</p>
<h2 id="实习时候的成长经历"><a href="#实习时候的成长经历" class="headerlink" title="实习时候的成长经历"></a>实习时候的成长经历</h2><p>1、有一次出现过一次消息队列重复消费的情况，当时情况是两个不同的测试环境，做相同业务消费时消费了两次，然后查代码一直也没有查到原因，就去看配置环境，原来是当时运维那边部署消息队列，两个环境都部署到了一个队列上面，没有做环境隔离。。。</p>
<p>2、在开发流程中先根据需求，写出开发思路，</p>
<h2 id="JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？"><a href="#JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？" class="headerlink" title="JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？"></a>JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？</h2><p><strong>业务及校验流程：</strong></p>
<p>用户通过学号+教务密码向Java后端发起请求，然后Java后端调用Python的服务进行校验账号密码是否正确，如果正确就会向前端返回一个token，客户端将Token保存在本地缓存之中，方便以后在一些业务操作的时候，都会从本地缓存中获取Token并将其放在Http请求的Header中发送请求，服务端获取到请求之后从Http的header里面获取token，并通过服务端保存的密匙进行重新生成新的signature和客户端发过来的token的signature进行比较确认token是否有效，再从payload部分获取相关用户信息进行进一步身份校验。</p>
<p>每次服务端在校验token有效的时候会根据payload的签发token时间+超时时间，当离过期时间只有1天的时候，就会重新签发一个Token给前端。</p>
<p><strong>Token存放位置：</strong></p>
<p>HTTP的Header部分。</p>
<h2 id="Java为什么需要垃圾回收机制呢？"><a href="#Java为什么需要垃圾回收机制呢？" class="headerlink" title="Java为什么需要垃圾回收机制呢？"></a>Java为什么需要垃圾回收机制呢？</h2><p>主要是为了管理内存，自动释放不再使用的对象，以避免内存泄漏和提高程序性能。</p>
<h2 id="什么情况下会出现资源的浪费（内存泄漏）？"><a href="#什么情况下会出现资源的浪费（内存泄漏）？" class="headerlink" title="什么情况下会出现资源的浪费（内存泄漏）？"></a>什么情况下会出现资源的浪费（内存泄漏）？</h2><p>1、长期存活的对象占用过多内存，就是长生命周期对象持有短生命周期的引用导致部分短生命周期的对象一直没有被释放，进而积累过多的情况下出现内存泄漏的问题。</p>
<p>2、各种连接：比如数据库连接、网络连接，对于这些连接操作都需要在不使用的时候进行关闭操作，垃圾回收期才会进行回收。</p>
<p>3、变量作用域不合理：比如要对一个msg进行保存操作，但是msg定义成一个成员变量，然后通过receiveMsg()方法进行相关保存业务逻辑操作，但是因为msg是成员变量，生命周期和类的生命周期一样，所以导致存储操作完成之后，msg还没有被回收释放，可能就会导致内存泄漏。</p>
<h2 id="创建了一个String类型的数据什么时候会被垃圾回收机制回收？"><a href="#创建了一个String类型的数据什么时候会被垃圾回收机制回收？" class="headerlink" title="创建了一个String类型的数据什么时候会被垃圾回收机制回收？"></a>创建了一个String类型的数据什么时候会被垃圾回收机制回收？</h2><p>1、对象不再引用。</p>
<p>2、对象引用被显式设置为null。</p>
<p>3、对象的引用超出作用域：在一个方法内部创建的，那么在这个方法执行完之后就会被收回。</p>
<p>3、垃圾回收机制触发：Java虚拟机判断系统内存不足就会触发此机制，尝试回收不再被使用的对象。</p>
<h2 id="了解哪些垃圾回收算法并介绍一下"><a href="#了解哪些垃圾回收算法并介绍一下" class="headerlink" title="了解哪些垃圾回收算法并介绍一下"></a>了解哪些垃圾回收算法并介绍一下</h2><p><strong>标记-清除算法：</strong></p>
<p>首先标记处所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p>
<p>导致的问题：</p>
<p>1、标记清除的过程效率都不高</p>
<p>2、标记清除后会产生大量不连续的内存碎片。</p>
<p><strong>复制算法：</strong></p>
<p>将内存空间分为两半，每次使用其中的一块，当这块使用完之后，将这块还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</p>
<p>导致的问题：</p>
<p>1、可用内存变小。</p>
<p>2、不适合老年代，如果存活对象数量大，复制性能会比较差。</p>
<p><strong>标记-整理算法：</strong></p>
<p>标记不需要回收的对象，然后将没有标记的对象统一向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>导致问题：</p>
<p>只适合老年代回收频率较低的场景</p>
<p><strong>分代收集算法：</strong></p>
<p>根据不同对象的生命周期将内存分为几块。一般将Java堆分为新生代和老年代，可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如：新生代中，每次都会有大量对象死去，可以选择<strong>复制算法</strong>，只需要付出少量对象的复制成本就可以完成垃圾收集。而对于老年代生命周期较长，存活率较高，可以选择<strong>标记-清除算法</strong>或者<strong>标记-整理算法</strong>实现。</p>
<h2 id="垃圾回收机制为什么要分新生代和老年代呢？"><a href="#垃圾回收机制为什么要分新生代和老年代呢？" class="headerlink" title="垃圾回收机制为什么要分新生代和老年代呢？"></a>垃圾回收机制为什么要分新生代和老年代呢？</h2><p>根据不同对象的生命周期将内存分为几块。一般将Java堆分为新生代和老年代，可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<h2 id="为什么新生代和老年代不放在一起进行回收呢？"><a href="#为什么新生代和老年代不放在一起进行回收呢？" class="headerlink" title="为什么新生代和老年代不放在一起进行回收呢？"></a>为什么新生代和老年代不放在一起进行回收呢？</h2><p>1、不同对象生命周期：可以根据不同的生命周期对象采用不同的回收策略</p>
<p>2、不同回收算法：一般新生代会采用复制算法清除，因为可以标记较少的对象复制到另一块内存上面去，然后一次性清理整个区域，效率较高，对于老年代生命周期长且存活率高，就可以采用标记-整理或者标记-删除的办法，将不需要回收的对象进行标记，然后直接删除没有标记的即可。</p>
<p>3、避免频繁回收老年代：混在一起会导致老年代频繁的回收，降低系统的性能。</p>
<h2 id="数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？"><a href="#数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？" class="headerlink" title="数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？"></a>数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？</h2><ul>
<li>数组访问效率比链表高，因为链表通常是动态扩容的，每次的动态调整都会带来一定的开销以及维护指针等，所以访问效率较低。</li>
<li>链表能灵活进行动态扩容或缩容，但是数组一旦确定大小就不能进行扩容和缩容操作了。</li>
<li>链表有丰富的api可以直接动态进行增删查改，而数组是一个固定长度的数组，只能按下标访问其中的元素，不具备动态增删的能力。</li>
<li>链表只能存储对象（对于基本数据类型可以采用包装类进行存储），但是数组既可以存储对象也可以存储基本数据类型。</li>
<li>链表可以通过泛型保证类型安全，但是数组不可以。</li>
</ul>
<h2 id="有没有一个数据结构可以访问元素时间是O-1-，又可以灵活的调整他的容量大小？"><a href="#有没有一个数据结构可以访问元素时间是O-1-，又可以灵活的调整他的容量大小？" class="headerlink" title="有没有一个数据结构可以访问元素时间是O(1)，又可以灵活的调整他的容量大小？"></a>有没有一个数据结构可以访问元素时间是O(1)，又可以灵活的调整他的容量大小？</h2><p>哈希表可以将key映射到存储位置来实现快速访问，使用哈希函数将键转换成索引，然后将值存在对应索引的位置，在理想情况下，能够在O（1）情况下根据键找到对应的值。哈希表具有灵活的扩容机制，当哈希表中元素过多的时候就会自动扩容，重新分配更大的空间。</p>
<h2 id="HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）"><a href="#HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）" class="headerlink" title="HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）"></a>HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）</h2><p>hashmap是基于数组+链表/红黑树的数据结构来具体实现的，首先hashmap产生哈希冲突的时候会判断链表的长度是否大于8，如果大于的话就会转换成红黑树（此时进入红黑树转换的函数的时候，会判断数组的长度是否大于64，如果数组长度小于64，就不会转换成红黑树，而是选择扩容的机制解决哈希冲突）</p>
<p>选择红黑树的原因：</p>
<p>1、如果是<strong>二叉查询树</strong>比较极端的情况下，当子节点都比父节点大或者小的时候，二叉查找树又会退化成链表，此时时间复杂度又是O(n)。</p>
<p>2、如果是<strong>平衡二叉树（AVL）</strong>，因为它每个节点的左子树和右子树的高度差至多等于1，如果大于1了就会通过左旋或者右旋的方式，使其复杂度一直维持在O(logN)，但是因为这个左旋和右旋的原因，导致插入数据的时候需要消耗大量的时间。</p>
<h2 id="场景题：现在有路由器a-b-c-d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？"><a href="#场景题：现在有路由器a-b-c-d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？" class="headerlink" title="场景题：现在有路由器a,b,c,d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？"></a>场景题：现在有路由器a,b,c,d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？</h2><p>在IP层遇到循环路由的情况下，数据包会被丢弃。IP协议是一种无连接的、不可靠的协议，它不会主动检查循环路由或处理数据包的循环传递。</p>
<p>为了防止数据包在网络中无限循环，网络管理员通常会配置路由器使用一些防循环机制，比如距离矢量路由协议中的Split Horizon技术，或链路状态路由协议中的Reverse Path Forwarding（RPF）检查。这些机制有助于检测和避免数据包在网络中形成循环路径。</p>
<p>但是，即使配置了防循环机制，由于网络的复杂性和问题可能的多样性，有时候循环路由问题仍然可能发生。在这种情况下，IP层不会继续无限传递数据包，而是丢弃它，从而避免对网络产生更严重的影响。丢弃数据包是为了确保网络中的数据传输是可靠和有效的，即使牺牲了某些数据包。</p>
<h2 id="Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？"><a href="#Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？" class="headerlink" title="Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？"></a>Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？</h2><p>stat的基本单位是块，也就是byte。转换成可识别的大小的话，通过1 kb = 1024byte实现。</p>
<p>可以通过ls -lh</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-借钱包交易平台Java开发实习</title>
    <url>/2023/08/10/%E9%9D%A2%E7%BB%8F-%E5%80%9F%E9%92%B1%E5%8C%85%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0Java%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="如果对于jdk版本升级，对于jvm的一些参数修改有哪些？"><a href="#如果对于jdk版本升级，对于jvm的一些参数修改有哪些？" class="headerlink" title="如果对于jdk版本升级，对于jvm的一些参数修改有哪些？"></a>如果对于jdk版本升级，对于jvm的一些参数修改有哪些？</h2><ol>
<li>-Xmx 和 -Xms：这些参数用于设置 JVM 的最大堆内存和初始堆内存大小。在 JDK 版本升级后，由于可能存在新的特性或改进，建议重新评估应用程序的内存需求，并相应地调整这些参数。</li>
<li>-XX:NewRatio 和 -XX:SurvivorRatio：这些参数用于调整新生代（Young Generation）和老年代（Old Generation）的比例和新生代中 Eden 区和 Survivor 区的比例。在 JDK 版本升级后，新的默认比例可能会有所变化，可能需要重新设置这些参数以优化垃圾回收性能。</li>
<li>-XX:+UseConcMarkSweepGC 和 -XX:+UseG1GC 等：这些参数用于选择不同的垃圾回收器。随着 JDK 版本的升级，可能会引入新的垃圾回收器或对现有的回收器进行优化，因此需要根据应用程序的特性和需求选择合适的垃圾回收器和相应的参数。</li>
<li>-XX:MaxMetaspaceSize：在 JDK 8 及之前的版本中，用于设置永久代（Permanent Generation）的最大大小。但从 JDK 8 开始，永久代被移除，取而代之的是 Metaspace。因此，在 JDK 版本升级后，如果之前使用了永久代的参数，需要调整为 Metaspace 相关的参数。</li>
<li>其他新的 -XX 开头的参数：随着 JDK 版本的升级，可能会引入新的 JVM 参数，用于控制新的特性或优化性能。因此，在升级后应该查阅新的文档，了解这些新参数的用法和影响，并根据需要进行配置。</li>
</ol>
<h2 id="介绍包装类和基本数据类型的自动拆箱和自动装箱"><a href="#介绍包装类和基本数据类型的自动拆箱和自动装箱" class="headerlink" title="介绍包装类和基本数据类型的自动拆箱和自动装箱?"></a>介绍包装类和基本数据类型的自动拆箱和自动装箱?</h2><p>自动装箱：将基本数据类型转换成对应的包装类型</p>
<p>自动拆箱：将包装类型转换成对应的基本数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//装箱  Integer.valueOf(10);</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;<span class="comment">//拆箱   n = i.intValue();</span></span><br></pre></td></tr></table></figure>

<h2 id="什么常见场景会自动触发自动装箱和自动拆箱？"><a href="#什么常见场景会自动触发自动装箱和自动拆箱？" class="headerlink" title="什么常见场景会自动触发自动装箱和自动拆箱？"></a>什么常见场景会自动触发自动装箱和自动拆箱？</h2><p>自动装箱场景：</p>
<ul>
<li>将基本数据类型赋值给对应的包装类型，比如:Integer i = 10;</li>
<li>将基本数据类型作为参数赋值给接受包装类型的方法。</li>
</ul>
<p>自动拆箱场景：</p>
<ul>
<li>将包装类型赋值给对应的基本数据类型，比如<code>Integer i = 10; int n = i;</code></li>
<li>将包装类型作为参数赋值给接受对应基本数据类型的方法。</li>
</ul>
<h2 id="对于Integer类型的数据进行比较大小需要注意哪些问题？"><a href="#对于Integer类型的数据进行比较大小需要注意哪些问题？" class="headerlink" title="对于Integer类型的数据进行比较大小需要注意哪些问题？"></a>对于Integer类型的数据进行比较大小需要注意哪些问题？</h2><p>1、比较大小：使用equals方法，因为equals方法比较的是对象的值，而==比较的是对象的引用地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">n == i; <span class="comment">// YES</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">a == b;<span class="comment">//NO，因为Integer会缓存-128-127的对象，此时==号比较的是a和b的引用地址，但是此时a和b的值不在此缓存范围内，会重新创建两个不同的引用，进行引用地址的比较。</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">c == d;<span class="comment">//NO</span></span><br><span class="line">c.equals(d);<span class="comment">//YES</span></span><br></pre></td></tr></table></figure>

<p>2、尽量避免频繁的拆箱装箱，频繁的拆装箱会造成一些不必要的资源损耗。</p>
<p>3、避免空指针异常：如果包装类型定义了null，此时进行自动拆箱的时候会抛出NPE。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n= <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n;<span class="comment">//会抛出NPE,NullPointException</span></span><br></pre></td></tr></table></figure>

<h2 id="为什么是选择equals方法去比较Integer这一类包装类类型的数据？"><a href="#为什么是选择equals方法去比较Integer这一类包装类类型的数据？" class="headerlink" title="为什么是选择equals方法去比较Integer这一类包装类类型的数据？"></a>为什么是选择equals方法去比较Integer这一类包装类类型的数据？</h2><p>使用==号的时候，如果Integer是通过<code>创建对象或者自动装箱的数据在-128~127的范围就会返回false</code>，==比较的是两个Integer对象的引用地址，如果出现刚刚所述的两种情况，是因为他们此时的所属对象的引用地址不一样导致的。</p>
<p>而使用equals方法比较的是两个对象之间的值，而不是引用地址。</p>
<h2 id="在重写一个对象的时候为什么要重写equals-以及hashcode-？"><a href="#在重写一个对象的时候为什么要重写equals-以及hashcode-？" class="headerlink" title="在重写一个对象的时候为什么要重写equals()以及hashcode()？"></a>在重写一个对象的时候为什么要重写equals()以及hashcode()？</h2><p>因为两个相等的对象的hashCode必须相等，不然如果重写了equals方法而没有重写hashCode方法的话可能会出现equals方法判断两个对象相等，但是其hashCode不相等的情况。</p>
<h2 id="hashmap如何解决哈希碰撞-哈希冲突-问题？"><a href="#hashmap如何解决哈希碰撞-哈希冲突-问题？" class="headerlink" title="hashmap如何解决哈希碰撞(哈希冲突)问题？"></a>hashmap如何解决哈希碰撞(哈希冲突)问题？</h2><h2 id="hashmap在存放一个键值对的时候过程是怎么样的？"><a href="#hashmap在存放一个键值对的时候过程是怎么样的？" class="headerlink" title="hashmap在存放一个键值对的时候过程是怎么样的？"></a>hashmap在存放一个键值对的时候过程是怎么样的？</h2><p>1、对键进行hash计算来确定键值存放的位置</p>
<p>2、通过取模运算找到具体存储哈希键值对的位置即桶</p>
<p>3、将键值对存储在对应的桶中，如果产生了哈希冲突就会作为一个节点存入到链表或者红黑树的头部。</p>
<h2 id="当hashmap转换成红黑树后什么情况下会转回链表？"><a href="#当hashmap转换成红黑树后什么情况下会转回链表？" class="headerlink" title="当hashmap转换成红黑树后什么情况下会转回链表？"></a>当hashmap转换成红黑树后什么情况下会转回链表？</h2><p>当红黑树的节点数小于等于6的时候，会转回链表的形式进行键值对的存储，因为hashCode符合泊松分布，哈希冲突造成链表长度等于6的情况比较高，且红黑树维护节点开销会比链表维护所需开销大，如果是长度等于7的情况的话，可能会导致频繁的链表和红黑树的转换开销和资源浪费。</p>
<blockquote>
<p><strong>为什么是<strong><strong>链表</strong></strong>等于8的时候转？</strong></p>
<p>因为经过统计，当hashCode遵循泊松分布时，因为哈希冲突造成桶的链表长度大于等于8的概率只有0.00000006，所以根据数学推算决定当链表长度等于8时转换成红黑树。而且转换成红黑树之后的维护开销会比链表高很多，所以不会随随便便进行红黑树和链表之间的互相转换。</p>
</blockquote>
<h2 id="常见集合list、map、set、queue之间的区别"><a href="#常见集合list、map、set、queue之间的区别" class="headerlink" title="常见集合list、map、set、queue之间的区别"></a>常见集合list、map、set、queue之间的区别</h2><p>list：元素有序，可重复</p>
<p>set：元素无序，不可重复</p>
<p>map：以key-value方式存储，key无序、不可重复，value无序、可重复，每个键最多映射到一个值。</p>
<p>queue：元素有序，可重复。</p>
<h2 id="关于构建一个线程池我们需要配置的核心参数有哪些？"><a href="#关于构建一个线程池我们需要配置的核心参数有哪些？" class="headerlink" title="关于构建一个线程池我们需要配置的核心参数有哪些？"></a>关于构建一个线程池我们需要配置的核心参数有哪些？</h2><p><strong><code>ThreadPoolExecutor</code></strong> <strong>3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code></strong> <strong>:</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code></strong> <strong>:</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>****:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ul>
<li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。</li>
</ul>
<h2 id="InnoDB的索引数据结构是什么？介绍一下b-树"><a href="#InnoDB的索引数据结构是什么？介绍一下b-树" class="headerlink" title="InnoDB的索引数据结构是什么？介绍一下b+树"></a>InnoDB的索引数据结构是什么？介绍一下b+树</h2><p>B+树</p>
<ul>
<li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。</li>
<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li>
<li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</li>
</ul>
<h2 id="为什么B-树千万级别在MySQL只有3-4层？"><a href="#为什么B-树千万级别在MySQL只有3-4层？" class="headerlink" title="为什么B+树千万级别在MySQL只有3-4层？"></a>为什么B+树千万级别在MySQL只有3-4层？</h2><p>非叶子结点一般只有键+指针，也就是8+6 = 14byte，那么一个非叶子结点可以存储的键+指针个数是16<em>1024/14=1170个单元数，如果一条记录是1k，那么一个节点能存16条记录，那么两层的B+树就是16 * 1170=18720条记录，3层的话就是16</em>1170*1170=2190w+条记录。</p>
<h2 id="Innodb的默认隔离事务级别是什么？什么是可重复读？"><a href="#Innodb的默认隔离事务级别是什么？什么是可重复读？" class="headerlink" title="Innodb的默认隔离事务级别是什么？什么是可重复读？"></a>Innodb的默认隔离事务级别是什么？什么是可重复读？</h2><p>可重复读。</p>
<p>指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的</p>
<h2 id="在可重复读的事务隔离级别下，什么场景下会出现幻读的情况？"><a href="#在可重复读的事务隔离级别下，什么场景下会出现幻读的情况？" class="headerlink" title="在可重复读的事务隔离级别下，什么场景下会出现幻读的情况？"></a>在可重复读的事务隔离级别下，什么场景下会出现幻读的情况？</h2><p>场景一（针对快照读）：</p>
<p>以下表为例：</p>
<p><img src="https://qazbc6jrkh1.feishu.cn/space/api/box/stream/download/asynccode/?code=YThkOTc3ZDZmNzg5ZDgxNTdmYjQxNzExNDNjN2YyMWJfOTdGNnVRc2NCY0xPSGpTa2pNVWo3VDJKS1I3WTI2b0FfVG9rZW46Tzg0eWJQUVpHb0tNYTZ4TnVYRGM0dktGbkRiXzE2OTIzNjI3NDU6MTY5MjM2NjM0NV9WNA" alt="img"></p>
<p>事务A执行查询id = 5的记录，此时表中没有此记录，所以查不出来</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#事务A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>此时事务B添加一条id = 5的记录，并提交</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#事务B</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert into</span> t_stu <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;小美&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>此时，<strong>事务A更新id=5的记录，并查询id=5的记录，此时就能看到事务B插入的记录。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务 A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> t_stu <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;小林coding&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)<span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 小林coding   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>时序图如下：</p>
<p><img src="https://qazbc6jrkh1.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQ2YmI5MDJlMjEwNDY0MDNlN2JmYmYzM2RkOTQ1M2NfUHVJbTIybHFoWHNnVEwxMFdjdmNOZU5oUk5CU05mdFlfVG9rZW46Q2xWOGJnczV6b1o5bk14OG1Za2NaQ1h1blVlXzE2OTIzNjI3NDU6MTY5MjM2NjM0NV9WNA" alt="img"></p>
<p>场景二（针对当前读）：</p>
<ul>
<li>T1时刻，事务A先执行了快照读语句:select * from t_test where id &gt; 100 得到了 3 条记录;</li>
<li>T2时刻，事务B插入了一条id = 200的记录并提交</li>
<li>T3时刻，事务A执行当前读：select * from t_test where id &gt; 100;就会得到4条记录</li>
</ul>
<h2 id="Maven添加资源包的时候，如何操作？"><a href="#Maven添加资源包的时候，如何操作？" class="headerlink" title="Maven添加资源包的时候，如何操作？"></a>Maven添加资源包的时候，如何操作？</h2><p>在Maven项目中添加资源包（例如配置文件、图像文件、文本文件等）通常涉及以下步骤：</p>
<ol>
<li><p><strong>创建资源文件夹</strong>：</p>
<p>在项目的源代码目录（src/main/java）旁边创建一个资源文件夹，通常命名为”resources”，这是Maven默认的资源文件夹。</p>
</li>
<li><p><strong>将资源文件放入资源文件夹</strong>：</p>
<p>将您的资源文件（例如配置文件、图像等）放入刚刚创建的”resources”文件夹中。</p>
</li>
<li><p><strong>更新项目配置文件（pom.xml）</strong>：</p>
<p>打开项目的<code>pom.xml</code>文件，并在<code>&lt;build&gt;</code>标签下的<code>&lt;resources&gt;</code>标签中配置资源文件夹。示例如下：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 可选：可以配置&lt;filtering&gt;标签来进行资源文件中的属性替换 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可以添加多个&lt;resource&gt;标签来包含多个资源文件夹 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>   此配置告诉Maven在构建项目时将资源文件夹中的内容包含在生成的JAR或WAR文件中。</p>
<ol start="4">
<li><p><strong>运行<strong><strong>Maven</strong></strong>构建命令</strong>：</p>
<p>打开终端或命令提示符，进入项目根目录，然后运行以下命令来执行Maven构建：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure>

<p>   或者如果只需要将资源添加到生成的JAR或WAR中，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn resources:resources</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p><strong>访问资源文件</strong>：</p>
<p>在Java代码中，您可以使用类加载器来访问位于资源文件夹中的资源文件。例如，使用以下代码来加载资源文件：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;path/to/resource.file&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>   其中，<code>path/to/resource.file</code>是资源文件在资源文件夹中的相对路径。</p>
<h2 id="Maven的常用命令有哪些？"><a href="#Maven的常用命令有哪些？" class="headerlink" title="Maven的常用命令有哪些？"></a>Maven的常用命令有哪些？</h2><h2 id="缓存雪崩、缓存和数据库一致性问题的解决方案？"><a href="#缓存雪崩、缓存和数据库一致性问题的解决方案？" class="headerlink" title="缓存雪崩、缓存和数据库一致性问题的解决方案？"></a>缓存雪崩、缓存和数据库一致性问题的解决方案？</h2><h2 id="如果此时使用的是cookie-session机制，而且是分布式系统的话，怎么实现用户鉴权问题？"><a href="#如果此时使用的是cookie-session机制，而且是分布式系统的话，怎么实现用户鉴权问题？" class="headerlink" title="如果此时使用的是cookie-session机制，而且是分布式系统的话，怎么实现用户鉴权问题？"></a>如果此时使用的是cookie-session机制，而且是分布式系统的话，怎么实现用户鉴权问题？</h2><p>1、SSO单点登录</p>
<p>2、集中式Session存储</p>
<h2 id="微布校园有遇到一些比较棘手的问题吗？如果出现问题，如何排查问题？"><a href="#微布校园有遇到一些比较棘手的问题吗？如果出现问题，如何排查问题？" class="headerlink" title="微布校园有遇到一些比较棘手的问题吗？如果出现问题，如何排查问题？"></a>微布校园有遇到一些比较棘手的问题吗？如果出现问题，如何排查问题？</h2><h2 id="当时是什么情况因为kafka挂了导致整个服务全部挂了？"><a href="#当时是什么情况因为kafka挂了导致整个服务全部挂了？" class="headerlink" title="当时是什么情况因为kafka挂了导致整个服务全部挂了？"></a>当时是什么情况因为kafka挂了导致整个服务全部挂了？</h2><h2 id="对于整个技术栈哪些组件有过深入的了解？"><a href="#对于整个技术栈哪些组件有过深入的了解？" class="headerlink" title="对于整个技术栈哪些组件有过深入的了解？"></a>对于整个技术栈哪些组件有过深入的了解？</h2>]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-巴比特一面</title>
    <url>/2023/05/01/%E9%9D%A2%E7%BB%8F-%E5%B7%B4%E6%AF%94%E7%89%B9%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="Netty的pipeline基于什么设计模式？"><a href="#Netty的pipeline基于什么设计模式？" class="headerlink" title="Netty的pipeline基于什么设计模式？"></a>Netty的pipeline基于什么设计模式？</h3><h3 id="Netty的拆包和粘包"><a href="#Netty的拆包和粘包" class="headerlink" title="Netty的拆包和粘包"></a>Netty的拆包和粘包</h3><h3 id="为什么不用自增id而是采用雪花算法？"><a href="#为什么不用自增id而是采用雪花算法？" class="headerlink" title="为什么不用自增id而是采用雪花算法？"></a>为什么不用自增id而是采用雪花算法？</h3><h3 id="介绍一下HashMap和concurrentHashMap"><a href="#介绍一下HashMap和concurrentHashMap" class="headerlink" title="介绍一下HashMap和concurrentHashMap"></a>介绍一下HashMap和concurrentHashMap</h3><h3 id="对比一下String-a-new-“abc”-和String-a-”abc”"><a href="#对比一下String-a-new-“abc”-和String-a-”abc”" class="headerlink" title="对比一下String a = new (“abc”)和String a =”abc”"></a>对比一下String a = new (“abc”)和String a =”abc”</h3><h3 id="什么叫死锁？"><a href="#什么叫死锁？" class="headerlink" title="什么叫死锁？"></a>什么叫死锁？</h3><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><h3 id="Bean的循环依赖怎么解决？"><a href="#Bean的循环依赖怎么解决？" class="headerlink" title="Bean的循环依赖怎么解决？"></a>Bean的循环依赖怎么解决？</h3>]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-北森后端开发实习一面(线程安全和锁未完成)</title>
    <url>/2023/08/03/%E9%9D%A2%E7%BB%8F-%E5%8C%97%E6%A3%AE%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="为什么离开了法大大实习？"><a href="#为什么离开了法大大实习？" class="headerlink" title="为什么离开了法大大实习？"></a>为什么离开了法大大实习？</h3><p>阿巴阿巴阿巴。。。。。</p>
<h3 id="为什么当时要用kafka进行UGC消息推送？业务场景是什么？"><a href="#为什么当时要用kafka进行UGC消息推送？业务场景是什么？" class="headerlink" title="为什么当时要用kafka进行UGC消息推送？业务场景是什么？"></a>为什么当时要用kafka进行UGC消息推送？业务场景是什么？</h3><p><strong>原因：</strong></p>
<ol>
<li>kakfa是一个高吞吐、低延迟的消息队列，UGC消息需要实时推送给其他用户，比如评论、点赞等，因此kafka可以确保消息被快速处理，从而提供更好的实时性和用户体验。</li>
<li>因为kafka 的可靠性比较高、消息会被持久化在磁盘上，确保消息不会丢失。</li>
<li>因为kafka可以支持多个消费组和分区，UGC在高并发的情况下需要处理大量的消息，而kafka可以轻松应对高负载和大规模的UGC</li>
<li>解耦异步，主要是因为异步的特性，不会因为同步处理的方式导致主线程阻塞，导致性能下降。使用消息队列，可以将这些操作封装成消息，放入消息队列中，异步处理这些操作，不影响主线程的执行，提高系统性能和响应速度。</li>
</ol>
<h3 id="kafka的生产和消费逻辑？"><a href="#kafka的生产和消费逻辑？" class="headerlink" title="kafka的生产和消费逻辑？"></a>kafka的生产和消费逻辑？</h3><p>生产实现逻辑：</p>
<p>1、连接到kafka集群，创建一个producer</p>
<p>2、生产者通过producer对象将消息发送到指定的topic。消息可以包含键和值，键可以帮助消息路由到特定的分区，如果没有特定的key就会通过自带的负载均衡机制选择一个分区。</p>
<p>3、通过key实现分区，指定了键的话将使用哈希函数映射到对应的分区，保证相同键的消息将始终被写入相同的分区，从而也可以保持消息的顺序。</p>
<p>4、生产者发送消息也会把消息持久化到磁盘，即使消息被消费，他也会根据kafka的配置的保留时间内保留在磁盘中。</p>
<p>消费实现逻辑：</p>
<p>1、消费者连接到kafka集群，创建一个consumer对象，并订阅一个或者多个主题</p>
<p>2、消费者使用consumer从指定的主题中拉取消息，其中消费者可以选择从分区的起始位置开始消费或者从上次消费的偏移量继续消费。</p>
<p>3、进行消息分配的时候，由于每个topic可能有多个partition，多个消费者可以同时消费同一个topic不同的partition，实现负载均衡和并行处理。（这时候可能会有一个问题，一个消费者组可以消费同一个分区吗？为什么每个分区只能被消费者组中的一个消费者消费？一个消费组可以同时消费不同的分区吗？）</p>
<h3 id="当时开发的过程中，kafka采用的路由分区策略是什么？"><a href="#当时开发的过程中，kafka采用的路由分区策略是什么？" class="headerlink" title="当时开发的过程中，kafka采用的路由分区策略是什么？"></a>当时开发的过程中，kafka采用的路由分区策略是什么？</h3><p>使用的默认的分区策略</p>
<p>就是会使用消息的key进行哈希，然后根据哈希值对分区总数取模得到一个分区号，将消息路由到对应的分区。这样就可以保证具有相同key的消息被写入同一个分区，保证消息有序。</p>
<h3 id="kafka如何保证顺序消费？"><a href="#kafka如何保证顺序消费？" class="headerlink" title="kafka如何保证顺序消费？"></a>kafka如何保证顺序消费？</h3><p>保证相关消息都发送到同一个分区这样就可以保证有序了，即通过一个partition消费对应的消息，因为生产者发送消息的时候，消息会逐一添加到该partition的日志中，并会分配一个唯一的offset，以保证从此offset开始进行消息的消费，从而保证消息顺序的有序性。</p>
<h3 id="如果kafka消息阻塞的话怎么处理？"><a href="#如果kafka消息阻塞的话怎么处理？" class="headerlink" title="如果kafka消息阻塞的话怎么处理？"></a>如果kafka消息阻塞的话怎么处理？</h3><p><strong>生产者角度：</strong></p>
<p>可能是因为生产者的生产速率太快导致，超过了消费者的消费能力，可以通过控制生产者的生产速率来适配消费者的处理速率</p>
<p><strong>消费者角度：</strong></p>
<p>可以创建多个消费者组或消费者实例，对不同的topic下不同的partition进行消费，但是最好是一个partition只被一个消费者消费，但一个消费者可以消费多个partition。</p>
<p><strong>硬件存储问题：</strong></p>
<p>由于存储空间满了，导致消息无法写入，因此消费者也无法进行消费，清空一定的磁盘空间即可。</p>
<h3 id="kafka是怎么保证主从副本的数据一致性？"><a href="#kafka是怎么保证主从副本的数据一致性？" class="headerlink" title="kafka是怎么保证主从副本的数据一致性？"></a>kafka是怎么保证主从副本的数据一致性？</h3><p>1、生产者向kafka的主副本发送消息，主副本会将消息追加到日志里面，进行持久化操作，并将消息分发给从副本。</p>
<p>2、从副本会周期性从主副本拉取数据保存到自己的本地log以保证同步。</p>
<p>3、ISR机制（最重要的一点）：Kafka会维护一个ISR的集合，它保存了相对主副本实时同步的从副本，如果某个从副本没有跟上主副本的进度，就会被移出ISR机制，直到它后面又跟上主副本的进度之后才会回到ISR集合中。</p>
<p>4、当所有ISR的从副本都确认收到了消息，这时候主副本就会把消息标记为已提交，意味着消息写入了足够多的副本中，确保数据的可靠性。</p>
<h3 id="如果主副本没了、这时候会怎么选择从副本？"><a href="#如果主副本没了、这时候会怎么选择从副本？" class="headerlink" title="如果主副本没了、这时候会怎么选择从副本？"></a>如果主副本没了、这时候会怎么选择从副本？</h3><p>会从ISR中同步的从副本选择作为主副本，然后此时被选举成为主副本的副本就会同步消息到其他的从副本中，来保证数据同步和备份。</p>
<h3 id="消息丢失的场景有哪些？以及怎么去解决这个问题？"><a href="#消息丢失的场景有哪些？以及怎么去解决这个问题？" class="headerlink" title="消息丢失的场景有哪些？以及怎么去解决这个问题？"></a>消息丢失的场景有哪些？以及怎么去解决这个问题？</h3><ul>
<li>生产者丢失消息<ul>
<li>生产者使用producer.send方法的时候，因为这个方法是异步的，会立即返回，如果此时出现了网络波动就会出现消息丢失的情况，导致Broker并没有接收到生产者发过来的消息</li>
</ul>
</li>
<li>Kafka Broker 服务端丢失消息<ul>
<li>如果因为leader broker宕机了触发选举过程，集群选举了一个落后的leader之后就会出现消息丢失的情况。</li>
<li>由于broker持久化消息需要先通过写入页缓存，再从页缓存写入磁盘，即通过异步批量刷盘的方式写入磁盘，也就是说需要消息达到一定的量和时间间隔才会去刷盘，具体的刷盘操作一般是由操作系统调度，如果刷盘之前导致broker宕机了也会出现消息丢失的情况。</li>
</ul>
</li>
<li>消费者丢失消息<ul>
<li>拉取消息之后，先提交offset，后处理消息：如果处理消息的时候突然宕机或者处理错误，但是此时offset又已经提交，等消费者重启恢复之后，就会从offset的下一个开始消费，之前未处理完的消息就会不再做处理，这时候对于消费者来说就是消息丢失了。</li>
<li>拉取消息之后，先处理消息，再提交offset：如果消息已经处理好了，但是要提交offset的时候突然宕机了，这时候重启服务，就会出现消费者会重新拉取上次消费了的消息进行再次消费的情况，此时会出现重复消费的情况或者直接丢失消息。</li>
</ul>
</li>
</ul>
<h3 id="有没有调用过一些三方接口？怎么实现的？"><a href="#有没有调用过一些三方接口？怎么实现的？" class="headerlink" title="有没有调用过一些三方接口？怎么实现的？"></a>有没有调用过一些三方接口？怎么实现的？</h3><p>1、文本审核内容审核</p>
<p>2、音视频内容审核</p>
<h3 id="对于微信接口的AccessToken怎么处理那个有效时间无效问题？"><a href="#对于微信接口的AccessToken怎么处理那个有效时间无效问题？" class="headerlink" title="对于微信接口的AccessToken怎么处理那个有效时间无效问题？"></a>对于微信接口的AccessToken怎么处理那个有效时间无效问题？</h3><p>定时刷新，将对应的AccessToken存在Redis里面，每次需要使用的时候，先从缓存中找，如果缓存中的东西失效了，那么就重新获取一次token进行令牌刷新并存在Redis里面，但是存取的时间是6000s，防止处理事务处理过程中出现失效的情况。</p>
<h3 id="如果服务器CPU或者内存满了怎么分析？"><a href="#如果服务器CPU或者内存满了怎么分析？" class="headerlink" title="如果服务器CPU或者内存满了怎么分析？"></a>如果服务器CPU或者内存满了怎么分析？</h3><p>1、使用监控工具确定是什么资源占用率高</p>
<p>2、使用系统工具查看占用cpu高的进程</p>
<p>3、查看日志找到异常或者错误信息，来定位具体是什么地方导致线程阻塞从而导致的cpu飙升，并及时优化代码。</p>
<h3 id="对于高并发问题，要怎么处理数据的一致性问题以及保证线程安全？"><a href="#对于高并发问题，要怎么处理数据的一致性问题以及保证线程安全？" class="headerlink" title="对于高并发问题，要怎么处理数据的一致性问题以及保证线程安全？"></a>对于高并发问题，要怎么处理数据的一致性问题以及保证线程安全？</h3><p><strong>解决方案：</strong></p>
<ul>
<li>使用并发容器，如ConcurrentHashMap，它是线程安全的数据结构，可用于高并发场景。</li>
<li>通过分布式锁的方式，保证数据一致性，确保在同一时间只有一个线程可以访问共享资源。</li>
<li>根据业务需求，设置合适的数据库隔离级别，如读未提交、读已提交、可重复读、串行化，以保证数据的一致性和隔离性。</li>
</ul>
<h3 id="常用的锁有哪些？"><a href="#常用的锁有哪些？" class="headerlink" title="常用的锁有哪些？"></a>常用的锁有哪些？</h3><h3 id="介绍一下互斥锁、自旋锁"><a href="#介绍一下互斥锁、自旋锁" class="headerlink" title="介绍一下互斥锁、自旋锁"></a>介绍一下互斥锁、自旋锁</h3><p>互斥锁：用于保护共享资源，同一时间只允许一个线程访问共享资源，其他线程需要等待锁的释放。</p>
<h3 id="Redis的Set扩容机制如何实现？"><a href="#Redis的Set扩容机制如何实现？" class="headerlink" title="Redis的Set扩容机制如何实现？"></a>Redis的Set扩容机制如何实现？</h3><p>1、当Set元素数量达到一定的阈值的时候，创建新的哈希表</p>
<p>2、Redis会逐一将原来哈希表的元素根据新的哈希映射函数分配到新的哈希表中</p>
<p>3、更新指针，这个指针指向的是存储哈希表的内存地址，以便在扩容过程中可以正确地切换到新的哈希表。</p>
<h3 id="介绍一下hashmap以及如何解决哈希冲突的？"><a href="#介绍一下hashmap以及如何解决哈希冲突的？" class="headerlink" title="介绍一下hashmap以及如何解决哈希冲突的？"></a>介绍一下hashmap以及如何解决哈希冲突的？</h3><p>问烂了、已经不想打字了，补充几个其他相关的题</p>
<h4 id="为什么hashmap要在红黑树节点小于等于6的时候转回链表？"><a href="#为什么hashmap要在红黑树节点小于等于6的时候转回链表？" class="headerlink" title="为什么hashmap要在红黑树节点小于等于6的时候转回链表？"></a>为什么hashmap要在红黑树节点小于等于6的时候转回链表？</h4><ul>
<li>最主要的原因是因为节点数小于等于6的时候，链表和红黑树查询平均时间复杂度几乎一样，都是O（n），在性能差异不大的情况下，红黑树的维护成本远远大于链表的维护成本。</li>
<li>根据概率论的泊松分布，造成哈希冲突导致桶的的链表长度等于6的概率很大，而查询的平均复杂度和红黑树一样，在同等效率下选择开销更小的链表结构。</li>
</ul>
<h4 id="为什么hashmap负载因子是0-75？"><a href="#为什么hashmap负载因子是0-75？" class="headerlink" title="为什么hashmap负载因子是0.75？"></a>为什么hashmap负载因子是0.75？</h4><p>1、避免频繁扩容带来的性能损失</p>
<p>2、提高空间利用率，负载因子 = 存储的元素数量 / 哈希表可存储元素的总数量</p>
<p>3、较小的负载因子能够减少哈希冲突，提高性能，这也是经验之谈。</p>
<h4 id="哈希扩容的时候，是根据什么来扩容的？"><a href="#哈希扩容的时候，是根据什么来扩容的？" class="headerlink" title="哈希扩容的时候，是根据什么来扩容的？"></a>哈希扩容的时候，是根据什么来扩容的？</h4><p>元素数量 / 哈希表的容量与负载因子进行比较，</p>
<h3 id="索引失效有哪些？"><a href="#索引失效有哪些？" class="headerlink" title="索引失效有哪些？"></a>索引失效有哪些？</h3><p>6种，左右模糊或左模糊，对索引使用函数，对索引隐式类型转换（查询的时候数据类型转换，实际上会用到函数CAST），对索引进行表达式计算(where id + 1 = 10不行)，联合索引非左匹配原则，where子句有OR</p>
<p>对索引使用函数，对索引隐式类型转换（查询的时候数据类型转换，实际上会用到函数CAST），对索引进行表达式计算(where id + 1 = 10不行)，这三种造成失效的原因就是索引存的是原始的值，而不是使用函数或者通过计算得到的新的值，如果建立对某个字段使用函数或者计算的索引来解决这个问题。例如建立索引<code>alter table t_user add key idx_name_length ((length(name)));</code></p>
<h3 id="介绍一些JWT，比较一下和Cookie-Session的区别？"><a href="#介绍一些JWT，比较一下和Cookie-Session的区别？" class="headerlink" title="介绍一些JWT，比较一下和Cookie-Session的区别？"></a>介绍一些JWT，比较一下和Cookie-Session的区别？</h3><p>阿巴阿巴阿巴。。。。。</p>
<h3 id="JWT是怎么解决防篡改问题的？"><a href="#JWT是怎么解决防篡改问题的？" class="headerlink" title="JWT是怎么解决防篡改问题的？"></a>JWT是怎么解决防篡改问题的？</h3><p>阿巴阿巴阿巴。。。。。</p>
<h3 id="介绍一下如何判断死亡对象的方法以及垃圾收集算法"><a href="#介绍一下如何判断死亡对象的方法以及垃圾收集算法" class="headerlink" title="介绍一下如何判断死亡对象的方法以及垃圾收集算法"></a>介绍一下如何判断死亡对象的方法以及垃圾收集算法</h3><p><strong>判断对象死亡的方法：</strong></p>
<ol>
<li>引用计数法：当被引用了就计数+1，引用失效就-1，当计数器的值==0就说明此对象已经死亡。</li>
<li>可达性分析算法：如果某个对象不能有一条路径到达GC ROOTS，如果没有的话，就说明这个对象已经死亡，有的话就说明，这个对象没有死亡。</li>
</ol>
<blockquote>
<p>这个时候实际上只能表示对象可以回收了，但是不一定代表着一定会回收，宣布一个对象死亡，要进行两次标记，可达性分析算法中不可达对象就会先第一次被标记并进行一次筛选，筛选条件就是此对象是否有必要执行finalize()，如果finalize()方法没有被覆盖，或者被虚拟栈调用过了，就会被认为没有必要被执行。被判定需要执行的对象就会被放入一个队列进行二次标记，除非这个对象跟引用链上的任何一个对象建立关联，否则就会被回收。</p>
</blockquote>
<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><blockquote>
<p><strong>简介</strong></p>
<ul>
<li>进程：计算机正在运行的一个程序实例，比如打开微信</li>
<li>线程：又称轻量级进程，多个线程可以在同一个进程中同时执行，并且共享进程的资源比如：内存空间、网络连接等，举例：你打开的微信就有一个线程专门用来拉取别人发你的最新的消息。</li>
</ul>
</blockquote>
<ol>
<li>一个进程可以产生多个线程，多个进程间共享堆和方法区，每个线程自己独立的程序计数器、虚拟机栈和本地方法栈。</li>
<li>进程线程最大的不同就是各进程是独立的，而线程不一定因为同一进程中的线程极有可能会相互影响。</li>
<li>线程执行开销小，不利于资源的管理和保护但是进程相反。</li>
</ol>
<h3 id="介绍一下协程（不会）"><a href="#介绍一下协程（不会）" class="headerlink" title="介绍一下协程（不会）"></a>介绍一下协程（不会）</h3><p>协程是相较于线程更加轻量级的一种执行单位，协程通常不会被内核调度所以协程切换不会涉及内核级的上下文切换，核心思想就是可以暂停和回复的执行单元，一个可以在某一个点挂起，然后执行权交给其他协程，等其他协程执行完毕之后可以恢复，从挂起的地方继续执行。</p>
<p>协程的并行数也受限于CPU的核心数，多个协程在同一线程中交替执行，充分利用了单线程的资源。但协程并发的时候可以通过调度器来控制哪个协程何时执行。</p>
<h3 id="平时怎么学习的？"><a href="#平时怎么学习的？" class="headerlink" title="平时怎么学习的？"></a>平时怎么学习的？</h3><p>阿巴阿巴阿巴阿巴阿巴阿巴。。。</p>
<h3 id="了不了解ElasticSearch？（并不了解）"><a href="#了不了解ElasticSearch？（并不了解）" class="headerlink" title="了不了解ElasticSearch？（并不了解）"></a>了不了解ElasticSearch？（并不了解）</h3><p>所以无解</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-快手测开 2023 - 7 - 11</title>
    <url>/2023/07/23/%E9%9D%A2%E7%BB%8F-%E5%BF%AB%E6%89%8B%E6%B5%8B%E5%BC%80%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="简单介绍一下二手市场整体的架构，数据流的实现？"><a href="#简单介绍一下二手市场整体的架构，数据流的实现？" class="headerlink" title="简单介绍一下二手市场整体的架构，数据流的实现？"></a>简单介绍一下二手市场整体的架构，数据流的实现？</h2><p><strong>整体架构：</strong></p>
<ol>
<li>持久层和缓存的选型<ol>
<li>MySQL作为持久层：<ol>
<li>支持复杂条件数据查询：在二手市场中，用户会根据自身需求筛选不同的条件进行各种复杂的查询，例如按照不同条件筛选商品等，MySQL提供丰富的查询语言和索引支持，能够高效查询相关数据。</li>
<li>结构化数据存储：二手市场涉及大量的结构化数据，例如：用户信息，商品信息等。而MySQL是关系型数据库，适合存储和管理结构化数据，提供事务支持，保证数据的一致性和完整性。</li>
</ol>
</li>
<li>Redis作为缓存：<ol>
<li>二手市场是多读少写的场景，用户会频繁的浏览商品，但是对商品的修改变更有限，所以可以将物品信息添加至Redis中有效减轻MySQL的读取压力，提高系统的响应和性能。</li>
</ol>
</li>
</ol>
</li>
<li>服务的拆分方式</li>
</ol>
<p>暂时因为是单体架构，没有钱去购买太多的服务器，所以服务暂时没有进行具体的划分，如果要进行划分的话我觉得可以划分成以下几种服务：</p>
<ol>
<li><p>用户服务：主要是对用户的身份信息进行认证和鉴权。</p>
</li>
<li><p>UGC消息通知：可以处理二手市场发布、编辑商品信息后，通过邮件、消息推送的方式告知用户。</p>
</li>
<li><p>商品信息服务：负责二手商品信息的发布、编辑、删除、搜索等功能。</p>
</li>
<li><p>缓存服务：应对二手市场这种读大于写的场景，可以将最新的50条商品信息放入系统缓存中，优化用户查看商品的体验。</p>
</li>
<li><p>支付服务：支付服务负责处理用户的支付请求，与第三方支付平台进行交互，并确保支付的安全性和可靠性。</p>
</li>
<li><p>文件服务：用于处理用户上传的图片、视频。</p>
</li>
<li><p>服务容灾和负载均衡方式</p>
<ol>
<li>服务容灾：<ol>
<li>定期对系统的数据进行备份</li>
<li>定期检查维护服务器的实例，修复代码BUG等</li>
</ol>
</li>
<li>负载均衡：<ol>
<li>CDN服务：将静态资源（图片、视频等）放置在内容分发网络中，加快资源加载速度，减少服务器负载</li>
<li>缓存数据，使用缓存减轻服务器负担，提高响应速度</li>
<li>反向代理：通过Nginx反向代理服务实现负载均衡，等后面有多台服务器之后将请求分发给不同的服务器，提高服务可扩展性。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>数据流实现：</strong></p>
<ol>
<li>用户上传商品：<ol>
<li>用户在应用中填写商品信息，并上传相关照片</li>
<li>上传的用户信息和照片URL被发送到服务器中进行处理和存储</li>
<li>服务器对传过来的数据进行数据库存储，并生成一个唯一ID</li>
</ol>
</li>
<li>商品展示和搜索：<ol>
<li>其他用户访问二手市场时，前端向后端请求商品数据</li>
<li>后端从数据库中获取数据列表，并返回给前端</li>
<li>用户可以根据自身的需求条件查询特定的商品，前端将搜索条件发送给后端，后端根据条件查询数据库并返回匹配的商品信息。</li>
</ol>
</li>
<li>商品详情获取：<ol>
<li>当用户点击某个商品的详情信息之后，前端发送请求，传递对应的商品ID给后端</li>
<li>后端根据商品ID在数据库中搜索并返回具体商品信息给前端展示</li>
</ol>
</li>
</ol>
<h2 id="如果检索某个具体商品是如何实现检索的？"><a href="#如果检索某个具体商品是如何实现检索的？" class="headerlink" title="如果检索某个具体商品是如何实现检索的？"></a>如果检索某个具体商品是如何实现检索的？</h2><h2 id="查询的时候如何避免慢查询？"><a href="#查询的时候如何避免慢查询？" class="headerlink" title="查询的时候如何避免慢查询？"></a>查询的时候如何避免慢查询？</h2><ul>
<li>索引优化，将经常用到的字段创建索引（除去经常更新的字段、重复度很高的字段、数据量较少的情况），比如单列索引和联合索引，从而避免全表扫描。</li>
<li>分页查询：对于返回大量的数据查询，使用分页查询的方式，限制返回的数据量，避免一次返回大量的数据导致查询速率很慢。</li>
<li>缓存查询：对于一些比较查询比较频繁的数据可以使用缓存来避免每次都进行数据库查询。</li>
<li>合理设计数据库的表结构：比如说说评论查询，二级评论可以通过添加一个masterId字段(对应的说说id)来快速定位到此二级评论是归属于哪条说说之下。</li>
</ul>
<h2 id="如何正确的创建索引？（即：什么时候创建索引？）"><a href="#如何正确的创建索引？（即：什么时候创建索引？）" class="headerlink" title="如何正确的创建索引？（即：什么时候创建索引？）"></a>如何正确的创建索引？（即：什么时候创建索引？）</h2><ul>
<li>字段具有唯一性限制，即重复度很低，且不是经常修改的字段</li>
<li>经常用于where子句查询</li>
<li>经常用于group by 或者 order by查询</li>
<li>表的数据量比较多的情况</li>
</ul>
<h2 id="二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？"><a href="#二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？" class="headerlink" title="二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？"></a>二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？</h2><ol>
<li>正确、错误、空物品查询</li>
<li>物品大小写查询</li>
<li>高并发查询</li>
<li>过滤项查询</li>
<li>物品状态查询</li>
<li>安全性测试：比如SQL注入</li>
<li>边界值测试：比如输入极限情况下，很长的字符串验证系统是否能正确处理。</li>
</ol>
<h2 id="后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？"><a href="#后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？" class="headerlink" title="后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？"></a>后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？</h2><ol>
<li>统计性能的方式：<ol>
<li>日志记录</li>
<li>性能监控工具的使用：比如New Relic、Prometheus等</li>
<li>负载测试，模拟大量并发请求，观察系统的响应情况和性能指标。</li>
</ol>
</li>
<li>有，限流操作如下：<ol>
<li>固定窗口计时器：设置一个固定时间窗口，例如</li>
</ol>
</li>
</ol>
<h2 id="HashMap、HashSet、HashTable的区别？"><a href="#HashMap、HashSet、HashTable的区别？" class="headerlink" title="HashMap、HashSet、HashTable的区别？"></a>HashMap、HashSet、HashTable的区别？</h2><p><strong>HashMap和HashTable区别：</strong></p>
<ul>
<li>线程是否安全：HashMap是非线程安全，HashTable是线程安全（通过synchronized修饰实现）。</li>
<li>效率：由于HashMap线程不安全，HashMap比HashTable效率高，但是HashTable几乎被淘汰，平时一般不会用HashTable。</li>
<li>键值对存值问题：HashMap是可存null键和null值，HashTable不允许有null键和null值，否则会抛出异常NPE。</li>
<li>初始容量大小和每次扩充容量大小不同：HashTable初始化容量是11，每次扩容就是2n+1，HashMap初始化容量是16，每次扩容就是原来的2n倍。</li>
<li>底层数据结构：HashMap是<strong>数组+<strong><strong>链表</strong></strong>/红黑树</strong>实现，在解决哈希冲突时，当链表长度大于阈值（默认为8），将链表转化成红黑树（将链表转化成红黑树之前，如果数组长度小于64就会进行数组扩容，而不是转换成红黑树），以减少搜索时间，而HashTable是<strong>数组+链表</strong>的形式实现。</li>
</ul>
<p><strong>HashMap</strong>和<strong>HashSet的区别:</strong></p>
<ul>
<li>HashMap实现Map接口，HashSet实现Set接口。</li>
<li>HashMap存储键值对，HashSet只存储对象。</li>
<li>HashMap通过put方法添加元素，HashSet通过add()向Set中添加元素。</li>
<li>HashMap使用Key计算hashcode，HashSet使用成员对象计算hashcode值。</li>
</ul>
<h2 id="HashMap是线程的安全的吗？介绍一下ConcurrentHashMap"><a href="#HashMap是线程的安全的吗？介绍一下ConcurrentHashMap" class="headerlink" title="HashMap是线程的安全的吗？介绍一下ConcurrentHashMap"></a>HashMap是线程的安全的吗？介绍一下ConcurrentHashMap</h2><p>线程<strong>不安全</strong>，因为多线程情况下，HashMap进行键值对存值的时候，可能会因为分配到一个桶里面造成数据覆盖的风险，比如线程1，2同时进行put操作，此时正好发生了hash冲突，线程1执行完hash冲突判断之后，时间片耗尽挂起，此时线程2进行hash冲突判断并对数据插入到链表中，后面等线程1重新获取到时间片，进行插入操作就会覆盖掉线程插入的数据。</p>
<p><strong>ConcuurentHashMap：</strong></p>
<p>Java8以上数据结构是Node数组+链表/红黑树，哈希冲突时当链表长度大于一定长度时，链表就会转换成红黑树。</p>
<h2 id="接口和抽象类的区别？"><a href="#接口和抽象类的区别？" class="headerlink" title="接口和抽象类的区别？"></a>接口和抽象类的区别？</h2><ul>
<li>接口是对类的行为进行约束，实现了某个接口就是已经拥有了具体的行为，抽象类是代码复用，强调的是类的从属关系。</li>
<li>接口的成员变量只能用public static final修饰且不可修改和初始化，抽象类的成员变量默认为default类型，可以在子类被重新赋值定义。</li>
<li>一个类可以实现多个接口但是只能继承一个父类。</li>
</ul>
<h2 id="如果某个网页打不开了，排查手段有哪些？"><a href="#如果某个网页打不开了，排查手段有哪些？" class="headerlink" title="如果某个网页打不开了，排查手段有哪些？"></a>如果某个网页打不开了，排查手段有哪些？</h2><h2 id="Linux中查看主目录下以-log结尾的文件？"><a href="#Linux中查看主目录下以-log结尾的文件？" class="headerlink" title="Linux中查看主目录下以.log结尾的文件？"></a>Linux中查看主目录下以.log结尾的文件？</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/home/directory -<span class="built_in">type</span> f -name <span class="string">&quot;*.log&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>find</code>：命令本身，用于查找文件和目录。</li>
<li><code>/path/to/home/directory</code>：替换为你要查找的主目录的路径。例如，如果你要在当前用户的主目录下查找，可以使用<code>~</code>代替这个路径。</li>
<li><code>-type f</code>：表示只查找普通文件，不包括目录等其他类型的文件。</li>
<li><code>-name &quot;*.log&quot;</code>：表示查找文件名以<code>.log</code>结尾的文件。<code>*.log</code>是通配符，表示匹配所有以<code>.log</code>结尾的文件名。</li>
</ul>
<h2 id="如何查询某个日志的内容？"><a href="#如何查询某个日志的内容？" class="headerlink" title="如何查询某个日志的内容？"></a>如何查询某个日志的内容？</h2><ul>
<li>Cat</li>
<li>Head</li>
<li>Tail</li>
<li>Less</li>
<li>More</li>
</ul>
<h2 id="比较一下less命令和more命令的区别？"><a href="#比较一下less命令和more命令的区别？" class="headerlink" title="比较一下less命令和more命令的区别？"></a>比较一下less命令和more命令的区别？</h2><ul>
<li>less支持前后翻页，more只支持向后翻页</li>
<li>less是根据要展示的内容加载到内存中，加快读取速度，more是将整个文件内容全部加载到内存中，可能会导致崩溃</li>
</ul>
<h2 id="算法题：力扣平衡字符串问题"><a href="#算法题：力扣平衡字符串问题" class="headerlink" title="算法题：力扣平衡字符串问题"></a>算法题：力扣平衡字符串问题</h2>]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-法大大Java实习 2023.4.6</title>
    <url>/2023/04/06/%E9%9D%A2%E7%BB%8F-%E6%B3%95%E5%A4%A7%E5%A4%A7Java%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E6%B3%95%E5%A4%A7%E5%A4%A7(2023.4.6).png" alt="法大大(2023.4.6)"></p>
<h2 id="总结：（答得不是很完善的地方总结一下）"><a href="#总结：（答得不是很完善的地方总结一下）" class="headerlink" title="总结：（答得不是很完善的地方总结一下）"></a>总结：（答得不是很完善的地方总结一下）</h2><h3 id="接口和抽象类的共同点和区别："><a href="#接口和抽象类的共同点和区别：" class="headerlink" title="接口和抽象类的共同点和区别："></a>接口和抽象类的共同点和区别：</h3><p><strong>共同点：</strong> </p>
<ul>
<li>不可以被实例化</li>
<li>可以包含抽象方法</li>
<li>可以有默认的实现方法</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>接口对类的行为进行约束，实现某接口已经拥有了的具体行为，抽象类代码复用，强调的是从属关系</li>
<li>接口的成员变量只能用public static final修饰且不可修改并初始化，抽象类默认是default类型，可以在子类被重新定义且重新赋值</li>
<li>一个类只能继承一个抽象类（单继承），可实现多个接口。</li>
</ul>
<h3 id="和-equals-方法"><a href="#和-equals-方法" class="headerlink" title="== 和 equals()方法"></a>== 和 equals()方法</h3><p><strong>==：</strong></p>
<ul>
<li>对于基本数据类型，直接比较值的大小</li>
<li>对于引用类型，比较对象的内存地址</li>
</ul>
<p><strong>equals（）方法：</strong></p>
<p>比较对象是否相等，即对象的内存地址是否相等，一般也分为两种情况</p>
<ul>
<li>重写了，一般比较两个对象的成员属性是否相等</li>
<li>未重写，比较的该类型的对象是否相等</li>
</ul>
<h3 id="try-catch-finally方法"><a href="#try-catch-finally方法" class="headerlink" title="try-catch-finally方法"></a>try-catch-finally方法</h3><ul>
<li>如果在catch中return了，那么finally里面的逻辑会在return之前被执行。</li>
<li>如果catch和finally都有return，那么catch的return会被忽略，</li>
<li>因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</li>
<li>finally一般用于资源回收、比如线程、数据库资源回收的情况</li>
</ul>
<h3 id="HashMap和HashSet区别"><a href="#HashMap和HashSet区别" class="headerlink" title="HashMap和HashSet区别"></a>HashMap和HashSet区别</h3><ul>
<li>前者实现了Map接口，后者实现了Set接口</li>
<li>HashSet底层是HashMap实现存储的</li>
</ul>
<h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><ul>
<li>前者继承了AbstractMap类，后者继承了Dictionary类</li>
<li>HashMap线程不安全，HashTable线程安全</li>
<li>contains不一样，HashMap没有contains方法只有containsValue和containsKey方法，但是HashTable这三个方法都有</li>
<li>key-value是否能为null，HashMap 都可以为null，HashTable都不可以null，否则就是空指针异常</li>
<li>获取hashCode方法不一样</li>
</ul>
<p>&emsp;&emsp;HashMap先调用hashCode获取到了hash值之后，再与右移16位的hash值相异或获取hash值。</p>
<p>&emsp;&emsp;HashTable直接通过hashCode方法获取</p>
<ul>
<li>解决hash冲突方法不一样</li>
</ul>
<p>&emsp;&emsp;HashMap通过数组+链表/红黑树，如果链表长度大于8，变成红黑树，若链表长度后面小于6，转回链表格式</p>
<p>&emsp;&emsp;HashTable只有链表存储</p>
<h3 id="项目介绍："><a href="#项目介绍：" class="headerlink" title="项目介绍："></a>项目介绍：</h3><p>因为主要是自己写的、在redis那一块也比较熟悉，也自己解决了缓存雪崩的问题，后面也解决了缓存和数据库一致性问题，但是面试的时候忘记提了，可能提了会更加加分~</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-深信服GO一二面</title>
    <url>/2023/09/28/%E9%9D%A2%E7%BB%8F-%E6%B7%B1%E4%BF%A1%E6%9C%8DGO%E4%B8%80%E4%BA%8C%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="算法：30min"><a href="#算法：30min" class="headerlink" title="算法：30min"></a>算法：30min</h3><p>（1）合并三个升序字符串，不能创建新的链表，而是使用已有链表实现。——手撕</p>
<p>（2）在一个长字符串里面，找出是否出现过的某个字符或子字符串。（遍历或者hashset手撕）</p>
<h3 id="场景题："><a href="#场景题：" class="headerlink" title="场景题："></a>场景题：</h3><p>（1）给两篇文章，怎么从文章1中找出文章2重复的内容，前提是：内存资源有限。</p>
<p>考虑因素：内存有限、高效</p>
<p>深度：除了使用哈希、布隆、MySQL、分段比较这些有没有其他的方法？</p>
<p>引申问题：如果有五个服务器、现在需要进行负载均衡，可以怎么实现？（哈希取模，虚拟地址分配到哈希环，实现虚拟地址和服务器地址映射）</p>
<p>（2）如果有一个10G的文件在服务器中，我现在客户端需要从服务器下载，但是网络不是很稳定，并且能保证用户能下载完文件，传输数据用的udp协议不是tcp协议，应该需要注意些什么？</p>
<p>考虑因素：网络不稳定，传输方式居然是udp。。。</p>
<p>感觉在应用层实现一个tcp机制，保证数据传输的有序、可靠性。</p>
<h3 id="常见八股："><a href="#常见八股：" class="headerlink" title="常见八股："></a>常见八股：</h3><p>（1）http和https之间区别？</p>
<p>（2）为什么现在大部分请求还是http而不是rpc？</p>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><h3 id="项目："><a href="#项目：" class="headerlink" title="项目："></a>项目：</h3><p>（1）比较熟悉的项目是什么？</p>
<p>（2）微布校园的难点有哪些？怎么解决？（缓存雪崩和击穿、缓存和数据库一致性问题、慢SQL优化）</p>
<p>（3）如果缓存放到一个进程中去读取会出现什么问题？</p>
<h3 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h3><p>（1）如果服务器资源有限如何合理利用缓存？（我的理解是部分经常读的数据写到缓存，经常就修改的就不写入缓存、从数据库拉取）</p>
<p>（2）如果资源有限，有大量数据需要处理，怎么去合理利用内存？（我想的是分段处理数据，类似于MySQL的分页查询，分段处理数据）</p>
<h3 id="常见八股"><a href="#常见八股" class="headerlink" title="常见八股"></a>常见八股</h3><p>（1）怎么获取http请求的一些头部、body部分的？</p>
<p>（2）http请求的一些数据是怎么到达代码中的？ （没有回答上来）</p>
<p>（3）http中post和get请求有什么区别？</p>
<p>（4）http传输数据过程中会有什么问题？</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经- 星环科技Java实习</title>
    <url>/2023/07/12/%E9%9D%A2%E7%BB%8F-%E6%98%9F%E7%8E%AF%E7%A7%91%E6%8A%80Java%E5%AE%9E%E4%B9%A0-2023-6-12/</url>
    <content><![CDATA[<h2 id="最高QPS是承受多少？服务器部署位置？目前是单体应用？"><a href="#最高QPS是承受多少？服务器部署位置？目前是单体应用？" class="headerlink" title="最高QPS是承受多少？服务器部署位置？目前是单体应用？"></a>最高QPS是承受多少？服务器部署位置？目前是单体应用？</h2><h2 id="为什么要使用雪花算法？（分布式id、雪花算法组成）"><a href="#为什么要使用雪花算法？（分布式id、雪花算法组成）" class="headerlink" title="为什么要使用雪花算法？（分布式id、雪花算法组成）"></a>为什么要使用雪花算法？（分布式id、雪花算法组成）</h2><h2 id="有无发布订阅的功能？应用场景有哪些？"><a href="#有无发布订阅的功能？应用场景有哪些？" class="headerlink" title="有无发布订阅的功能？应用场景有哪些？"></a>有无发布订阅的功能？应用场景有哪些？</h2><h2 id="Redis的应用场景是哪些？"><a href="#Redis的应用场景是哪些？" class="headerlink" title="Redis的应用场景是哪些？"></a>Redis的应用场景是哪些？</h2><h2 id="什么情况下会出现缓存雪崩？怎么防止缓存雪崩的问题？"><a href="#什么情况下会出现缓存雪崩？怎么防止缓存雪崩的问题？" class="headerlink" title="什么情况下会出现缓存雪崩？怎么防止缓存雪崩的问题？"></a>什么情况下会出现缓存雪崩？怎么防止缓存雪崩的问题？</h2><h2 id="怎么保证数据库和redis的一致性问题？"><a href="#怎么保证数据库和redis的一致性问题？" class="headerlink" title="怎么保证数据库和redis的一致性问题？"></a>怎么保证数据库和redis的一致性问题？</h2><h2 id="怎么解决用户禁言时间失效的问题？"><a href="#怎么解决用户禁言时间失效的问题？" class="headerlink" title="怎么解决用户禁言时间失效的问题？"></a>怎么解决用户禁言时间失效的问题？</h2><h2 id="介绍一下Java集合"><a href="#介绍一下Java集合" class="headerlink" title="介绍一下Java集合"></a>介绍一下Java集合</h2><h2 id="ArrayList是基于什么实现的？-从ArrayList和Array的区别出发）"><a href="#ArrayList是基于什么实现的？-从ArrayList和Array的区别出发）" class="headerlink" title="ArrayList是基于什么实现的？(从ArrayList和Array的区别出发）"></a>ArrayList是基于什么实现的？(从ArrayList和Array的区别出发）</h2><h2 id="ArrayList的怎么动态扩容的？"><a href="#ArrayList的怎么动态扩容的？" class="headerlink" title="ArrayList的怎么动态扩容的？"></a>ArrayList的怎么动态扩容的？</h2><ol>
<li><strong>初始化容量：</strong> 当你创建一个新的ArrayList对象时，它会分配一个初始容量，通常是10个元素的大小（这个值可以根据需要进行修改）。</li>
<li><strong>添加元素：</strong> 当你向ArrayList中添加元素时，如果当前元素数量达到了容量上限(一般是元素数量到达9/10的时候)，就会触发动态扩容。</li>
<li><strong>扩容操作：</strong> 在进行动态扩容时，ArrayList会创建一个新的更大容量的数组，然后将原数组中的元素复制到新数组中。</li>
<li><strong>更新引用：</strong> 一旦新数组中的元素复制完成，ArrayList会更新内部引用，指向新的数组。</li>
</ol>
<h2 id="介绍一下JVM的内存区域（面试官其实是想要我自己说出来程序计数器、虚拟机栈等的作用。。。）"><a href="#介绍一下JVM的内存区域（面试官其实是想要我自己说出来程序计数器、虚拟机栈等的作用。。。）" class="headerlink" title="介绍一下JVM的内存区域（面试官其实是想要我自己说出来程序计数器、虚拟机栈等的作用。。。）"></a>介绍一下JVM的内存区域（面试官其实是想要我自己说出来程序计数器、虚拟机栈等的作用。。。）</h2><h2 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h2><h2 id="介绍一下垃圾回收算法"><a href="#介绍一下垃圾回收算法" class="headerlink" title="介绍一下垃圾回收算法"></a>介绍一下垃圾回收算法</h2><h2 id="MySQL的常用引擎"><a href="#MySQL的常用引擎" class="headerlink" title="MySQL的常用引擎?"></a>MySQL的常用引擎?</h2><h2 id="MySQL如何实现MVCC的原理？（从ReadView角度回答）"><a href="#MySQL如何实现MVCC的原理？（从ReadView角度回答）" class="headerlink" title="MySQL如何实现MVCC的原理？（从ReadView角度回答）"></a>MySQL如何实现MVCC的原理？（从ReadView角度回答）</h2><h2 id="多线程的应用场景"><a href="#多线程的应用场景" class="headerlink" title="多线程的应用场景"></a>多线程的应用场景</h2><h2 id="如何创建线程池？为什么要使用线程池？"><a href="#如何创建线程池？为什么要使用线程池？" class="headerlink" title="如何创建线程池？为什么要使用线程池？"></a>如何创建线程池？为什么要使用线程池？</h2><h2 id="如何解决线程安全问题？"><a href="#如何解决线程安全问题？" class="headerlink" title="如何解决线程安全问题？"></a>如何解决线程安全问题？</h2><h2 id="了解自旋锁、乐观锁、悲观锁吗？（自旋锁不会。。。）"><a href="#了解自旋锁、乐观锁、悲观锁吗？（自旋锁不会。。。）" class="headerlink" title="了解自旋锁、乐观锁、悲观锁吗？（自旋锁不会。。。）"></a>了解自旋锁、乐观锁、悲观锁吗？（自旋锁不会。。。）</h2><h2 id="SpringBoot的常用注解"><a href="#SpringBoot的常用注解" class="headerlink" title="SpringBoot的常用注解"></a>SpringBoot的常用注解</h2><p>总结一下：</p>
<p>1、依赖注入：@Autowired(<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称)、@Resource、@Inject</p>
<p>2、组件声明：@Component、@Bean、@Configuration、@Repository、@Service、@Controller</p>
<p>3、其他：@ComponentScan、@Value</p>
<p>以及其他等等。。。。</p>
<h2 id="Component和-Bean注解的区别？"><a href="#Component和-Bean注解的区别？" class="headerlink" title="@Component和@Bean注解的区别？"></a>@Component和@Bean注解的区别？</h2><h2 id="Spring的设计模式有哪些？"><a href="#Spring的设计模式有哪些？" class="headerlink" title="Spring的设计模式有哪些？"></a>Spring的设计模式有哪些？</h2><h2 id="怎么部署Java服务？"><a href="#怎么部署Java服务？" class="headerlink" title="怎么部署Java服务？"></a>怎么部署Java服务？</h2><h2 id="查看cpu、进程、内存命令"><a href="#查看cpu、进程、内存命令" class="headerlink" title="查看cpu、进程、内存命令"></a>查看cpu、进程、内存命令</h2>]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-滴滴golang后端实习 2023 - 07 - 04</title>
    <url>/2023/07/23/%E9%9D%A2%E7%BB%8F-%E6%BB%B4%E6%BB%B4Golang%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="HTTP有哪些请求方式？"><a href="#HTTP有哪些请求方式？" class="headerlink" title="HTTP有哪些请求方式？"></a>HTTP有哪些请求方式？</h2><ul>
<li>PUT：将数据存储在服务器，覆盖指定URL，常用于更新资源</li>
<li>GET：从服务器获取数据，GET请求是幂等的，即多次请求相同的URL会返回相同的结果</li>
<li>POST：向服务器提交数据，通常用于向服务器发送数据，比如提交表单</li>
<li>DELETE：从服务器删除指定的URL资源。</li>
<li>HEAD：类似于GET请求，但服务器只返回头部信息，不返回实际数据。主要用于检查资源的元数据，例如确认资源是否存在或最后修改日期等。</li>
<li>OPTIONS：获取目标URL支持的请求方法信息。用于查询服务器支持哪些HTTP方法。</li>
<li>PATCH：用于对资源进行局部更新，更新指定的字段而不是像PUT一样更新整个资源。</li>
<li>TRACE：用于目标服务器上执行一个消息环回测试，主要用于诊断。</li>
<li>CONNECT：用于代理服务器请求，通常用于建立代理服务器的隧道。</li>
</ul>
<h2 id="POST和GET的使用场景及区别？"><a href="#POST和GET的使用场景及区别？" class="headerlink" title="POST和GET的使用场景及区别？"></a>POST和GET的使用场景及区别？</h2><p>POST主要用于客户端向服务端提交数据的时候使用，GET主要用于客户端向服务端获取请求的时候使用。</p>
<p>POST和GET实际上没有什么区别，如果硬要说有区别可见如下：</p>
<ul>
<li>GET方法产生一个数据包，POST方法产生两个数据包。<ul>
<li>GET方法会将header和data一并发给服务器，服务器响应200。</li>
<li>POST方法会先发送header给服务器，等服务器返回100之后发送data给服务器，然后服务器响应200。此方法在网络差的情况下，会稍微好一点，因为分两次发可能丢包率会小一些。（POST请求，数据包Firefox只会发一次）</li>
</ul>
</li>
<li>GET请求URL传递的参数会有长度限制，POST没有</li>
<li>GET请求传递参数放在URL中，POST放在Body部分</li>
<li>GET请求只接受ASCII字符，POST无限制</li>
<li>GET请求比POST更不安全，因为参数会外漏在URL，所以不能传递敏感信息。</li>
</ul>
<h2 id="Token在HTTP请求的时候会放在什么位置？"><a href="#Token在HTTP请求的时候会放在什么位置？" class="headerlink" title="Token在HTTP请求的时候会放在什么位置？"></a>Token在HTTP请求的时候会放在什么位置？</h2><p>一般存在header里面的Authorization字段，Java获取的此字段信息的代码一般如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取Authorization头的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorizationHeader</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        System.out.println(authorizationHeader);</span><br><span class="line"></span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？"><a href="#GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？" class="headerlink" title="GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？"></a>GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？</h2><ol>
<li>有长度限制。</li>
<li>不是HTTP本身限制了这个URL长度，一般是指定的浏览器或者服务器对它进行了长度的限制，超过一定的限制，服务器可能会直接返回错误或者截断URL，发生错误的请求。</li>
<li>解决URL超长问题方法如下：<ol>
<li>采取POST请求，因为POST请求对数据传输的长度没有限制</li>
<li>分割请求，如果传输的数据量很大，可以分割成很多小的请求分批次进行数据发送，然后服务端进行整合。</li>
<li>避免GET请求传输大量的数据。</li>
<li>压缩URL参数：通过将GET请求的URL参数进行压缩，转换成Base64来压缩参数，减少URL长度。</li>
</ol>
</li>
</ol>
<h2 id="介绍一下对Spring的理解"><a href="#介绍一下对Spring的理解" class="headerlink" title="介绍一下对Spring的理解"></a>介绍一下对Spring的理解</h2><p>是一款开源的轻量级开发框架，是多个模块的集合，比如：Spring IOC、Spring AOP等。</p>
<ol>
<li>SpringIOC（DI）</li>
<li>SpringAOP</li>
<li>可以整合其他技术开发</li>
</ol>
<h2 id="Spring、SpringMVC、SpringleBoot的区别"><a href="#Spring、SpringMVC、SpringleBoot的区别" class="headerlink" title="Spring、SpringMVC、SpringleBoot的区别"></a>Spring、SpringMVC、SpringleBoot的区别</h2><ul>
<li>Spring的核心模块就是Spring-Core（主要负责SpringIOC容器的依赖注入的支持），Spring其他所有功能都依赖此模块（包括SpringMVC）。</li>
<li>SpringMVC是Spring中得一个模块，主要赋予Spring快速构建MVC架构的Web程序能力，MVC（Model、View、Controller），其核心思想就是将业务逻辑、数据处理、视图显示分离来组织代码。</li>
<li>SpringBoot只是简化了配置，减少配置文件（比如xml文件、Java显示配置，开箱即用）</li>
</ul>
<h2 id="解释一下SpringIOC、SpringAOP"><a href="#解释一下SpringIOC、SpringAOP" class="headerlink" title="解释一下SpringIOC、SpringAOP"></a>解释一下SpringIOC、SpringAOP</h2><p><strong>Spring</strong> <strong>IOC<strong><strong>（</strong></strong>inversion of control<strong><strong>，</strong></strong>控制反转****）</strong></p>
<p>是一种设计思想，其思想就是把原本在程序创建对象的控制权，统一交给SpringIOC容器去管理，控制：创建对象实例的权利，反转：控制权交给Spring框架、IOC容器去管理。</p>
<p>有了SpringIOC之后，我们只需要直接从容器中获取对象即可，而对象的创建是交给SpringIOC容器去创建管理的。</p>
<p>实现方式：</p>
<p>1、从配置元数据获取DI的业务POJO（配置元数据：xml、Configuration、注解等）</p>
<p>2、将业务POJO形成BeanDefinition注入到Spring Container中</p>
<p>3、使用方通过AppllicationContext从SpringContainer中获取即可</p>
<p><strong>Spring AOP（Aspect Object Programming，<strong><strong>面向切面编程</strong></strong>）</strong></p>
<p>就是把公共逻辑抽出来，让开发者更加专注于业务逻辑开发。AOP是一种设计思想，是OOP的补充，OOP是面向类和对象的，但是AOP是面向不同切面的，一个切面可以横跨多个类和对象去操作，极大的提高了开发效率。</p>
<p>比如一个订单的创建，大致流程是：</p>
<p>1、权限校验</p>
<p>2、事务管理</p>
<p>3、创建订单</p>
<p>4、日志管理</p>
<p>使用AOP思想就可以把这四个步骤当作四个切面，让开发者专注于第三个切面，其他三个切面则使用基础的通用逻辑统一交给AOP封装管理。</p>
<h2 id="SpringAOP是如何实现的？"><a href="#SpringAOP是如何实现的？" class="headerlink" title="SpringAOP是如何实现的？"></a>SpringAOP是如何实现的？</h2><p>AOP实现原理：</p>
<p>AOP实现有两种方式，一种是Java原生的动态代理，一种是基于cglib的动态代理。默认的一般是原生的JDK的动态代理，但是这种代理方式无法代理没有接口的类，此时就会使用cglib代理这个没有接口实现的类。</p>
<h2 id="Sql注入攻击是什么？SQL注入是怎么产生的？"><a href="#Sql注入攻击是什么？SQL注入是怎么产生的？" class="headerlink" title="Sql注入攻击是什么？SQL注入是怎么产生的？"></a>Sql注入攻击是什么？SQL注入是怎么产生的？</h2><p><strong>SQL注入攻击****：</strong>针对使用SQL进行数据查询和操作的应用程序，基本原理是通过在用户输入的数据中插入恶意的SQL代码，从而让应用程序执行未经授权的数据库操作或者或者泄露敏感信息。</p>
<p>比如SQL = select * from user where username = ‘#{username}’ and password = ‘#{password}’，攻击者在用户名框或者密码输入框中输入恶意的SQL代码：<code>&#39; OR 1 = 1 --</code> 就会变成<code>select * from user where username = &#39;&#39; or 1 = 1  --&#39;and password=&#39;&#39;</code> ，此时<code>-- &#39; and password = &#39;&#39;</code> 已经被注释掉了实际上就是<code>select * from user where username = &#39;&#39; or 1 = 1;</code> 此时就会将所有用户的数据信息全部返回给前端。</p>
<p><strong>SQL注入的产生</strong></p>
<p>1、参数未校验，用户不正确的输入</p>
<p>2、特殊字符未转义，例如：=、–这种类型的符号</p>
<h2 id="什么时候需要创建索引？"><a href="#什么时候需要创建索引？" class="headerlink" title="什么时候需要创建索引？"></a>什么时候需要创建索引？</h2><ul>
<li>字段具有唯一性限制</li>
<li>经常用于where子句查询的字段</li>
<li>经常用于group by 和 order by查询的字段</li>
</ul>
<h2 id="为什么索引如果重复度比较高的时候会对数据库产生一定的压力？"><a href="#为什么索引如果重复度比较高的时候会对数据库产生一定的压力？" class="headerlink" title="为什么索引如果重复度比较高的时候会对数据库产生一定的压力？"></a>为什么索引如果重复度比较高的时候会对数据库产生一定的压力？</h2><ul>
<li>导致页分裂，占用物理空间大：每次数据更新的话，会导致索引进行重新排序，甚至造成页分裂的问题，导致索引查询效率下降，也会在一定程度上造成空间不必要的浪费。</li>
<li>维护成本高：索引重复度比较高也会导致索引字段大小很大，维护空间和时间成本就会变大，占用一定的冗余物理空间</li>
<li>查询效率低：索引重复度比较高可能会匹配到多个符合条件的索引项，进而增加查询的开销，导致查询效率下降。</li>
<li>内存消耗大：如果是5.7的版本，由于MySQL的索引缓存存在的原因，索引重复度高，索引大小也会变大，需要更多的内存去存储这些数据，高内存可能会导致服务器崩溃。</li>
</ul>
<h2 id="创建联合索引失效的情况"><a href="#创建联合索引失效的情况" class="headerlink" title="创建联合索引失效的情况"></a>创建联合索引失效的情况</h2><p>当where子句查询或者order by或者group by查询的时候没有遵循最左匹配原则则会导致查询时联合索引部分失效。</p>
<p>比如:创建索引(a,b,c)，此时<code>select * from user where a = 1 and b = 1 and c = 1;</code>此时均用到了联合索引。</p>
<p>若改成<code>select * from user where a = 1 and b &gt; 1 and c = 1;</code>此时用到了索引的只有a,b，因为索引查询是先对a进行排序，在a相等的情况下，对b再进行排序，最后在b相同的情况下对c进行排序，此时因为b &gt; 1无法直接定位到从哪个索引列开始顺序查询，也就是说对c再进行排序的话无法进一步提高查询速率，所以只有a，b用到了联合索引。</p>
<blockquote>
<p>一条查询语句的顺序是from -&gt; where -&gt; group by -&gt; Having -&gt; select -&gt; order by</p>
</blockquote>
<h2 id="如果有一个联合索引-a-b-c-，如果where子句查询只有a-1-and-c-1，能不能实现走-a-b-c-这个索引查询？"><a href="#如果有一个联合索引-a-b-c-，如果where子句查询只有a-1-and-c-1，能不能实现走-a-b-c-这个索引查询？" class="headerlink" title="如果有一个联合索引(a,b,c)，如果where子句查询只有a = 1 and c = 1，能不能实现走(a,b,c)这个索引查询？"></a>如果有一个联合索引(a,b,c)，如果where子句查询只有a = 1 and c = 1，能不能实现走(a,b,c)这个索引查询？</h2><p>1、如果能够修改a,b,c联合索引的顺序的话，就可以实现，比如改成<code>(a,c,b)</code> 因为联合索引遵循<strong>最左匹配原则</strong>，即先对a排序，在a相同的情况下，对c排序，在c相同的情况下再对b进行排序，最终形成索引B+树。</p>
<p>2、如果不可以修改联合索引的顺序，那么将无法实现走a,b,c形成的联合索引查询，此时只有a = 1能走到联合索引。</p>
<h2 id="目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？"><a href="#目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？" class="headerlink" title="目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？"></a>目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？</h2><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> age , sex , count<span class="comment">(*) from user group by age , sex;</span></span><br><span class="line"><span class="comment">select age , count(*)</span> <span class="keyword">from</span> user <span class="keyword">group</span> <span class="keyword">by</span> age<span class="punctuation">;</span> </span><br></pre></td></tr></table></figure>

<h2 id="有两个集合List如何快速找出相同的元素？"><a href="#有两个集合List如何快速找出相同的元素？" class="headerlink" title="有两个集合List如何快速找出相同的元素？"></a>有两个集合List如何快速找出相同的元素？</h2><p>思路大致如下：</p>
<ol>
<li>创建并初始化两个List类型的链表</li>
<li>将两个List类型的列表转换成HashSet类型</li>
<li>使用HashSet自带的取交集方法<code>set1.retainAll(set2)</code> ，此时set1中保存的就是原set1和set2的交集，即两个集合相同的元素。</li>
</ol>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindCommonElements</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例数据</span></span><br><span class="line">        List&lt;Integer&gt; list1 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用HashSet找出相同元素</span></span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list1);</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list2);</span><br><span class="line"></span><br><span class="line">        set1.retainAll(set2); <span class="comment">// 保留set1中与set2的交集</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set1); <span class="comment">// 输出：[3, 4, 5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构：哈希如何使用？"><a href="#数据结构：哈希如何使用？" class="headerlink" title="数据结构：哈希如何使用？"></a>数据结构：哈希如何使用？</h2><p>「哈希表 Hash Table」通过建立键 <code>key</code> 与值 <code>value</code> 之间的映射，实现高效的元素查询。具体而言，我们向哈希表输入一个 <code>key</code> ，则可以在O(1)时间内获取对应的 <code>value</code> 。</p>
<p>详情见下：</p>
<p><a href="https://www.hello-algo.com/chapter_hashing/hash_map/">哈希表（Hello算法）</a></p>
<h2 id="有一个集合Set怎么批量删除部分元素？"><a href="#有一个集合Set怎么批量删除部分元素？" class="headerlink" title="有一个集合Set怎么批量删除部分元素？"></a>有一个集合Set怎么批量删除部分元素？</h2><p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoveElementsFromSet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 原始Set</span></span><br><span class="line">        Set&lt;Integer&gt; originalSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        originalSet.add(<span class="number">1</span>);</span><br><span class="line">        originalSet.add(<span class="number">2</span>);</span><br><span class="line">        originalSet.add(<span class="number">3</span>);</span><br><span class="line">        originalSet.add(<span class="number">4</span>);</span><br><span class="line">        originalSet.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要删除的元素集合</span></span><br><span class="line">        Set&lt;Integer&gt; elementsToRemove = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        elementsToRemove.add(<span class="number">3</span>);</span><br><span class="line">        elementsToRemove.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 批量删除部分元素</span></span><br><span class="line">        originalSet.removeAll(elementsToRemove);</span><br><span class="line"></span><br><span class="line">        System.out.println(originalSet); <span class="comment">// 输出：[1, 2, 4]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Linux查询一个日志文件的关键字？查询某个关键字的前后500行？"><a href="#Linux查询一个日志文件的关键字？查询某个关键字的前后500行？" class="headerlink" title="Linux查询一个日志文件的关键字？查询某个关键字的前后500行？"></a>Linux查询一个日志文件的关键字？查询某个关键字的前后500行？</h2><p>查询日志文件的某个关键字可以使用grep命令实现，例如:grep ‘关键字’ filePath</p>
<p>查询某个关键字的前后500行：grep -AB 500或者 grep -C 500（-C == -AB）</p>
<h2 id="怎么保证MySQL和Redis的一致性问题"><a href="#怎么保证MySQL和Redis的一致性问题" class="headerlink" title="怎么保证MySQL和Redis的一致性问题"></a>怎么保证MySQL和Redis的一致性问题</h2><p>读请求：先读缓存，如果缓存失效或不存在就让先获取到互斥锁的线程查数据库并回写缓存，让后续的请求直接都缓存即可</p>
<p>写请求：先更新数据库，再删缓存即可（此时可能会出现删缓存失败的场景，可以通过消息队列的方式，采取重试机制，如果删除缓存失败，则通过消息队列再进行一次删除缓存的操作，如果删除成功，则把消息队列里面的删除缓存操作删除即可，避免重复消费，造成不必要的资源浪费）</p>
<h2 id="价格类型的数据Java用什么存储？"><a href="#价格类型的数据Java用什么存储？" class="headerlink" title="价格类型的数据Java用什么存储？"></a>价格类型的数据Java用什么存储？</h2><p>1、BigDecimal（使用String类型的进行转换，才不会导致精度丢失)</p>
<p>2、整数存储（比如：3.14存为314）</p>
<p>3、自定义存储方式，数据库一个字段存整数，一个字段存小数</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-快狗打车实习一面</title>
    <url>/2023/04/15/%E9%9D%A2%E7%BB%8F-%E5%BF%AB%E7%8B%97%E6%89%93%E8%BD%A6%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="Redis的基本数据结构以及应用场景"><a href="#Redis的基本数据结构以及应用场景" class="headerlink" title="Redis的基本数据结构以及应用场景"></a>Redis的基本数据结构以及应用场景</h3><h3 id="Redis的缓存雪崩、击穿以及穿透"><a href="#Redis的缓存雪崩、击穿以及穿透" class="headerlink" title="Redis的缓存雪崩、击穿以及穿透"></a>Redis的缓存雪崩、击穿以及穿透</h3><h3 id="Redis的高可用，如哨兵机制、主从复制"><a href="#Redis的高可用，如哨兵机制、主从复制" class="headerlink" title="Redis的高可用，如哨兵机制、主从复制"></a>Redis的高可用，如哨兵机制、主从复制</h3><h3 id="Redis的内存淘汰策略"><a href="#Redis的内存淘汰策略" class="headerlink" title="Redis的内存淘汰策略"></a>Redis的内存淘汰策略</h3><h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><h3 id="MySQL的引擎区别主要是MyISAM和InnoDB"><a href="#MySQL的引擎区别主要是MyISAM和InnoDB" class="headerlink" title="MySQL的引擎区别主要是MyISAM和InnoDB"></a>MySQL的引擎区别主要是MyISAM和InnoDB</h3><h3 id="MySQL为什么要用B-树？（可以跟B树、HASH树进行比较）"><a href="#MySQL为什么要用B-树？（可以跟B树、HASH树进行比较）" class="headerlink" title="MySQL为什么要用B+树？（可以跟B树、HASH树进行比较）"></a>MySQL为什么要用B+树？（可以跟B树、HASH树进行比较）</h3><h3 id="MySQL的索引失效？"><a href="#MySQL的索引失效？" class="headerlink" title="MySQL的索引失效？"></a>MySQL的索引失效？</h3><h3 id="微布校园存储说说列表是用的什么Redis数据结构？"><a href="#微布校园存储说说列表是用的什么Redis数据结构？" class="headerlink" title="微布校园存储说说列表是用的什么Redis数据结构？"></a>微布校园存储说说列表是用的什么Redis数据结构？</h3><h3 id="微布校园怎么保证Redis和数据库一致性问题？"><a href="#微布校园怎么保证Redis和数据库一致性问题？" class="headerlink" title="微布校园怎么保证Redis和数据库一致性问题？"></a>微布校园怎么保证Redis和数据库一致性问题？</h3>]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-睿联校招一面-2023-9-20</title>
    <url>/2023/09/20/%E9%9D%A2%E7%BB%8F-%E7%9D%BF%E8%81%94%E6%A0%A1%E6%8B%9B%E4%B8%80%E9%9D%A2-2023-9-20/</url>
    <content><![CDATA[<h2 id="Linux文件权限有那些？"><a href="#Linux文件权限有那些？" class="headerlink" title="Linux文件权限有那些？"></a>Linux文件权限有那些？</h2><h2 id="怎么控制文件权限？x权限是用来干什么的？"><a href="#怎么控制文件权限？x权限是用来干什么的？" class="headerlink" title="怎么控制文件权限？x权限是用来干什么的？"></a>怎么控制文件权限？x权限是用来干什么的？</h2><h2 id="操作系统中，进程和线程区别？"><a href="#操作系统中，进程和线程区别？" class="headerlink" title="操作系统中，进程和线程区别？"></a>操作系统中，进程和线程区别？</h2><h2 id="操作系统中的交换分区作用"><a href="#操作系统中的交换分区作用" class="headerlink" title="操作系统中的交换分区作用"></a>操作系统中的交换分区作用</h2><h2 id="MySQL中幻读和脏读的区别"><a href="#MySQL中幻读和脏读的区别" class="headerlink" title="MySQL中幻读和脏读的区别"></a>MySQL中幻读和脏读的区别</h2><h2 id="MySQL中聚簇索引和非聚簇索引的区别"><a href="#MySQL中聚簇索引和非聚簇索引的区别" class="headerlink" title="MySQL中聚簇索引和非聚簇索引的区别"></a>MySQL中聚簇索引和非聚簇索引的区别</h2><h2 id="MySQL的乐观锁和悲观锁"><a href="#MySQL的乐观锁和悲观锁" class="headerlink" title="MySQL的乐观锁和悲观锁"></a>MySQL的乐观锁和悲观锁</h2><h2 id="为什么MySQL使用B-树？"><a href="#为什么MySQL使用B-树？" class="headerlink" title="为什么MySQL使用B+树？"></a>为什么MySQL使用B+树？</h2><h2 id="什么子网掩码？有什么用？"><a href="#什么子网掩码？有什么用？" class="headerlink" title="什么子网掩码？有什么用？"></a>什么子网掩码？有什么用？</h2><h2 id="为什么说tcp是流式的传输协议"><a href="#为什么说tcp是流式的传输协议" class="headerlink" title="为什么说tcp是流式的传输协议"></a>为什么说tcp是流式的传输协议</h2><h2 id="http的常用请求方法"><a href="#http的常用请求方法" class="headerlink" title="http的常用请求方法"></a>http的常用请求方法</h2><h2 id="URL的组成部分"><a href="#URL的组成部分" class="headerlink" title="URL的组成部分"></a>URL的组成部分</h2><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><h2 id="https如何保证传输安全"><a href="#https如何保证传输安全" class="headerlink" title="https如何保证传输安全"></a>https如何保证传输安全</h2><h2 id="刚刚提到的https的密匙协商是什么样的过程？"><a href="#刚刚提到的https的密匙协商是什么样的过程？" class="headerlink" title="刚刚提到的https的密匙协商是什么样的过程？"></a>刚刚提到的https的密匙协商是什么样的过程？</h2><h2 id="Java面向对象的多态的理解"><a href="#Java面向对象的多态的理解" class="headerlink" title="Java面向对象的多态的理解"></a>Java面向对象的多态的理解</h2><h2 id="快排的思想"><a href="#快排的思想" class="headerlink" title="快排的思想"></a>快排的思想</h2><h2 id="JWT的组成，以及怎么后端校验此token是否有效的？"><a href="#JWT的组成，以及怎么后端校验此token是否有效的？" class="headerlink" title="JWT的组成，以及怎么后端校验此token是否有效的？"></a>JWT的组成，以及怎么后端校验此token是否有效的？</h2><h2 id="雪花算法怎么实现不重复的？（从组成的角度回答）"><a href="#雪花算法怎么实现不重复的？（从组成的角度回答）" class="headerlink" title="雪花算法怎么实现不重复的？（从组成的角度回答）"></a>雪花算法怎么实现不重复的？（从组成的角度回答）</h2>]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
</search>
